name: 'Create Release Branch from Tag'
description: 'Creates a release branch for tags with patch version 0 (e.g., v1.0.0, v2.0.0)'

inputs:
  tag-prefix:
    description: 'Prefix used for tags (e.g., "v" for v1.0.0)'
    required: false
    default: 'v'
  branch-prefix:
    description: 'Prefix used for branch names'
    required: false
    default: 'release-'
  github-token:
    description: 'GitHub token for API access'
    required: true

outputs:
  branch-name:
    description: 'Name of the created branch'
    value: ${{ steps.script.outputs.branch-name }}
  created:
    description: 'Whether a branch was created (true/false)'
    value: ${{ steps.script.outputs.created }}
  skipped-reason:
    description: 'Reason why branch creation was skipped (if applicable)'
    value: ${{ steps.script.outputs.skipped-reason }}

runs:
  using: "composite"
  steps:
    - id: script
      uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
      if: startsWith(github.ref, 'refs/tags/') && !startsWith(github.ref, 'refs/tags/dummy')
      env:
        TAG_PREFIX: ${{ inputs.tag-prefix }}
        BRANCH_PREFIX: ${{ inputs.branch-prefix }}
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          try {
            // Configuration
            const tagPrefix = process.env.TAG_PREFIX;
            const branchPrefix = process.env.BRANCH_PREFIX;

            // Extract the tag name from the Git reference
            const tagName = context.ref.replace('refs/tags/', '');

            // Validate if this is a semantic version tag
            const versionRegex = new RegExp(`^${tagPrefix}?(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`);
            const versionMatch = tagName.match(versionRegex);

            if (!versionMatch) {
              core.setOutput('created', 'false');
              core.setOutput('skipped-reason', 'Not a valid semantic version tag');
              return;
            }

            // Extract version components
            const major = parseInt(versionMatch[1]);
            const minor = parseInt(versionMatch[2]);
            const patch = parseInt(versionMatch[3]);

            // Only create release branches for patch version 0
            if (patch !== 0) {
              core.setOutput('created', 'false');
              core.setOutput('skipped-reason', `Patch version is ${patch}, only creating branches for .0 releases`);
              console.log(`Skipping branch creation: Patch version is ${patch}, not 0`);
              return;
            }

            // Set branch name
            const branchName = `${branchPrefix}v${major}.${minor}`;

            // Get tag SHA
            console.log(`Getting SHA for tag ${tagName}...`);
            const tagResponse = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${tagName}`
            });

            const tagSha = tagResponse.data.object.sha;
            console.log(`Tag SHA: ${tagSha}`);

            // Create branch reference
            console.log(`Creating branch ${branchName} from tag ${tagName}...`);

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: tagSha
              });
              
              console.log(`✅ Successfully created branch ${branchName} from tag ${tagName}`);
              core.setOutput('branch-name', branchName);
              core.setOutput('created', 'true');
            } catch (error) {
              if (error.status === 422 && error.message.includes('already exists')) {
                console.log(`⚠️ Branch ${branchName} already exists`);
                core.setOutput('branch-name', branchName);
                core.setOutput('created', 'false');
                core.setOutput('skipped-reason', 'Branch already exists');
              } else {
                throw error;
              }
            }
          } catch (error) {
            core.setFailed(`Error fetching tag SHA: ${error.message}`);
            return;
          }
