name: Label Pull Requests

on:
  pull_request:
    types:
      - opened
      - reopened
      - unlabeled

permissions:
  pull-requests: write

jobs:
  external-contributor:
    runs-on: ubuntu-latest
    steps:
      - name: Check Author Association and Label PR
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              console.log("Could not get PR from context");
              return;
            }

            // Define associations considered "internal"
            const internalAssociations = ["MEMBER"];

            // Label to add if the author is external
            const externalLabel = "external-contributor";

            const authorAssociation = pr.author_association;
            const isExternal = !internalAssociations.includes(authorAssociation);

            const prLabels = pr.labels.map(label => label.name);
            const hasExternalLabel = prLabels.includes(externalLabel);

            console.log(`Event: ${context.eventName}, Action: ${context.payload.action}`);
            console.log(`Author: ${pr.user.login}, Association: ${authorAssociation}, Is External: ${isExternal}`);
            console.log(`Current PR Labels: ${prLabels.join(', ')}`);

            // Logic for 'unlabeled' event: only re-add if *our* label was removed and author is still external
            if (context.eventName === 'pull_request_target' && context.payload.action === 'unlabeled') {
              const removedLabel = context.payload.label.name;
              console.log(`Label removed: ${removedLabel}`);
              if (removedLabel === externalLabel && isExternal) {
                console.log(`External label was removed, author is still external. Re-adding label: ${externalLabel}`);
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [externalLabel]
                });
                console.log(`Label "${externalLabel}" re-added successfully.`);
              } else {
                console.log(`Removed label was not the external label or author is not external. No action needed for unlabeled event.`);
              }
            }
            // Logic for 'opened' or 'reopened' events: add label if external and not already present
            else if (['opened', 'reopened'].includes(context.payload.action)) {
              if (isExternal && !hasExternalLabel) {
                console.log(`Author association "${authorAssociation}" is external and label is missing. Adding label: ${externalLabel}`);
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [externalLabel]
                });
                console.log(`Label "${externalLabel}" added successfully.`);
              } else if (isExternal && hasExternalLabel) {
                 console.log(`Author is external, but label "${externalLabel}" is already present.`);
              } else {
                console.log(`Author association "${authorAssociation}" is internal or label already present. No label added.`);
              }
            }
            // Optional: Add logic for 'synchronize' if you uncomment it in the 'on:' section
            // else if (context.payload.action === 'synchronize') { ... }
            else {
              console.log(`Unhandled action type: ${context.payload.action}. No labeling action taken.`);
            }
