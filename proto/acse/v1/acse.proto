syntax = "proto3";

package acse.v1;

import "attributes/v1/attributes.proto";
import "buf/validate/validate.proto";
import "common/v1/common.proto";
import "google/api/annotations.proto";

/*
   Access Control Subject Encoding (ACSE):  Structures supporting the mapping of Subjects and Attributes (e.g. Entitlement)
*/

/**
   Define a mapping of an subject attribute to subject using a rule:
   <subject.subjectAttribute> <operator IN/NOT_IN> [subjectValue]

   Example subject mapping of a subject with nationality = CZE entitled to attribute relto:ZCE
   From Existing Policy: "http://demo.com/attr/relto/value/CZE": {"nationality": ["CZE"]}
   To Subject Mapping Policy:
   {
     attributeValueFQN: "http://demo.com/attr/relto/value/CZE"
     subjectAttribute: "nationality"
     subjectValues: ["CZE"]
     operator: "IN"
   }

*/
message SubjectMapping {
  common.v1.ResourceDescriptor descriptor = 1;

  enum Operator {
    OPERATOR_UNSPECIFIED = 0;
    OPERATOR_IN = 1;
    OPERATOR_NOT_IN = 2;
  }
  //TODO should this be a list of values?
  // Attribute Value to be mapped to
  attributes.v1.AttributeValueReference attribute_value_ref = 2;
  // Resource Attribute Key; NOT Attribute Definition Attribute name
  string subject_attribute = 3;
  // The list of comparison values for a resource's <attribute> value
  repeated string subject_values = 4;
  // the operator
  Operator operator = 5 [
    (buf.validate.field).enum.defined_only = true,
    (buf.validate.field).required = true
  ];
  //TODO future - add features or idea of pattern/regex like ACSE?  like username regex to pull domain from subject attribute
  // or treat the subject values as regex patterns applied to subject attribute
}

message GetSubjectMappingRequest {
  int32 id = 1 [(buf.validate.field).required = true];
}
message GetSubjectMappingResponse {
  SubjectMapping subject_mapping = 1;
}

message ListSubjectMappingsRequest {
  common.v1.ResourceSelector selector = 1;
}
message ListSubjectMappingsResponse {
  repeated SubjectMapping subject_mappings = 1;
}

message CreateSubjectMappingRequest {
  SubjectMapping subject_mapping = 1 [(buf.validate.field).required = true];
}
message CreateSubjectMappingResponse {}

message UpdateSubjectMappingRequest {
  int32 id = 1 [(buf.validate.field).required = true];
  SubjectMapping subject_mapping = 2 [(buf.validate.field).required = true];
}
message UpdateSubjectMappingResponse {}

message DeleteSubjectMappingRequest {
  int32 id = 1 [(buf.validate.field).required = true];
}
message DeleteSubjectMappingResponse {}

service SubjectEncodingService {
  rpc ListSubjectMappings(ListSubjectMappingsRequest) returns (ListSubjectMappingsResponse) {
    option (google.api.http) = {get: "/v1/encoding/subject/mappings"};
  }
  rpc GetSubjectMapping(GetSubjectMappingRequest) returns (GetSubjectMappingResponse) {
    option (google.api.http) = {get: "/v1/encoding/subject/mappings/{id}"};
  }

  rpc CreateSubjectMapping(CreateSubjectMappingRequest) returns (CreateSubjectMappingResponse) {
    option (google.api.http) = {
      post: "/v1/encoding/subject/mappings"
      body: "subject_mapping"
    };
  }

  rpc UpdateSubjectMapping(UpdateSubjectMappingRequest) returns (UpdateSubjectMappingResponse) {
    option (google.api.http) = {
      post: "/v1/encoding/subject/mappings/{id}"
      body: "subject_mapping"
    };
  }

  rpc DeleteSubjectMapping(DeleteSubjectMappingRequest) returns (DeleteSubjectMappingResponse) {
    option (google.api.http) = {delete: "/v1/encoding/subjects/mappings/{id}"};
  }
}
