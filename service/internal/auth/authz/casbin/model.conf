# Casbin Model v2 - RPC + Dimensions Authorization
#
# This model replaces the legacy path+action model with a cleaner RPC+dimensions approach:
#   - sub: subject (roles extracted from JWT, or username)
#   - rpc: full gRPC method path (e.g., /policy.attributes.AttributesService/UpdateAttribute)
#   - dims: resolved authorization dimensions (e.g., namespace=hr&attribute=classification)
#
# The 'action' field from v1 is removed as the RPC method itself implies the operation.
# This simplifies policy when the gRPC Gateway is removed.
#
# ================================
# Dimension Serialization Format
# ================================
#
# Request dimensions are serialized as: key1=value1&key2=value2
#   - Keys are sorted alphabetically for canonical ordering
#   - '&' is the delimiter between key-value pairs (AND semantics)
#   - '=' separates key from value
#   - Empty dimensions serialize to "*"
#
# Policy dimension patterns:
#   - "*"                    : Wildcard, matches any dimensions (including empty)
#   - "namespace=hr"         : Match single dimension exactly
#   - "namespace=*"          : Match any value for 'namespace' key
#   - "namespace=hr&attr=x"  : Match multiple dimensions (AND logic)
#
# Matching rules (dimensionMatch function):
#   - Policy "*" matches everything
#   - Each policy dimension must be satisfied by the request
#   - Policy can omit dimensions (partial match OK)
#   - Request can have extra dimensions not in policy (OK)
#   - Use multiple policy lines for OR logic
#
# Example policies:
#   p, role:admin, *, *, allow                                           # Admin can do anything
#   p, role:hr-admin, /policy.attributes.AttributesService/*, namespace=hr, allow  # HR admin on HR namespace
#   p, role:viewer, /policy.*/Get*, *, allow                             # Viewer can read any policy service

[request_definition]
r = sub, rpc, dims

[policy_definition]
p = sub, rpc, dims, eft

[role_definition]
g = _, _

[policy_effect]
# Allow if any policy explicitly allows AND no policy explicitly denies
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
# g(r.sub, p.sub): role/group membership check
# keyMatch(r.rpc, p.rpc): RPC path matching with wildcards
# dimensionMatch(r.dims, p.dims): custom function for dimension matching
m = g(r.sub, p.sub) && keyMatch(r.rpc, p.rpc) && dimensionMatch(r.dims, p.dims)
