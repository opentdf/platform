// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomAction = `-- name: createCustomAction :one
INSERT INTO actions (name, metadata, is_standard)
VALUES ($1, $2, FALSE)
RETURNING id
`

type createCustomActionParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// createCustomAction
//
//	INSERT INTO actions (name, metadata, is_standard)
//	VALUES ($1, $2, FALSE)
//	RETURNING id
func (q *Queries) createCustomAction(ctx context.Context, arg createCustomActionParams) (string, error) {
	row := q.db.QueryRow(ctx, createCustomAction, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createOrListActionsByName = `-- name: createOrListActionsByName :many
WITH input_actions AS (
    SELECT unnest($1::text[]) AS name
),
new_actions AS (
    INSERT INTO actions (name, is_standard)
    SELECT 
        input.name, 
        FALSE -- custom actions
    FROM input_actions input
    WHERE NOT EXISTS (
        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
    )
    ON CONFLICT (name) DO NOTHING
    RETURNING id, name, is_standard, created_at
),
all_actions AS (
    -- Get existing actions that match input names
    SELECT a.id, a.name, a.is_standard, a.created_at, 
           TRUE AS pre_existing
    FROM actions a
    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
    
    UNION ALL
    
    -- Include newly created actions
    SELECT id, name, is_standard, created_at,
           FALSE AS pre_existing
    FROM new_actions
)
SELECT 
    id,
    name,
    is_standard,
    created_at,
    pre_existing
FROM all_actions
ORDER BY name
`

type createOrListActionsByNameRow struct {
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	IsStandard  bool               `json:"is_standard"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	PreExisting bool               `json:"pre_existing"`
}

// createOrListActionsByName
//
//	WITH input_actions AS (
//	    SELECT unnest($1::text[]) AS name
//	),
//	new_actions AS (
//	    INSERT INTO actions (name, is_standard)
//	    SELECT
//	        input.name,
//	        FALSE -- custom actions
//	    FROM input_actions input
//	    WHERE NOT EXISTS (
//	        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
//	    )
//	    ON CONFLICT (name) DO NOTHING
//	    RETURNING id, name, is_standard, created_at
//	),
//	all_actions AS (
//	    -- Get existing actions that match input names
//	    SELECT a.id, a.name, a.is_standard, a.created_at,
//	           TRUE AS pre_existing
//	    FROM actions a
//	    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
//
//	    UNION ALL
//
//	    -- Include newly created actions
//	    SELECT id, name, is_standard, created_at,
//	           FALSE AS pre_existing
//	    FROM new_actions
//	)
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    created_at,
//	    pre_existing
//	FROM all_actions
//	ORDER BY name
func (q *Queries) createOrListActionsByName(ctx context.Context, actionNames []string) ([]createOrListActionsByNameRow, error) {
	rows, err := q.db.Query(ctx, createOrListActionsByName, actionNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []createOrListActionsByNameRow
	for rows.Next() {
		var i createOrListActionsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsStandard,
			&i.CreatedAt,
			&i.PreExisting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCustomAction = `-- name: deleteCustomAction :execrows
DELETE FROM actions
WHERE id = $1
  AND is_standard = FALSE
`

// deleteCustomAction
//
//	DELETE FROM actions
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) deleteCustomAction(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCustomAction, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAction = `-- name: getAction :one
SELECT 
    a.id,
    a.name,
    a.is_standard,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', a.metadata -> 'labels', 'created_at', a.created_at, 'updated_at', a.updated_at)) AS metadata
FROM actions a
WHERE 
  ($1::uuid IS NULL OR a.id = $1::uuid)
  AND ($2::text IS NULL OR a.name = $2::text)
`

type getActionParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type getActionRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	IsStandard bool   `json:"is_standard"`
	Metadata   []byte `json:"metadata"`
}

// getAction
//
//	SELECT
//	    a.id,
//	    a.name,
//	    a.is_standard,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', a.metadata -> 'labels', 'created_at', a.created_at, 'updated_at', a.updated_at)) AS metadata
//	FROM actions a
//	WHERE
//	  ($1::uuid IS NULL OR a.id = $1::uuid)
//	  AND ($2::text IS NULL OR a.name = $2::text)
func (q *Queries) getAction(ctx context.Context, arg getActionParams) (getActionRow, error) {
	row := q.db.QueryRow(ctx, getAction, arg.ID, arg.Name)
	var i getActionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsStandard,
		&i.Metadata,
	)
	return i, err
}

const listActions = `-- name: listActions :many

WITH counted AS (
    SELECT COUNT(id) AS total FROM actions
)
SELECT 
    a.id,
    a.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
        'labels', a.metadata -> 'labels', 
        'created_at', a.created_at, 
        'updated_at', a.updated_at
    )) as metadata,
    a.is_standard,
    counted.total
FROM actions a
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type listActionsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listActionsRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	Metadata   []byte `json:"metadata"`
	IsStandard bool   `json:"is_standard"`
	Total      int64  `json:"total"`
}

// --------------------------------------------------------------
// ACTIONS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total FROM actions
//	)
//	SELECT
//	    a.id,
//	    a.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	        'labels', a.metadata -> 'labels',
//	        'created_at', a.created_at,
//	        'updated_at', a.updated_at
//	    )) as metadata,
//	    a.is_standard,
//	    counted.total
//	FROM actions a
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listActions(ctx context.Context, arg listActionsParams) ([]listActionsRow, error) {
	rows, err := q.db.Query(ctx, listActions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listActionsRow
	for rows.Next() {
		var i listActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.IsStandard,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomAction = `-- name: updateCustomAction :execrows
UPDATE actions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
  AND is_standard = FALSE
`

type updateCustomActionParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateCustomAction
//
//	UPDATE actions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) updateCustomAction(ctx context.Context, arg updateCustomActionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCustomAction, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
