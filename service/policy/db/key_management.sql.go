// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: key_management.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProviderConfig = `-- name: createProviderConfig :one

WITH inserted AS (
  INSERT INTO provider_config (provider_name, config, metadata)
  VALUES ($1, $2, $3)
  RETURNING id, provider_name, config, created_at, updated_at, metadata
)
SELECT 
  id,
  provider_name,
  config,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', metadata -> 'labels',         
      'created_at', created_at,               
      'updated_at', updated_at                
    )
  ) AS metadata
FROM inserted
`

type createProviderConfigParams struct {
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

type createProviderConfigRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

// --------------------------------------------------------------
// Provider Config
// --------------------------------------------------------------
//
//	WITH inserted AS (
//	  INSERT INTO provider_config (provider_name, config, metadata)
//	  VALUES ($1, $2, $3)
//	  RETURNING id, provider_name, config, created_at, updated_at, metadata
//	)
//	SELECT
//	  id,
//	  provider_name,
//	  config,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', metadata -> 'labels',
//	      'created_at', created_at,
//	      'updated_at', updated_at
//	    )
//	  ) AS metadata
//	FROM inserted
func (q *Queries) createProviderConfig(ctx context.Context, arg createProviderConfigParams) (createProviderConfigRow, error) {
	row := q.db.QueryRow(ctx, createProviderConfig, arg.ProviderName, arg.Config, arg.Metadata)
	var i createProviderConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProviderName,
		&i.Config,
		&i.Metadata,
	)
	return i, err
}

const deleteProviderConfig = `-- name: deleteProviderConfig :execrows
DELETE FROM provider_config 
WHERE id = $1
`

// deleteProviderConfig
//
//	DELETE FROM provider_config
//	WHERE id = $1
func (q *Queries) deleteProviderConfig(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProviderConfig, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getProviderConfig = `-- name: getProviderConfig :one
SELECT 
    pc.id,
    pc.provider_name,
    pc.config,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata
FROM provider_config AS pc
WHERE ($1::uuid IS NULL OR pc.id = $1::uuid)
  AND ($2::text IS NULL OR pc.provider_name = $2::text)
`

type getProviderConfigParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type getProviderConfigRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

// getProviderConfig
//
//	SELECT
//	    pc.id,
//	    pc.provider_name,
//	    pc.config,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata
//	FROM provider_config AS pc
//	WHERE ($1::uuid IS NULL OR pc.id = $1::uuid)
//	  AND ($2::text IS NULL OR pc.provider_name = $2::text)
func (q *Queries) getProviderConfig(ctx context.Context, arg getProviderConfigParams) (getProviderConfigRow, error) {
	row := q.db.QueryRow(ctx, getProviderConfig, arg.ID, arg.Name)
	var i getProviderConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProviderName,
		&i.Config,
		&i.Metadata,
	)
	return i, err
}

const listKeyMappings = `-- name: listKeyMappings :many
WITH filtered_keys AS (
    -- Get all keys matching the filter criteria
    SELECT
        kask.created_at,
        kask.id AS id,
        kask.key_id AS kid,
        kas.id AS kas_id,
        kas.uri AS kas_uri
    FROM key_access_server_keys kask
    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
    WHERE (
        -- Case 1: Filter by system key ID if provided
        ($3::uuid IS NOT NULL AND kask.id = $3::uuid)
        -- Case 2: Filter by KID + at least one KAS identifier
        OR (
            $4::text IS NOT NULL 
            AND kask.key_id = $4::text
            AND (
                ($5::uuid IS NOT NULL AND kas.id = $5::uuid)
                OR ($6::text IS NOT NULL AND kas.name = $6::text)
                OR ($7::text IS NOT NULL AND kas.uri = $7::text)
            )
        )
        -- Case 3: Return all keys if no filters are provided
        OR (
            $3::uuid IS NULL 
            AND $4::text IS NULL
        )
    )
),
keys_with_mappings AS (
    SELECT id
    FROM filtered_keys fk
    WHERE EXISTS (
        SELECT 1 FROM attribute_namespace_public_key_map anpm WHERE anpm.key_access_server_key_id = fk.id
    ) OR EXISTS (
        SELECT 1 FROM attribute_definition_public_key_map adpm WHERE adpm.key_access_server_key_id = fk.id
    ) OR EXISTS (
        SELECT 1 FROM attribute_value_public_key_map avpm WHERE avpm.key_access_server_key_id = fk.id
    )
),
keys_with_mappings_count AS (
    SELECT COUNT(*) AS total FROM keys_with_mappings
),
namespace_mappings AS (
    -- Get namespace mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', anpm.namespace_id,
                'fqn', fqns.fqn
            )
        ) FILTER (WHERE anpm.namespace_id IS NOT NULL) AS namespace_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_namespace_public_key_map anpm ON fk.id = anpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON anpm.namespace_id = fqns.namespace_id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    GROUP BY fk.id
),
definition_mappings AS (
    -- Get attribute definition mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', adpm.definition_id,
                'fqn', fqns.fqn
            )
        ) FILTER (WHERE adpm.definition_id IS NOT NULL) AS definition_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_definition_public_key_map adpm ON fk.id = adpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON adpm.definition_id = fqns.attribute_id AND fqns.value_id IS NULL
    GROUP BY fk.id
),
value_mappings AS (
    -- Get attribute value mappings for each key
    SELECT 
        fk.id as key_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', avpm.value_id,
                'fqn', fqns.fqn
            )
        ) FILTER (WHERE avpm.value_id IS NOT NULL) AS value_mappings
    FROM filtered_keys fk
    INNER JOIN attribute_value_public_key_map avpm ON fk.id = avpm.key_access_server_key_id
    INNER JOIN attribute_fqns fqns ON avpm.value_id = fqns.value_id
    GROUP BY fk.id
)
SELECT 
    fk.kid,
    fk.kas_uri,
    COALESCE(nm.namespace_mappings, '[]'::json) AS namespace_mappings,
    COALESCE(dm.definition_mappings, '[]'::json) AS attribute_mappings,
    COALESCE(vm.value_mappings, '[]'::json) AS value_mappings,
    kwmc.total
FROM filtered_keys fk
INNER JOIN keys_with_mappings kwm ON fk.id = kwm.id
CROSS JOIN keys_with_mappings_count kwmc
LEFT JOIN namespace_mappings nm ON fk.id = nm.key_id
LEFT JOIN definition_mappings dm ON fk.id = dm.key_id
LEFT JOIN value_mappings vm ON fk.id = vm.key_id
ORDER BY fk.created_at
LIMIT $2 
OFFSET $1
`

type listKeyMappingsParams struct {
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
	ID      pgtype.UUID `json:"id"`
	Kid     pgtype.Text `json:"kid"`
	KasID   pgtype.UUID `json:"kas_id"`
	KasName pgtype.Text `json:"kas_name"`
	KasUri  pgtype.Text `json:"kas_uri"`
}

type listKeyMappingsRow struct {
	Kid               string `json:"kid"`
	KasUri            string `json:"kas_uri"`
	NamespaceMappings []byte `json:"namespace_mappings"`
	AttributeMappings []byte `json:"attribute_mappings"`
	ValueMappings     []byte `json:"value_mappings"`
	Total             int64  `json:"total"`
}

// listKeyMappings
//
//	WITH filtered_keys AS (
//	    -- Get all keys matching the filter criteria
//	    SELECT
//	        kask.created_at,
//	        kask.id AS id,
//	        kask.key_id AS kid,
//	        kas.id AS kas_id,
//	        kas.uri AS kas_uri
//	    FROM key_access_server_keys kask
//	    INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	    WHERE (
//	        -- Case 1: Filter by system key ID if provided
//	        ($3::uuid IS NOT NULL AND kask.id = $3::uuid)
//	        -- Case 2: Filter by KID + at least one KAS identifier
//	        OR (
//	            $4::text IS NOT NULL
//	            AND kask.key_id = $4::text
//	            AND (
//	                ($5::uuid IS NOT NULL AND kas.id = $5::uuid)
//	                OR ($6::text IS NOT NULL AND kas.name = $6::text)
//	                OR ($7::text IS NOT NULL AND kas.uri = $7::text)
//	            )
//	        )
//	        -- Case 3: Return all keys if no filters are provided
//	        OR (
//	            $3::uuid IS NULL
//	            AND $4::text IS NULL
//	        )
//	    )
//	),
//	keys_with_mappings AS (
//	    SELECT id
//	    FROM filtered_keys fk
//	    WHERE EXISTS (
//	        SELECT 1 FROM attribute_namespace_public_key_map anpm WHERE anpm.key_access_server_key_id = fk.id
//	    ) OR EXISTS (
//	        SELECT 1 FROM attribute_definition_public_key_map adpm WHERE adpm.key_access_server_key_id = fk.id
//	    ) OR EXISTS (
//	        SELECT 1 FROM attribute_value_public_key_map avpm WHERE avpm.key_access_server_key_id = fk.id
//	    )
//	),
//	keys_with_mappings_count AS (
//	    SELECT COUNT(*) AS total FROM keys_with_mappings
//	),
//	namespace_mappings AS (
//	    -- Get namespace mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', anpm.namespace_id,
//	                'fqn', fqns.fqn
//	            )
//	        ) FILTER (WHERE anpm.namespace_id IS NOT NULL) AS namespace_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_namespace_public_key_map anpm ON fk.id = anpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON anpm.namespace_id = fqns.namespace_id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    GROUP BY fk.id
//	),
//	definition_mappings AS (
//	    -- Get attribute definition mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', adpm.definition_id,
//	                'fqn', fqns.fqn
//	            )
//	        ) FILTER (WHERE adpm.definition_id IS NOT NULL) AS definition_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_definition_public_key_map adpm ON fk.id = adpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON adpm.definition_id = fqns.attribute_id AND fqns.value_id IS NULL
//	    GROUP BY fk.id
//	),
//	value_mappings AS (
//	    -- Get attribute value mappings for each key
//	    SELECT
//	        fk.id as key_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', avpm.value_id,
//	                'fqn', fqns.fqn
//	            )
//	        ) FILTER (WHERE avpm.value_id IS NOT NULL) AS value_mappings
//	    FROM filtered_keys fk
//	    INNER JOIN attribute_value_public_key_map avpm ON fk.id = avpm.key_access_server_key_id
//	    INNER JOIN attribute_fqns fqns ON avpm.value_id = fqns.value_id
//	    GROUP BY fk.id
//	)
//	SELECT
//	    fk.kid,
//	    fk.kas_uri,
//	    COALESCE(nm.namespace_mappings, '[]'::json) AS namespace_mappings,
//	    COALESCE(dm.definition_mappings, '[]'::json) AS attribute_mappings,
//	    COALESCE(vm.value_mappings, '[]'::json) AS value_mappings,
//	    kwmc.total
//	FROM filtered_keys fk
//	INNER JOIN keys_with_mappings kwm ON fk.id = kwm.id
//	CROSS JOIN keys_with_mappings_count kwmc
//	LEFT JOIN namespace_mappings nm ON fk.id = nm.key_id
//	LEFT JOIN definition_mappings dm ON fk.id = dm.key_id
//	LEFT JOIN value_mappings vm ON fk.id = vm.key_id
//	ORDER BY fk.created_at
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listKeyMappings(ctx context.Context, arg listKeyMappingsParams) ([]listKeyMappingsRow, error) {
	rows, err := q.db.Query(ctx, listKeyMappings,
		arg.Offset,
		arg.Limit,
		arg.ID,
		arg.Kid,
		arg.KasID,
		arg.KasName,
		arg.KasUri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listKeyMappingsRow
	for rows.Next() {
		var i listKeyMappingsRow
		if err := rows.Scan(
			&i.Kid,
			&i.KasUri,
			&i.NamespaceMappings,
			&i.AttributeMappings,
			&i.ValueMappings,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviderConfigs = `-- name: listProviderConfigs :many
WITH counted AS (
    SELECT COUNT(pc.id) AS total 
    FROM provider_config pc
)
SELECT 
    pc.id,
    pc.provider_name,
    pc.config,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata,
    counted.total
FROM provider_config AS pc
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type listProviderConfigsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listProviderConfigsRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
	Total        int64  `json:"total"`
}

// listProviderConfigs
//
//	WITH counted AS (
//	    SELECT COUNT(pc.id) AS total
//	    FROM provider_config pc
//	)
//	SELECT
//	    pc.id,
//	    pc.provider_name,
//	    pc.config,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata,
//	    counted.total
//	FROM provider_config AS pc
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listProviderConfigs(ctx context.Context, arg listProviderConfigsParams) ([]listProviderConfigsRow, error) {
	rows, err := q.db.Query(ctx, listProviderConfigs, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listProviderConfigsRow
	for rows.Next() {
		var i listProviderConfigsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderName,
			&i.Config,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProviderConfig = `-- name: updateProviderConfig :execrows
UPDATE provider_config
SET
    provider_name = COALESCE($2, provider_name),
    config = COALESCE($3, config),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type updateProviderConfigParams struct {
	ID           string      `json:"id"`
	ProviderName pgtype.Text `json:"provider_name"`
	Config       []byte      `json:"config"`
	Metadata     []byte      `json:"metadata"`
}

// updateProviderConfig
//
//	UPDATE provider_config
//	SET
//	    provider_name = COALESCE($2, provider_name),
//	    config = COALESCE($3, config),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) updateProviderConfig(ctx context.Context, arg updateProviderConfigParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProviderConfig,
		arg.ID,
		arg.ProviderName,
		arg.Config,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
