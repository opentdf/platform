// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AttributeDefinitionRule string

const (
	AttributeDefinitionRuleUNSPECIFIED AttributeDefinitionRule = "UNSPECIFIED"
	AttributeDefinitionRuleALLOF       AttributeDefinitionRule = "ALL_OF"
	AttributeDefinitionRuleANYOF       AttributeDefinitionRule = "ANY_OF"
	AttributeDefinitionRuleHIERARCHY   AttributeDefinitionRule = "HIERARCHY"
)

func (e *AttributeDefinitionRule) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AttributeDefinitionRule(s)
	case string:
		*e = AttributeDefinitionRule(s)
	default:
		return fmt.Errorf("unsupported scan type for AttributeDefinitionRule: %T", src)
	}
	return nil
}

type NullAttributeDefinitionRule struct {
	AttributeDefinitionRule AttributeDefinitionRule `json:"attribute_definition_rule"`
	Valid                   bool                    `json:"valid"` // Valid is true if AttributeDefinitionRule is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAttributeDefinitionRule) Scan(value interface{}) error {
	if value == nil {
		ns.AttributeDefinitionRule, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AttributeDefinitionRule.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAttributeDefinitionRule) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AttributeDefinitionRule), nil
}

// Table to store actions for use in ABAC decisioning
type Action struct {
	// Unique identifier for the action
	ID string `json:"id"`
	// Unique name of the action, e.g. read, write, etc.
	Name string `json:"name"`
	// Whether the action is standard (proto-enum) or custom (user-defined).
	IsStandard bool `json:"is_standard"`
	// Metadata for the action (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// View to retrieve active public keys mapped to attribute definitions
type ActiveDefinitionPublicKeysView struct {
	DefinitionID string `json:"definition_id"`
	Keys         []byte `json:"keys"`
}

// View to retrieve active public keys mapped to attribute namespaces
type ActiveNamespacePublicKeysView struct {
	NamespaceID string `json:"namespace_id"`
	Keys        []byte `json:"keys"`
}

// View to retrieve active public keys mapped to attribute values
type ActiveValuePublicKeysView struct {
	ValueID string `json:"value_id"`
	Keys    []byte `json:"keys"`
}

// Table to store asymmetric keys
type AsymKey struct {
	// Unique identifier for the key
	ID string `json:"id"`
	// Unique identifier for the key
	KeyID string `json:"key_id"`
	// Algorithm used to generate the key
	KeyAlgorithm int32 `json:"key_algorithm"`
	// Indicates the status of the key Active, Inactive, Compromised, or Expired
	KeyStatus int32 `json:"key_status"`
	// Indicates whether the key is stored LOCAL or REMOTE
	KeyMode int32 `json:"key_mode"`
	// Public Key Context is a json defined structure of the public key
	PublicKeyCtx []byte `json:"public_key_ctx"`
	// Private Key Context is a json defined structure of the private key. Could include information like PEM encoded key, or external key id information
	PrivateKeyCtx []byte             `json:"private_key_ctx"`
	Expiration    pgtype.Timestamptz `json:"expiration"`
	// Reference the provider configuration for this key
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	// Additional metadata for the key
	Metadata []byte `json:"metadata"`
	// Timestamp when the key was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the key was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store the definitions of attributes
type AttributeDefinition struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the parent namespace of the attribute definition
	NamespaceID string `json:"namespace_id"`
	// Name of the attribute (i.e. organization or classification), unique within the namespace
	Name string `json:"name"`
	// Rule for the attribute (see protos for options)
	Rule AttributeDefinitionRule `json:"rule"`
	// Metadata for the attribute definition (see protos for structure)
	Metadata []byte `json:"metadata"`
	// Active/Inactive state
	Active    bool               `json:"active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Order of value ids for the attribute (important for hierarchy rule)
	ValuesOrder []string `json:"values_order"`
}

// Table to store the grants of key access servers (KASs) to attribute definitions
type AttributeDefinitionKeyAccessGrant struct {
	// Foreign key to the attribute definition
	AttributeDefinitionID string `json:"attribute_definition_id"`
	// Foreign key to the KAS registration
	KeyAccessServerID string `json:"key_access_server_id"`
}

// Table to map public keys to attribute definitions
type AttributeDefinitionPublicKeyMap struct {
	// Foreign key to the attribute definition
	DefinitionID string `json:"definition_id"`
	// Foreign key to the key access server public key for wrapping symmetric keys
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// Table to store the fully qualified names of attributes for reverse lookup at their object IDs
type AttributeFqn struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the namespace of the attribute
	NamespaceID pgtype.UUID `json:"namespace_id"`
	// Foreign key to the attribute definition
	AttributeID pgtype.UUID `json:"attribute_id"`
	// Foreign key to the attribute value
	ValueID pgtype.UUID `json:"value_id"`
	// Fully qualified name of the attribute (i.e. https://<namespace>/attr/<attribute name>/value/<value>)
	Fqn string `json:"fqn"`
}

// Table to store the parent namespaces of platform policy attributes and related policy objects
type AttributeNamespace struct {
	// Primary key for the table
	ID string `json:"id"`
	// Name of the namespace (i.e. example.com)
	Name string `json:"name"`
	// Active/Inactive state
	Active bool `json:"active"`
	// Metadata for the namespace (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store the grants of key access servers (KASs) to attribute namespaces
type AttributeNamespaceKeyAccessGrant struct {
	// Foreign key to the namespace of the KAS grant
	NamespaceID string `json:"namespace_id"`
	// Foreign key to the KAS registration
	KeyAccessServerID string `json:"key_access_server_id"`
}

// Table to map public keys to attribute namespaces
type AttributeNamespacePublicKeyMap struct {
	// Foreign key to the attribute namespace
	NamespaceID string `json:"namespace_id"`
	// Foreign key to the key access server public key for wrapping symmetric keys
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// Table to store the values of attributes
type AttributeValue struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the parent attribute definition
	AttributeDefinitionID string `json:"attribute_definition_id"`
	// Value of the attribute (i.e. "manager" or "admin" on an attribute for titles), unique within the definition
	Value string `json:"value"`
	// Metadata for the attribute value (see protos for structure)
	Metadata []byte `json:"metadata"`
	// Active/Inactive state
	Active    bool               `json:"active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store the grants of key access servers (KASs) to attribute values
type AttributeValueKeyAccessGrant struct {
	// Foreign key to the attribute value
	AttributeValueID string `json:"attribute_value_id"`
	// Foreign key to the KAS registration
	KeyAccessServerID string `json:"key_access_server_id"`
}

// Table to map public keys to attribute values
type AttributeValuePublicKeyMap struct {
	// Foreign key to the attribute value
	ValueID string `json:"value_id"`
	// Foreign key to the key access server public key for wrapping symmetric keys
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

type BaseKey struct {
	ID                   string      `json:"id"`
	KeyAccessServerKeyID pgtype.UUID `json:"key_access_server_key_id"`
}

// Table to store the known registrations of key access servers (KASs)
type KeyAccessServer struct {
	// Primary key for the table
	ID string `json:"id"`
	// URI of the KAS
	Uri string `json:"uri"`
	// Public key of the KAS (see protos for structure/options)
	PublicKey []byte `json:"public_key"`
	// Metadata for the KAS (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Optional common name of the KAS
	Name       pgtype.Text `json:"name"`
	SourceType pgtype.Text `json:"source_type"`
}

type KeyAccessServerKey struct {
	// Unique identifier for the key
	ID string `json:"id"`
	// Unique identifier for the key
	KeyID string `json:"key_id"`
	// Algorithm used to generate the key
	KeyAlgorithm int32 `json:"key_algorithm"`
	// Indicates the status of the key Active, Inactive, Compromised, or Expired
	KeyStatus int32 `json:"key_status"`
	// Indicates whether the key is stored LOCAL or REMOTE
	KeyMode int32 `json:"key_mode"`
	// Public Key Context is a json defined structure of the public key
	PublicKeyCtx []byte `json:"public_key_ctx"`
	// Private Key Context is a json defined structure of the private key. Could include information like PEM encoded key, or external key id information
	PrivateKeyCtx []byte             `json:"private_key_ctx"`
	Expiration    pgtype.Timestamptz `json:"expiration"`
	// Reference the provider configuration for this key
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	// Additional metadata for the key
	Metadata []byte `json:"metadata"`
	// Timestamp when the key was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the key was last updated
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	KeyAccessServerID string             `json:"key_access_server_id"`
}

// Table to store key provider configurations
type ProviderConfig struct {
	// Unique identifier for the provider configuration
	ID string `json:"id"`
	// Unique name for the key provider.
	ProviderName string `json:"provider_name"`
	// Configuration details for the key provider
	Config []byte `json:"config"`
	// Timestamp when the provider configuration was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the provider configuration was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Additional metadata for the provider configuration
	Metadata []byte `json:"metadata"`
}

// Table to store registered resources
type RegisteredResource struct {
	// Primary key for the table
	ID string `json:"id"`
	// Name for the registered resource
	Name string `json:"name"`
	// Metadata for the registered resource (see protos for structure)
	Metadata []byte `json:"metadata"`
	// Timestamp when the record was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the record was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store the linkage of registered resource values to actions and attribute values
type RegisteredResourceActionAttributeValue struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the registered_resource_values table
	RegisteredResourceValueID string `json:"registered_resource_value_id"`
	// Foreign key to the actions table
	ActionID string `json:"action_id"`
	// Foreign key to the attribute_values table
	AttributeValueID string `json:"attribute_value_id"`
	// Timestamp when the record was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the record was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store registered resource values
type RegisteredResourceValue struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the registered_resources table
	RegisteredResourceID string `json:"registered_resource_id"`
	// Value for the registered resource value
	Value string `json:"value"`
	// Metadata for the registered resource value (see protos for structure)
	Metadata []byte `json:"metadata"`
	// Timestamp when the record was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the record was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Table to store associated terms that should map resource data to attribute values
type ResourceMapping struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the attribute value
	AttributeValueID string `json:"attribute_value_id"`
	// Terms to match against resource data (i.e. translations "roi", "rey", or "kung" in a terms list could map to the value "/attr/card/value/king")
	Terms []string `json:"terms"`
	// Metadata for the resource mapping (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Foreign key to the parent group of the resource mapping (optional, a resource mapping may not be in a group)
	GroupID pgtype.UUID `json:"group_id"`
}

// Table to store the groups of resource mappings by unique namespace and group name combinations
type ResourceMappingGroup struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the namespace of the attribute
	NamespaceID string `json:"namespace_id"`
	// Name for the group of resource mappings
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Metadata  []byte             `json:"metadata"`
}

// Table to store sets of conditions that logically entitle subject entity representations to attribute values via a subject mapping
type SubjectConditionSet struct {
	// Primary key for the table
	ID string `json:"id"`
	// Conditions that must be met for the subject entity to be entitled to the attribute value (see protos for JSON structure)
	Condition []byte `json:"condition"`
	// Metadata for the condition set (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Array of cached selector values extracted from the condition JSONB and maintained via trigger.
	SelectorValues []string `json:"selector_values"`
}

// Table to store conditions that logically entitle subject entity representations to attribute values
type SubjectMapping struct {
	// Primary key for the table
	ID string `json:"id"`
	// Foreign key to the attribute value
	AttributeValueID string `json:"attribute_value_id"`
	// Metadata for the subject mapping (see protos for structure)
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Foreign key to the condition set that entitles the subject entity to the attribute value
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
}

type SubjectMappingAction struct {
	SubjectMappingID string           `json:"subject_mapping_id"`
	ActionID         string           `json:"action_id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

// Table to store symmetric keys
type SymKey struct {
	// Unique identifier for the key
	ID string `json:"id"`
	// Unique identifier for the key
	KeyID string `json:"key_id"`
	// Indicates the status of the key Active, Inactive, Compromised, or Expired
	KeyStatus int32 `json:"key_status"`
	// Indicates whether the key is stored LOCAL or REMOTE
	KeyMode int32 `json:"key_mode"`
	// Key value in binary format
	KeyValue []byte `json:"key_value"`
	// Reference the provider configuration for this key
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	// Timestamp when the key was created
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	// Timestamp when the key was last updated
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	// Additional metadata for the key
	Metadata   []byte             `json:"metadata"`
	Expiration pgtype.Timestamptz `json:"expiration"`
}
