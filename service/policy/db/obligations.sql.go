// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: obligations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createObligation = `-- name: createObligation :one

WITH inserted_obligation AS (
    INSERT INTO obligation_definitions (namespace_id, name, metadata)
    SELECT 
        COALESCE($1::uuid, fqns.namespace_id),
        $2, 
        $3
    FROM (
        SELECT 
            $1::uuid as direct_namespace_id
    ) direct
    LEFT JOIN attribute_fqns fqns ON fqns.fqn = $4::text AND $1::text IS NULL
    WHERE 
        ($1::text IS NOT NULL AND direct.direct_namespace_id IS NOT NULL) OR
        ($4::text IS NOT NULL AND fqns.namespace_id IS NOT NULL)
    RETURNING id, namespace_id, name, metadata
),
inserted_values AS (
    INSERT INTO obligation_values_standard (obligation_definition_id, value)
    SELECT io.id, UNNEST($5::VARCHAR[])
    FROM inserted_obligation io
    WHERE $5::VARCHAR[] IS NOT NULL AND array_length($5::VARCHAR[], 1) > 0
    RETURNING id, obligation_definition_id, value
)
SELECT
    io.id,
    io.name,
    io.metadata,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', iv.id,
                'value', iv.value
            )
        ) FILTER (WHERE iv.id IS NOT NULL),
        '[]'::JSON
    )::JSONB as values
FROM inserted_obligation io
JOIN attribute_namespaces n ON io.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
GROUP BY io.id, io.name, io.metadata, n.id, fqns.fqn
`

type createObligationParams struct {
	NamespaceID  pgtype.UUID `json:"namespace_id"`
	Name         string      `json:"name"`
	Metadata     []byte      `json:"metadata"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Values       []string    `json:"values"`
}

type createObligationRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Metadata  []byte `json:"metadata"`
	Namespace []byte `json:"namespace"`
	Values    []byte `json:"values"`
}

// --------------------------------------------------------------
// OBLIGATIONS
// --------------------------------------------------------------
//
//	WITH inserted_obligation AS (
//	    INSERT INTO obligation_definitions (namespace_id, name, metadata)
//	    SELECT
//	        COALESCE($1::uuid, fqns.namespace_id),
//	        $2,
//	        $3
//	    FROM (
//	        SELECT
//	            $1::uuid as direct_namespace_id
//	    ) direct
//	    LEFT JOIN attribute_fqns fqns ON fqns.fqn = $4::text AND $1::text IS NULL
//	    WHERE
//	        ($1::text IS NOT NULL AND direct.direct_namespace_id IS NOT NULL) OR
//	        ($4::text IS NOT NULL AND fqns.namespace_id IS NOT NULL)
//	    RETURNING id, namespace_id, name, metadata
//	),
//	inserted_values AS (
//	    INSERT INTO obligation_values_standard (obligation_definition_id, value)
//	    SELECT io.id, UNNEST($5::VARCHAR[])
//	    FROM inserted_obligation io
//	    WHERE $5::VARCHAR[] IS NOT NULL AND array_length($5::VARCHAR[], 1) > 0
//	    RETURNING id, obligation_definition_id, value
//	)
//	SELECT
//	    io.id,
//	    io.name,
//	    io.metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    COALESCE(
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', iv.id,
//	                'value', iv.value
//	            )
//	        ) FILTER (WHERE iv.id IS NOT NULL),
//	        '[]'::JSON
//	    )::JSONB as values
//	FROM inserted_obligation io
//	JOIN attribute_namespaces n ON io.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	LEFT JOIN inserted_values iv ON iv.obligation_definition_id = io.id
//	GROUP BY io.id, io.name, io.metadata, n.id, fqns.fqn
func (q *Queries) createObligation(ctx context.Context, arg createObligationParams) (createObligationRow, error) {
	row := q.db.QueryRow(ctx, createObligation,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
		arg.NamespaceFqn,
		arg.Values,
	)
	var i createObligationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Namespace,
		&i.Values,
	)
	return i, err
}

const createObligationTrigger = `-- name: createObligationTrigger :one

WITH params AS (
    SELECT
        $1::uuid as obligation_value_id,
        $2::uuid as action_id,
        $3::text as action_name,
        $4::uuid as attribute_value_id,
        $5::text as attribute_value_fqn
),
ov_id AS (
    SELECT ov.id, od.namespace_id
    FROM obligation_values_standard ov
    CROSS JOIN params
    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
    WHERE params.obligation_value_id IS NOT NULL AND ov.id = params.obligation_value_id
),
a_id AS (
    SELECT a.id
    FROM actions a
    CROSS JOIN params
    WHERE
        (params.action_id IS NOT NULL AND a.id = params.action_id)
        OR
        (params.action_name IS NOT NULL AND a.name = params.action_name)
),
av_id AS (
    SELECT av.id
    FROM attribute_values av
    CROSS JOIN params
    JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
    LEFT JOIN attribute_fqns fqns ON fqns.value_id = av.id
    WHERE
        ((params.attribute_value_id IS NOT NULL AND av.id = params.attribute_value_id)
        OR
        (params.attribute_value_fqn IS NOT NULL AND fqns.fqn = params.attribute_value_fqn))
        AND ad.namespace_id = (SELECT namespace_id FROM ov_id)
),
inserted AS (
    INSERT INTO obligation_triggers (obligation_value_id, action_id, attribute_value_id, metadata, client_id)
    SELECT
        (SELECT id FROM ov_id),
        (SELECT id FROM a_id),
        (SELECT id FROM av_id),
        $6,
        $7::text
    RETURNING id, obligation_value_id, action_id, attribute_value_id, metadata, created_at, updated_at, client_id
)
SELECT
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'labels', i.metadata -> 'labels',
            'created_at', i.created_at,
            'updated_at', i.updated_at
        )
    ) AS metadata,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'id', i.id,
            'obligation_value', JSON_BUILD_OBJECT(
                'id', ov.id,
                'value', ov.value,
                'obligation', JSON_BUILD_OBJECT(
                    'id', od.id,
                    'name', od.name,
                    'namespace', JSON_BUILD_OBJECT(
                        'id', n.id,
                        'name', n.name,
                        'fqn', COALESCE(ns_fqns.fqn, '')
                    )
                )
            ),
            'action', JSON_BUILD_OBJECT(
                'id', a.id,
                'name', a.name
            ),
            'attribute_value', JSON_BUILD_OBJECT(
                'id', av.id,
                'value', av.value,
                'fqn', COALESCE(av_fqns.fqn, '')
            ),
            'context', CASE
                WHEN i.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                    JSON_BUILD_OBJECT(
                        'pep', JSON_BUILD_OBJECT(
                            'client_id', i.client_id
                        )
                    ))
                ELSE '[]'::JSON
            END
        )
    ) as trigger
FROM inserted i
JOIN obligation_values_standard ov ON i.obligation_value_id = ov.id
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
JOIN actions a ON i.action_id = a.id
JOIN attribute_values av ON i.attribute_value_id = av.id
LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
`

type createObligationTriggerParams struct {
	ObligationValueID pgtype.UUID `json:"obligation_value_id"`
	ActionID          pgtype.UUID `json:"action_id"`
	ActionName        pgtype.Text `json:"action_name"`
	AttributeValueID  pgtype.UUID `json:"attribute_value_id"`
	AttributeValueFqn pgtype.Text `json:"attribute_value_fqn"`
	Metadata          []byte      `json:"metadata"`
	ClientID          pgtype.Text `json:"client_id"`
}

type createObligationTriggerRow struct {
	Metadata []byte `json:"metadata"`
	Trigger  []byte `json:"trigger"`
}

// --------------------------------------------------------------
// OBLIGATION TRIGGERS
// --------------------------------------------------------------
// Gets the attribute value, but also ensures that the attribute value belongs to the same namespace as the obligation, to which the obligation value belongs
//
//	WITH params AS (
//	    SELECT
//	        $1::uuid as obligation_value_id,
//	        $2::uuid as action_id,
//	        $3::text as action_name,
//	        $4::uuid as attribute_value_id,
//	        $5::text as attribute_value_fqn
//	),
//	ov_id AS (
//	    SELECT ov.id, od.namespace_id
//	    FROM obligation_values_standard ov
//	    CROSS JOIN params
//	    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	    WHERE params.obligation_value_id IS NOT NULL AND ov.id = params.obligation_value_id
//	),
//	a_id AS (
//	    SELECT a.id
//	    FROM actions a
//	    CROSS JOIN params
//	    WHERE
//	        (params.action_id IS NOT NULL AND a.id = params.action_id)
//	        OR
//	        (params.action_name IS NOT NULL AND a.name = params.action_name)
//	),
//	av_id AS (
//	    SELECT av.id
//	    FROM attribute_values av
//	    CROSS JOIN params
//	    JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.value_id = av.id
//	    WHERE
//	        ((params.attribute_value_id IS NOT NULL AND av.id = params.attribute_value_id)
//	        OR
//	        (params.attribute_value_fqn IS NOT NULL AND fqns.fqn = params.attribute_value_fqn))
//	        AND ad.namespace_id = (SELECT namespace_id FROM ov_id)
//	),
//	inserted AS (
//	    INSERT INTO obligation_triggers (obligation_value_id, action_id, attribute_value_id, metadata, client_id)
//	    SELECT
//	        (SELECT id FROM ov_id),
//	        (SELECT id FROM a_id),
//	        (SELECT id FROM av_id),
//	        $6,
//	        $7::text
//	    RETURNING id, obligation_value_id, action_id, attribute_value_id, metadata, created_at, updated_at, client_id
//	)
//	SELECT
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'labels', i.metadata -> 'labels',
//	            'created_at', i.created_at,
//	            'updated_at', i.updated_at
//	        )
//	    ) AS metadata,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'id', i.id,
//	            'obligation_value', JSON_BUILD_OBJECT(
//	                'id', ov.id,
//	                'value', ov.value,
//	                'obligation', JSON_BUILD_OBJECT(
//	                    'id', od.id,
//	                    'name', od.name,
//	                    'namespace', JSON_BUILD_OBJECT(
//	                        'id', n.id,
//	                        'name', n.name,
//	                        'fqn', COALESCE(ns_fqns.fqn, '')
//	                    )
//	                )
//	            ),
//	            'action', JSON_BUILD_OBJECT(
//	                'id', a.id,
//	                'name', a.name
//	            ),
//	            'attribute_value', JSON_BUILD_OBJECT(
//	                'id', av.id,
//	                'value', av.value,
//	                'fqn', COALESCE(av_fqns.fqn, '')
//	            ),
//	            'context', CASE
//	                WHEN i.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                    JSON_BUILD_OBJECT(
//	                        'pep', JSON_BUILD_OBJECT(
//	                            'client_id', i.client_id
//	                        )
//	                    ))
//	                ELSE '[]'::JSON
//	            END
//	        )
//	    ) as trigger
//	FROM inserted i
//	JOIN obligation_values_standard ov ON i.obligation_value_id = ov.id
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
//	JOIN actions a ON i.action_id = a.id
//	JOIN attribute_values av ON i.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
func (q *Queries) createObligationTrigger(ctx context.Context, arg createObligationTriggerParams) (createObligationTriggerRow, error) {
	row := q.db.QueryRow(ctx, createObligationTrigger,
		arg.ObligationValueID,
		arg.ActionID,
		arg.ActionName,
		arg.AttributeValueID,
		arg.AttributeValueFqn,
		arg.Metadata,
		arg.ClientID,
	)
	var i createObligationTriggerRow
	err := row.Scan(&i.Metadata, &i.Trigger)
	return i, err
}

const createObligationValue = `-- name: createObligationValue :one

WITH params AS (
    SELECT
        $1::uuid as id,
        $2::text as namespace_fqn,
        $3::text as name
),
obligation_lookup AS (
    SELECT od.id, od.name, od.metadata
    FROM obligation_definitions od
    CROSS JOIN params
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        -- lookup by obligation id OR by namespace fqn + obligation name
        (
            -- lookup by obligation id
            (params.id IS NOT NULL AND od.id = params.id)
            OR
            -- lookup by namespace fqn + obligation name
            (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL 
             AND fqns.fqn = params.namespace_fqn AND od.name = params.name)
        )
),
inserted_value AS (
    INSERT INTO obligation_values_standard (obligation_definition_id, value, metadata)
    SELECT ol.id, $4, $5
    FROM obligation_lookup ol
    RETURNING id, obligation_definition_id, value, metadata
)
SELECT
    iv.id,
    ol.name,
    ol.id as obligation_id,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    iv.metadata as metadata
FROM inserted_value iv
JOIN obligation_lookup ol ON ol.id = iv.obligation_definition_id
JOIN obligation_definitions od ON od.id = ol.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
`

type createObligationValueParams struct {
	ID           pgtype.UUID `json:"id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Name         pgtype.Text `json:"name"`
	Value        string      `json:"value"`
	Metadata     []byte      `json:"metadata"`
}

type createObligationValueRow struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	ObligationID string `json:"obligation_id"`
	Namespace    []byte `json:"namespace"`
	Metadata     []byte `json:"metadata"`
}

// --------------------------------------------------------------
// OBLIGATION VALUES
// --------------------------------------------------------------
//
//	WITH params AS (
//	    SELECT
//	        $1::uuid as id,
//	        $2::text as namespace_fqn,
//	        $3::text as name
//	),
//	obligation_lookup AS (
//	    SELECT od.id, od.name, od.metadata
//	    FROM obligation_definitions od
//	    CROSS JOIN params
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        -- lookup by obligation id OR by namespace fqn + obligation name
//	        (
//	            -- lookup by obligation id
//	            (params.id IS NOT NULL AND od.id = params.id)
//	            OR
//	            -- lookup by namespace fqn + obligation name
//	            (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL
//	             AND fqns.fqn = params.namespace_fqn AND od.name = params.name)
//	        )
//	),
//	inserted_value AS (
//	    INSERT INTO obligation_values_standard (obligation_definition_id, value, metadata)
//	    SELECT ol.id, $4, $5
//	    FROM obligation_lookup ol
//	    RETURNING id, obligation_definition_id, value, metadata
//	)
//	SELECT
//	    iv.id,
//	    ol.name,
//	    ol.id as obligation_id,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    iv.metadata as metadata
//	FROM inserted_value iv
//	JOIN obligation_lookup ol ON ol.id = iv.obligation_definition_id
//	JOIN obligation_definitions od ON od.id = ol.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
func (q *Queries) createObligationValue(ctx context.Context, arg createObligationValueParams) (createObligationValueRow, error) {
	row := q.db.QueryRow(ctx, createObligationValue,
		arg.ID,
		arg.NamespaceFqn,
		arg.Name,
		arg.Value,
		arg.Metadata,
	)
	var i createObligationValueRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ObligationID,
		&i.Namespace,
		&i.Metadata,
	)
	return i, err
}

const deleteAllObligationTriggersForValue = `-- name: deleteAllObligationTriggersForValue :execrows
DELETE FROM obligation_triggers
WHERE obligation_value_id = $1
`

// deleteAllObligationTriggersForValue
//
//	DELETE FROM obligation_triggers
//	WHERE obligation_value_id = $1
func (q *Queries) deleteAllObligationTriggersForValue(ctx context.Context, obligationValueID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAllObligationTriggersForValue, obligationValueID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteObligation = `-- name: deleteObligation :one
DELETE FROM obligation_definitions 
WHERE id IN (
    SELECT od.id
    FROM obligation_definitions od
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        -- lookup by obligation id OR by namespace fqn + obligation name
        (
            -- lookup by obligation id
            ($1::text IS NOT NULL AND od.id = $1::uuid)
            OR
            -- lookup by namespace fqn + obligation name
            ($2::text IS NOT NULL AND $3::text IS NOT NULL 
             AND fqns.fqn = $2::text AND od.name = $3::text)
        )
)
RETURNING id
`

type deleteObligationParams struct {
	ID           pgtype.Text `json:"id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Name         pgtype.Text `json:"name"`
}

// deleteObligation
//
//	DELETE FROM obligation_definitions
//	WHERE id IN (
//	    SELECT od.id
//	    FROM obligation_definitions od
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        -- lookup by obligation id OR by namespace fqn + obligation name
//	        (
//	            -- lookup by obligation id
//	            ($1::text IS NOT NULL AND od.id = $1::uuid)
//	            OR
//	            -- lookup by namespace fqn + obligation name
//	            ($2::text IS NOT NULL AND $3::text IS NOT NULL
//	             AND fqns.fqn = $2::text AND od.name = $3::text)
//	        )
//	)
//	RETURNING id
func (q *Queries) deleteObligation(ctx context.Context, arg deleteObligationParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteObligation, arg.ID, arg.NamespaceFqn, arg.Name)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteObligationTrigger = `-- name: deleteObligationTrigger :one
DELETE FROM obligation_triggers
WHERE id = $1
RETURNING id
`

// deleteObligationTrigger
//
//	DELETE FROM obligation_triggers
//	WHERE id = $1
//	RETURNING id
func (q *Queries) deleteObligationTrigger(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, deleteObligationTrigger, id)
	err := row.Scan(&id)
	return id, err
}

const deleteObligationValue = `-- name: deleteObligationValue :one
DELETE FROM obligation_values_standard
WHERE id IN (
    SELECT ov.id
    FROM obligation_values_standard ov
    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        -- lookup by value id OR by namespace fqn + obligation name + value name
        (
            -- lookup by value id
            ($1::text IS NOT NULL AND ov.id = $1::uuid)
            OR
            -- lookup by namespace fqn + obligation name + value
            ($2::text IS NOT NULL AND $3::text IS NOT NULL AND $4::text IS NOT NULL
             AND fqns.fqn = $2::text AND od.name = $3::text AND ov.value = $4::text)
        )
)
RETURNING id
`

type deleteObligationValueParams struct {
	ID           pgtype.Text `json:"id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Name         pgtype.Text `json:"name"`
	Value        pgtype.Text `json:"value"`
}

// deleteObligationValue
//
//	DELETE FROM obligation_values_standard
//	WHERE id IN (
//	    SELECT ov.id
//	    FROM obligation_values_standard ov
//	    JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        -- lookup by value id OR by namespace fqn + obligation name + value name
//	        (
//	            -- lookup by value id
//	            ($1::text IS NOT NULL AND ov.id = $1::uuid)
//	            OR
//	            -- lookup by namespace fqn + obligation name + value
//	            ($2::text IS NOT NULL AND $3::text IS NOT NULL AND $4::text IS NOT NULL
//	             AND fqns.fqn = $2::text AND od.name = $3::text AND ov.value = $4::text)
//	        )
//	)
//	RETURNING id
func (q *Queries) deleteObligationValue(ctx context.Context, arg deleteObligationValueParams) (string, error) {
	row := q.db.QueryRow(ctx, deleteObligationValue,
		arg.ID,
		arg.NamespaceFqn,
		arg.Name,
		arg.Value,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getObligation = `-- name: getObligation :one
WITH params AS (
    SELECT
        $1::uuid as id,
        $2::text as namespace_fqn,
        $3::text as name
),
obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'::JSON
                END
            )
        ) as triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
    GROUP BY ot.obligation_value_id
)
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value,
            'triggers', COALESCE(ota.triggers, '[]'::JSON)
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values
FROM obligation_definitions od
CROSS JOIN params
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
WHERE
    -- lookup by obligation id OR by namespace fqn + obligation name
    (
        -- lookup by obligation id
        (params.id IS NOT NULL AND od.id = params.id)
        OR
        -- lookup by namespace fqn + obligation name
        (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL
         AND fqns.fqn = params.namespace_fqn AND od.name = params.name)
    )
GROUP BY od.id, n.id, fqns.fqn
`

type getObligationParams struct {
	ID           pgtype.UUID `json:"id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Name         pgtype.Text `json:"name"`
}

type getObligationRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
}

// getObligation
//
//	WITH params AS (
//	    SELECT
//	        $1::uuid as id,
//	        $2::text as namespace_fqn,
//	        $3::text as name
//	),
//	obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'::JSON
//	                END
//	            )
//	        ) as triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	    GROUP BY ot.obligation_value_id
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value,
//	            'triggers', COALESCE(ota.triggers, '[]'::JSON)
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values
//	FROM obligation_definitions od
//	CROSS JOIN params
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
//	WHERE
//	    -- lookup by obligation id OR by namespace fqn + obligation name
//	    (
//	        -- lookup by obligation id
//	        (params.id IS NOT NULL AND od.id = params.id)
//	        OR
//	        -- lookup by namespace fqn + obligation name
//	        (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL
//	         AND fqns.fqn = params.namespace_fqn AND od.name = params.name)
//	    )
//	GROUP BY od.id, n.id, fqns.fqn
func (q *Queries) getObligation(ctx context.Context, arg getObligationParams) (getObligationRow, error) {
	row := q.db.QueryRow(ctx, getObligation, arg.ID, arg.NamespaceFqn, arg.Name)
	var i getObligationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const getObligationValue = `-- name: getObligationValue :one
WITH params AS (
    SELECT
        $1::uuid as id,
        $2::text as namespace_fqn,
        $3::text as name,
        $4::text as value
),
obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'::JSON
                END
            )
        ) as triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
    GROUP BY ot.obligation_value_id
)
SELECT
    ov.id,
    ov.value,
    od.id as obligation_id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ov.metadata -> 'labels', 'created_at', ov.created_at,'updated_at', ov.updated_at)) as metadata,
    COALESCE(ota.triggers, '[]'::JSON) as triggers
FROM obligation_values_standard ov
CROSS JOIN params
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
WHERE
    -- lookup by value id OR by namespace fqn + obligation name + value name
    (
        -- lookup by value id
        (params.id IS NOT NULL AND ov.id = params.id)
        OR
        -- lookup by namespace fqn + obligation name + value name
        (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL AND params.value IS NOT NULL
         AND fqns.fqn = params.namespace_fqn AND od.name = params.name AND ov.value = params.value)
    )
`

type getObligationValueParams struct {
	ID           pgtype.UUID `json:"id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
	Name         pgtype.Text `json:"name"`
	Value        pgtype.Text `json:"value"`
}

type getObligationValueRow struct {
	ID           string `json:"id"`
	Value        string `json:"value"`
	ObligationID string `json:"obligation_id"`
	Name         string `json:"name"`
	Namespace    []byte `json:"namespace"`
	Metadata     []byte `json:"metadata"`
	Triggers     []byte `json:"triggers"`
}

// getObligationValue
//
//	WITH params AS (
//	    SELECT
//	        $1::uuid as id,
//	        $2::text as namespace_fqn,
//	        $3::text as name,
//	        $4::text as value
//	),
//	obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'::JSON
//	                END
//	            )
//	        ) as triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	    GROUP BY ot.obligation_value_id
//	)
//	SELECT
//	    ov.id,
//	    ov.value,
//	    od.id as obligation_id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ov.metadata -> 'labels', 'created_at', ov.created_at,'updated_at', ov.updated_at)) as metadata,
//	    COALESCE(ota.triggers, '[]'::JSON) as triggers
//	FROM obligation_values_standard ov
//	CROSS JOIN params
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
//	WHERE
//	    -- lookup by value id OR by namespace fqn + obligation name + value name
//	    (
//	        -- lookup by value id
//	        (params.id IS NOT NULL AND ov.id = params.id)
//	        OR
//	        -- lookup by namespace fqn + obligation name + value name
//	        (params.namespace_fqn IS NOT NULL AND params.name IS NOT NULL AND params.value IS NOT NULL
//	         AND fqns.fqn = params.namespace_fqn AND od.name = params.name AND ov.value = params.value)
//	    )
func (q *Queries) getObligationValue(ctx context.Context, arg getObligationValueParams) (getObligationValueRow, error) {
	row := q.db.QueryRow(ctx, getObligationValue,
		arg.ID,
		arg.NamespaceFqn,
		arg.Name,
		arg.Value,
	)
	var i getObligationValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ObligationID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Triggers,
	)
	return i, err
}

const getObligationValuesByFQNs = `-- name: getObligationValuesByFQNs :many
WITH obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'::JSON
                END
            )
        ) as triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
    GROUP BY ot.obligation_value_id
)
SELECT
    ov.id,
    ov.value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ov.metadata -> 'labels', 'created_at', ov.created_at,'updated_at', ov.updated_at)) as metadata,
    od.id as obligation_id,
    od.name as name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    COALESCE(ota.triggers, '[]'::JSON) as triggers
FROM
    obligation_values_standard ov
JOIN
    obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN
    attribute_namespaces n ON od.namespace_id = n.id
JOIN
    attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
JOIN
    (SELECT unnest($1::text[]) as ns_fqn, unnest($2::text[]) as obl_name, unnest($3::text[]) as value) as fqn_pairs
ON
    fqns.fqn = fqn_pairs.ns_fqn AND od.name = fqn_pairs.obl_name AND ov.value = fqn_pairs.value
LEFT JOIN
    obligation_triggers_agg ota on ov.id = ota.obligation_value_id
`

type getObligationValuesByFQNsParams struct {
	NamespaceFqns []string `json:"namespace_fqns"`
	Names         []string `json:"names"`
	Values        []string `json:"values"`
}

type getObligationValuesByFQNsRow struct {
	ID           string `json:"id"`
	Value        string `json:"value"`
	Metadata     []byte `json:"metadata"`
	ObligationID string `json:"obligation_id"`
	Name         string `json:"name"`
	Namespace    []byte `json:"namespace"`
	Triggers     []byte `json:"triggers"`
}

// getObligationValuesByFQNs
//
//	WITH obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'::JSON
//	                END
//	            )
//	        ) as triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	    GROUP BY ot.obligation_value_id
//	)
//	SELECT
//	    ov.id,
//	    ov.value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ov.metadata -> 'labels', 'created_at', ov.created_at,'updated_at', ov.updated_at)) as metadata,
//	    od.id as obligation_id,
//	    od.name as name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    COALESCE(ota.triggers, '[]'::JSON) as triggers
//	FROM
//	    obligation_values_standard ov
//	JOIN
//	    obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN
//	    attribute_namespaces n ON od.namespace_id = n.id
//	JOIN
//	    attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	JOIN
//	    (SELECT unnest($1::text[]) as ns_fqn, unnest($2::text[]) as obl_name, unnest($3::text[]) as value) as fqn_pairs
//	ON
//	    fqns.fqn = fqn_pairs.ns_fqn AND od.name = fqn_pairs.obl_name AND ov.value = fqn_pairs.value
//	LEFT JOIN
//	    obligation_triggers_agg ota on ov.id = ota.obligation_value_id
func (q *Queries) getObligationValuesByFQNs(ctx context.Context, arg getObligationValuesByFQNsParams) ([]getObligationValuesByFQNsRow, error) {
	rows, err := q.db.Query(ctx, getObligationValuesByFQNs, arg.NamespaceFqns, arg.Names, arg.Values)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getObligationValuesByFQNsRow
	for rows.Next() {
		var i getObligationValuesByFQNsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Metadata,
			&i.ObligationID,
			&i.Name,
			&i.Namespace,
			&i.Triggers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObligationsByFQNs = `-- name: getObligationsByFQNs :many
WITH obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'::JSON
                END
            )
        ) as triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
    GROUP BY ot.obligation_value_id
)
SELECT
    od.id,
    od.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ov.id,
                'value', ov.value,
                'triggers', COALESCE(ota.triggers, '[]'::JSON)
            )
        ) FILTER (WHERE ov.id IS NOT NULL),
        '[]'::JSON
    )::JSONB as values
FROM
    obligation_definitions od
JOIN
    attribute_namespaces n on od.namespace_id = n.id
JOIN
    attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
JOIN
    (SELECT unnest($1::text[]) as ns_fqn, unnest($2::text[]) as obl_name) as fqn_pairs
ON
    fqns.fqn = fqn_pairs.ns_fqn AND od.name = fqn_pairs.obl_name
LEFT JOIN
    obligation_values_standard ov on od.id = ov.obligation_definition_id
LEFT JOIN
    obligation_triggers_agg ota on ov.id = ota.obligation_value_id
GROUP BY
    od.id, n.id, fqns.fqn
`

type getObligationsByFQNsParams struct {
	NamespaceFqns []string `json:"namespace_fqns"`
	Names         []string `json:"names"`
}

type getObligationsByFQNsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Metadata  []byte `json:"metadata"`
	Namespace []byte `json:"namespace"`
	Values    []byte `json:"values"`
}

// getObligationsByFQNs
//
//	WITH obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'::JSON
//	                END
//	            )
//	        ) as triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	    GROUP BY ot.obligation_value_id
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    COALESCE(
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ov.id,
//	                'value', ov.value,
//	                'triggers', COALESCE(ota.triggers, '[]'::JSON)
//	            )
//	        ) FILTER (WHERE ov.id IS NOT NULL),
//	        '[]'::JSON
//	    )::JSONB as values
//	FROM
//	    obligation_definitions od
//	JOIN
//	    attribute_namespaces n on od.namespace_id = n.id
//	JOIN
//	    attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	JOIN
//	    (SELECT unnest($1::text[]) as ns_fqn, unnest($2::text[]) as obl_name) as fqn_pairs
//	ON
//	    fqns.fqn = fqn_pairs.ns_fqn AND od.name = fqn_pairs.obl_name
//	LEFT JOIN
//	    obligation_values_standard ov on od.id = ov.obligation_definition_id
//	LEFT JOIN
//	    obligation_triggers_agg ota on ov.id = ota.obligation_value_id
//	GROUP BY
//	    od.id, n.id, fqns.fqn
func (q *Queries) getObligationsByFQNs(ctx context.Context, arg getObligationsByFQNsParams) ([]getObligationsByFQNsRow, error) {
	rows, err := q.db.Query(ctx, getObligationsByFQNs, arg.NamespaceFqns, arg.Names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getObligationsByFQNsRow
	for rows.Next() {
		var i getObligationsByFQNsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.Namespace,
			&i.Values,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObligationTriggers = `-- name: listObligationTriggers :many
WITH params AS (
    SELECT
        $3::uuid as namespace_id,
        $4::text as namespace_fqn
)
SELECT
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'id', ot.id,
            'obligation_value', JSON_BUILD_OBJECT(
                'id', ov.id,
                'value', ov.value,
                'obligation', JSON_BUILD_OBJECT(
                    'id', od.id,
                    'name', od.name,
                    'namespace', JSON_BUILD_OBJECT(
                        'id', n.id,
                        'name', n.name,
                        'fqn', COALESCE(ns_fqns.fqn, '')
                    )
                )
            ),
            'action', JSON_BUILD_OBJECT(
                'id', a.id,
                'name', a.name
            ),
            'attribute_value', JSON_BUILD_OBJECT(
                'id', av.id,
                'value', av.value,
                'fqn', COALESCE(av_fqns.fqn, '')
            ),
            'context', CASE
                WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                    JSON_BUILD_OBJECT(
                        'pep', JSON_BUILD_OBJECT(
                            'client_id', ot.client_id
                        )
                    )
                )
                ELSE '[]'::JSON
            END
        )
    ) as trigger,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'labels', ot.metadata -> 'labels',
            'created_at', ot.created_at,
            'updated_at', ot.updated_at
        )
    ) as metadata,
    COUNT(*) OVER() as total
FROM obligation_triggers ot
CROSS JOIN params
JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
JOIN actions a ON ot.action_id = a.id
JOIN attribute_values av ON ot.attribute_value_id = av.id
LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
WHERE
    (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
    (params.namespace_fqn IS NULL OR ns_fqns.fqn = params.namespace_fqn)
ORDER BY ot.created_at DESC
LIMIT $2
OFFSET $1
`

type listObligationTriggersParams struct {
	Offset       int32       `json:"offset_"`
	Limit        int32       `json:"limit_"`
	NamespaceID  pgtype.UUID `json:"namespace_id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
}

type listObligationTriggersRow struct {
	Trigger  []byte `json:"trigger"`
	Metadata []byte `json:"metadata"`
	Total    int64  `json:"total"`
}

// listObligationTriggers
//
//	WITH params AS (
//	    SELECT
//	        $3::uuid as namespace_id,
//	        $4::text as namespace_fqn
//	)
//	SELECT
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'id', ot.id,
//	            'obligation_value', JSON_BUILD_OBJECT(
//	                'id', ov.id,
//	                'value', ov.value,
//	                'obligation', JSON_BUILD_OBJECT(
//	                    'id', od.id,
//	                    'name', od.name,
//	                    'namespace', JSON_BUILD_OBJECT(
//	                        'id', n.id,
//	                        'name', n.name,
//	                        'fqn', COALESCE(ns_fqns.fqn, '')
//	                    )
//	                )
//	            ),
//	            'action', JSON_BUILD_OBJECT(
//	                'id', a.id,
//	                'name', a.name
//	            ),
//	            'attribute_value', JSON_BUILD_OBJECT(
//	                'id', av.id,
//	                'value', av.value,
//	                'fqn', COALESCE(av_fqns.fqn, '')
//	            ),
//	            'context', CASE
//	                WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                    JSON_BUILD_OBJECT(
//	                        'pep', JSON_BUILD_OBJECT(
//	                            'client_id', ot.client_id
//	                        )
//	                    )
//	                )
//	                ELSE '[]'::JSON
//	            END
//	        )
//	    ) as trigger,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'labels', ot.metadata -> 'labels',
//	            'created_at', ot.created_at,
//	            'updated_at', ot.updated_at
//	        )
//	    ) as metadata,
//	    COUNT(*) OVER() as total
//	FROM obligation_triggers ot
//	CROSS JOIN params
//	JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
//	JOIN actions a ON ot.action_id = a.id
//	JOIN attribute_values av ON ot.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	WHERE
//	    (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
//	    (params.namespace_fqn IS NULL OR ns_fqns.fqn = params.namespace_fqn)
//	ORDER BY ot.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listObligationTriggers(ctx context.Context, arg listObligationTriggersParams) ([]listObligationTriggersRow, error) {
	rows, err := q.db.Query(ctx, listObligationTriggers,
		arg.Offset,
		arg.Limit,
		arg.NamespaceID,
		arg.NamespaceFqn,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationTriggersRow
	for rows.Next() {
		var i listObligationTriggersRow
		if err := rows.Scan(&i.Trigger, &i.Metadata, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObligations = `-- name: listObligations :many
WITH params AS (
    SELECT
        $3::uuid as namespace_id,
        $4::text as namespace_fqn
),
counted AS (
    SELECT COUNT(od.id) AS total
    FROM obligation_definitions od
    CROSS JOIN params
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
        (params.namespace_fqn IS NULL OR fqns.fqn = params.namespace_fqn)
),
obligation_triggers_agg AS (
    SELECT
        ot.obligation_value_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', ot.id,
                'action', JSON_BUILD_OBJECT(
                    'id', a.id,
                    'name', a.name
                ),
                'attribute_value', JSON_BUILD_OBJECT(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
                        JSON_BUILD_OBJECT(
                            'pep', JSON_BUILD_OBJECT(
                                'client_id', ot.client_id
                            )
                        )
                    )
                    ELSE '[]'::JSON
                END
            )
        ) as triggers
    FROM obligation_triggers ot
    JOIN actions a ON ot.action_id = a.id
    JOIN attribute_values av ON ot.attribute_value_id = av.id
    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
    GROUP BY ot.obligation_value_id
)
SELECT
    od.id,
    od.name,
    JSON_BUILD_OBJECT(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', ov.id,
            'value', ov.value,
            'triggers', COALESCE(ota.triggers, '[]'::JSON)
        )
    ) FILTER (WHERE ov.id IS NOT NULL) as values,
    counted.total
FROM obligation_definitions od
CROSS JOIN params
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
CROSS JOIN counted
LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
WHERE
    (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
    (params.namespace_fqn IS NULL OR fqns.fqn = params.namespace_fqn)
GROUP BY od.id, n.id, fqns.fqn, counted.total
LIMIT $2
OFFSET $1
`

type listObligationsParams struct {
	Offset       int32       `json:"offset_"`
	Limit        int32       `json:"limit_"`
	NamespaceID  pgtype.UUID `json:"namespace_id"`
	NamespaceFqn pgtype.Text `json:"namespace_fqn"`
}

type listObligationsRow struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Namespace []byte `json:"namespace"`
	Metadata  []byte `json:"metadata"`
	Values    []byte `json:"values"`
	Total     int64  `json:"total"`
}

// listObligations
//
//	WITH params AS (
//	    SELECT
//	        $3::uuid as namespace_id,
//	        $4::text as namespace_fqn
//	),
//	counted AS (
//	    SELECT COUNT(od.id) AS total
//	    FROM obligation_definitions od
//	    CROSS JOIN params
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
//	        (params.namespace_fqn IS NULL OR fqns.fqn = params.namespace_fqn)
//	),
//	obligation_triggers_agg AS (
//	    SELECT
//	        ot.obligation_value_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', ot.id,
//	                'action', JSON_BUILD_OBJECT(
//	                    'id', a.id,
//	                    'name', a.name
//	                ),
//	                'attribute_value', JSON_BUILD_OBJECT(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN JSON_BUILD_ARRAY(
//	                        JSON_BUILD_OBJECT(
//	                            'pep', JSON_BUILD_OBJECT(
//	                                'client_id', ot.client_id
//	                            )
//	                        )
//	                    )
//	                    ELSE '[]'::JSON
//	                END
//	            )
//	        ) as triggers
//	    FROM obligation_triggers ot
//	    JOIN actions a ON ot.action_id = a.id
//	    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	    GROUP BY ot.obligation_value_id
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    JSON_BUILD_OBJECT(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', od.metadata -> 'labels', 'created_at', od.created_at,'updated_at', od.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', ov.id,
//	            'value', ov.value,
//	            'triggers', COALESCE(ota.triggers, '[]'::JSON)
//	        )
//	    ) FILTER (WHERE ov.id IS NOT NULL) as values,
//	    counted.total
//	FROM obligation_definitions od
//	CROSS JOIN params
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	CROSS JOIN counted
//	LEFT JOIN obligation_values_standard ov on od.id = ov.obligation_definition_id
//	LEFT JOIN obligation_triggers_agg ota on ov.id = ota.obligation_value_id
//	WHERE
//	    (params.namespace_id IS NULL OR od.namespace_id = params.namespace_id) AND
//	    (params.namespace_fqn IS NULL OR fqns.fqn = params.namespace_fqn)
//	GROUP BY od.id, n.id, fqns.fqn, counted.total
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listObligations(ctx context.Context, arg listObligationsParams) ([]listObligationsRow, error) {
	rows, err := q.db.Query(ctx, listObligations,
		arg.Offset,
		arg.Limit,
		arg.NamespaceID,
		arg.NamespaceFqn,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationsRow
	for rows.Next() {
		var i listObligationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Namespace,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligation = `-- name: updateObligation :execrows
UPDATE obligation_definitions
SET
    name = COALESCE($1, name),
    metadata = COALESCE($2, metadata)
WHERE id = $3
`

type updateObligationParams struct {
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
	ID       string      `json:"id"`
}

// updateObligation
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE($1, name),
//	    metadata = COALESCE($2, metadata)
//	WHERE id = $3
func (q *Queries) updateObligation(ctx context.Context, arg updateObligationParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligation, arg.Name, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateObligationValue = `-- name: updateObligationValue :execrows
UPDATE obligation_values_standard
SET
    value = COALESCE($1, value),
    metadata = COALESCE($2, metadata)
WHERE id = $3
`

type updateObligationValueParams struct {
	Value    pgtype.Text `json:"value"`
	Metadata []byte      `json:"metadata"`
	ID       string      `json:"id"`
}

// updateObligationValue
//
//	UPDATE obligation_values_standard
//	SET
//	    value = COALESCE($1, value),
//	    metadata = COALESCE($2, metadata)
//	WHERE id = $3
func (q *Queries) updateObligationValue(ctx context.Context, arg updateObligationValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateObligationValue, arg.Value, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
