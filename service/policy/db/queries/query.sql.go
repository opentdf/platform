// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package queries

import (
	"context"

	"github.com/google/uuid"
)

const upsertAttrFqnDefinition = `-- name: UpsertAttrFqnDefinition :many
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT n.id, ad.id, v.id,
       CASE
         WHEN v.value IS NOT NULL THEN CONCAT('https://', n.name, '/attr/', ad.name, '/value/', v.value)
         ELSE CONCAT('https://', n.name, '/attr/', ad.name)
       END AS fqn
FROM attribute_namespaces n
JOIN attribute_definitions ad ON ad.namespace_id = n.id
JOIN attribute_values v ON v.attribute_id = ad.id
WHERE ad.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// UpsertAttrFqnDefinition
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT n.id, ad.id, v.id,
//	       CASE
//	         WHEN v.value IS NOT NULL THEN CONCAT('https://', n.name, '/attr/', ad.name, '/value/', v.value)
//	         ELSE CONCAT('https://', n.name, '/attr/', ad.name)
//	       END AS fqn
//	FROM attribute_namespaces n
//	JOIN attribute_definitions ad ON ad.namespace_id = n.id
//	JOIN attribute_values v ON v.attribute_id = ad.id
//	WHERE ad.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttrFqnDefinition(ctx context.Context, id uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, upsertAttrFqnDefinition, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var fqn string
		if err := rows.Scan(&fqn); err != nil {
			return nil, err
		}
		items = append(items, fqn)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAttrFqnNamespace = `-- name: UpsertAttrFqnNamespace :many
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT n.id, ad.id, v.id,
       CONCAT('https://', n.name, 
              CASE WHEN ad.id IS NOT NULL THEN '/attr/' || ad.name ELSE '' END,
              CASE WHEN v.id IS NOT NULL THEN '/value/' || v.value ELSE '' END) AS fqn
FROM attribute_namespaces n
LEFT JOIN attribute_definitions ad ON ad.namespace_id = n.id
LEFT JOIN attribute_values v ON v.attribute_id = ad.id
WHERE n.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// UpsertAttrFqnNamespace
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT n.id, ad.id, v.id,
//	       CONCAT('https://', n.name,
//	              CASE WHEN ad.id IS NOT NULL THEN '/attr/' || ad.name ELSE '' END,
//	              CASE WHEN v.id IS NOT NULL THEN '/value/' || v.value ELSE '' END) AS fqn
//	FROM attribute_namespaces n
//	LEFT JOIN attribute_definitions ad ON ad.namespace_id = n.id
//	LEFT JOIN attribute_values v ON v.attribute_id = ad.id
//	WHERE n.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttrFqnNamespace(ctx context.Context, id uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, upsertAttrFqnNamespace, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var fqn string
		if err := rows.Scan(&fqn); err != nil {
			return nil, err
		}
		items = append(items, fqn)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAttrFqnValue = `-- name: UpsertAttrFqnValue :one
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT n.id, ad.id, v.id, CONCAT('https://', n.name, '/attr/', ad.name, '/value/', v.value) AS fqn
FROM attribute_namespaces n
JOIN attribute_definitions ad ON ad.namespace_id = n.id
JOIN attribute_values v ON v.attribute_id = ad.id
WHERE v.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// UpsertAttrFqnValue
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT n.id, ad.id, v.id, CONCAT('https://', n.name, '/attr/', ad.name, '/value/', v.value) AS fqn
//	FROM attribute_namespaces n
//	JOIN attribute_definitions ad ON ad.namespace_id = n.id
//	JOIN attribute_values v ON v.attribute_id = ad.id
//	WHERE v.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id) DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttrFqnValue(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRow(ctx, upsertAttrFqnValue, id)
	var fqn string
	err := row.Scan(&fqn)
	return fqn, err
}
