// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignKeyAccessServerToAttribute = `-- name: AssignKeyAccessServerToAttribute :execrows
INSERT INTO attribute_definition_key_access_grants (attribute_definition_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToAttributeParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	KeyAccessServerID     string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToAttribute
//
//	INSERT INTO attribute_definition_key_access_grants (attribute_definition_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToAttribute(ctx context.Context, arg AssignKeyAccessServerToAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignKeyAccessServerToAttributeValue = `-- name: AssignKeyAccessServerToAttributeValue :execrows
INSERT INTO attribute_value_key_access_grants (attribute_value_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToAttributeValueParams struct {
	AttributeValueID  string `json:"attribute_value_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToAttributeValue
//
//	INSERT INTO attribute_value_key_access_grants (attribute_value_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToAttributeValue(ctx context.Context, arg AssignKeyAccessServerToAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignKeyAccessServerToNamespace = `-- name: AssignKeyAccessServerToNamespace :execrows
INSERT INTO attribute_namespace_key_access_grants (namespace_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToNamespaceParams struct {
	NamespaceID       string `json:"namespace_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToNamespace
//
//	INSERT INTO attribute_namespace_key_access_grants (namespace_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToNamespace(ctx context.Context, arg AssignKeyAccessServerToNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToNamespace, arg.NamespaceID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createAttribute = `-- name: CreateAttribute :one
INSERT INTO attribute_definitions (namespace_id, name, rule, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateAttributeParams struct {
	NamespaceID string                  `json:"namespace_id"`
	Name        string                  `json:"name"`
	Rule        AttributeDefinitionRule `json:"rule"`
	Metadata    []byte                  `json:"metadata"`
}

// CreateAttribute
//
//	INSERT INTO attribute_definitions (namespace_id, name, rule, metadata)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateAttribute(ctx context.Context, arg CreateAttributeParams) (string, error) {
	row := q.db.QueryRow(ctx, createAttribute,
		arg.NamespaceID,
		arg.Name,
		arg.Rule,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createAttributeValue = `-- name: CreateAttributeValue :one
INSERT INTO attribute_values (attribute_definition_id, value, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateAttributeValueParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	Value                 string `json:"value"`
	Metadata              []byte `json:"metadata"`
}

// CreateAttributeValue
//
//	INSERT INTO attribute_values (attribute_definition_id, value, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateAttributeValue(ctx context.Context, arg CreateAttributeValueParams) (string, error) {
	row := q.db.QueryRow(ctx, createAttributeValue, arg.AttributeDefinitionID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createKeyAccessServer = `-- name: CreateKeyAccessServer :one
INSERT INTO key_access_servers (uri, public_key, name, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateKeyAccessServerParams struct {
	Uri       string      `json:"uri"`
	PublicKey []byte      `json:"public_key"`
	Name      pgtype.Text `json:"name"`
	Metadata  []byte      `json:"metadata"`
}

// CreateKeyAccessServer
//
//	INSERT INTO key_access_servers (uri, public_key, name, metadata)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateKeyAccessServer(ctx context.Context, arg CreateKeyAccessServerParams) (string, error) {
	row := q.db.QueryRow(ctx, createKeyAccessServer,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createNamespace = `-- name: CreateNamespace :one
INSERT INTO attribute_namespaces (name, metadata)
VALUES ($1, $2)
RETURNING id
`

type CreateNamespaceParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// CreateNamespace
//
//	INSERT INTO attribute_namespaces (name, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateNamespace(ctx context.Context, arg CreateNamespaceParams) (string, error) {
	row := q.db.QueryRow(ctx, createNamespace, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMapping = `-- name: CreateResourceMapping :one
INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateResourceMappingParams struct {
	AttributeValueID string      `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// CreateResourceMapping
//
//	INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateResourceMapping(ctx context.Context, arg CreateResourceMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMapping,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMappingGroup = `-- name: CreateResourceMappingGroup :one
INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateResourceMappingGroupParams struct {
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// CreateResourceMappingGroup
//
//	INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateResourceMappingGroup(ctx context.Context, arg CreateResourceMappingGroupParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMappingGroup, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectConditionSet = `-- name: CreateSubjectConditionSet :one
INSERT INTO subject_condition_set (condition, metadata)
VALUES ($1, $2)
RETURNING id
`

type CreateSubjectConditionSetParams struct {
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// CreateSubjectConditionSet
//
//	INSERT INTO subject_condition_set (condition, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateSubjectConditionSet(ctx context.Context, arg CreateSubjectConditionSetParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectConditionSet, arg.Condition, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectMapping = `-- name: CreateSubjectMapping :one
INSERT INTO subject_mappings (attribute_value_id, actions, metadata, subject_condition_set_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateSubjectMappingParams struct {
	AttributeValueID      string      `json:"attribute_value_id"`
	Actions               []byte      `json:"actions"`
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
}

// CreateSubjectMapping
//
//	INSERT INTO subject_mappings (attribute_value_id, actions, metadata, subject_condition_set_id)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateSubjectMapping(ctx context.Context, arg CreateSubjectMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectMapping,
		arg.AttributeValueID,
		arg.Actions,
		arg.Metadata,
		arg.SubjectConditionSetID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAttribute = `-- name: DeleteAttribute :execrows
DELETE FROM attribute_definitions WHERE id = $1
`

// DeleteAttribute
//
//	DELETE FROM attribute_definitions WHERE id = $1
func (q *Queries) DeleteAttribute(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttribute, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttributeValue = `-- name: DeleteAttributeValue :execrows
DELETE FROM attribute_values WHERE id = $1
`

// DeleteAttributeValue
//
//	DELETE FROM attribute_values WHERE id = $1
func (q *Queries) DeleteAttributeValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttributeValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteKeyAccessServer = `-- name: DeleteKeyAccessServer :execrows
DELETE FROM key_access_servers WHERE id = $1
`

// DeleteKeyAccessServer
//
//	DELETE FROM key_access_servers WHERE id = $1
func (q *Queries) DeleteKeyAccessServer(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteKeyAccessServer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteNamespace = `-- name: DeleteNamespace :execrows
DELETE FROM attribute_namespaces WHERE id = $1
`

// DeleteNamespace
//
//	DELETE FROM attribute_namespaces WHERE id = $1
func (q *Queries) DeleteNamespace(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNamespace, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteResourceMapping = `-- name: DeleteResourceMapping :execrows
DELETE FROM resource_mappings WHERE id = $1
`

// DeleteResourceMapping
//
//	DELETE FROM resource_mappings WHERE id = $1
func (q *Queries) DeleteResourceMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteResourceMappingGroup = `-- name: DeleteResourceMappingGroup :execrows
DELETE FROM resource_mapping_groups WHERE id = $1
`

// DeleteResourceMappingGroup
//
//	DELETE FROM resource_mapping_groups WHERE id = $1
func (q *Queries) DeleteResourceMappingGroup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMappingGroup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubjectConditionSet = `-- name: DeleteSubjectConditionSet :execrows
DELETE FROM subject_condition_set WHERE id = $1
`

// DeleteSubjectConditionSet
//
//	DELETE FROM subject_condition_set WHERE id = $1
func (q *Queries) DeleteSubjectConditionSet(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectConditionSet, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubjectMapping = `-- name: DeleteSubjectMapping :execrows
DELETE FROM subject_mappings WHERE id = $1
`

// DeleteSubjectMapping
//
//	DELETE FROM subject_mappings WHERE id = $1
func (q *Queries) DeleteSubjectMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAttribute = `-- name: GetAttribute :one
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS values,
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )
    ) FILTER (WHERE adkag.attribute_definition_id IS NOT NULL) AS grants,
    fqns.fqn
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
    SELECT
        av.id,
        av.value,
        av.active,
        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT('id', vkas.id,'uri', vkas.uri,'name', vkas.name,'public_key', vkas.public_key )) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
        av.attribute_definition_id
    FROM attribute_values av
    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
    GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE ad.id = $1
GROUP BY ad.id, n.name, fqns.fqn
`

type GetAttributeRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
	Values        []byte                  `json:"values"`
	Grants        []byte                  `json:"grants"`
	Fqn           pgtype.Text             `json:"fqn"`
}

// GetAttribute
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    JSONB_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )
//	    ) FILTER (WHERE adkag.attribute_definition_id IS NOT NULL) AS grants,
//	    fqns.fqn
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	    SELECT
//	        av.id,
//	        av.value,
//	        av.active,
//	        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT('id', vkas.id,'uri', vkas.uri,'name', vkas.name,'public_key', vkas.public_key )) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
//	        av.attribute_definition_id
//	    FROM attribute_values av
//	    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
//	    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
//	    GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
//	LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE ad.id = $1
//	GROUP BY ad.id, n.name, fqns.fqn
func (q *Queries) GetAttribute(ctx context.Context, id string) (GetAttributeRow, error) {
	row := q.db.QueryRow(ctx, getAttribute, id)
	var i GetAttributeRow
	err := row.Scan(
		&i.ID,
		&i.AttributeName,
		&i.Rule,
		&i.Metadata,
		&i.NamespaceID,
		&i.Active,
		&i.NamespaceName,
		&i.Values,
		&i.Grants,
		&i.Fqn,
	)
	return i, err
}

const getAttributeByDefOrValueFqn = `-- name: GetAttributeByDefOrValueFqn :one
WITH target_definition AS (
    SELECT ad.id
    FROM attribute_definitions ad
    INNER JOIN attribute_fqns af ON af.attribute_id = ad.id
    WHERE af.fqn = $1
    LIMIT 1
),
active_attribute_values AS (
    SELECT
        av.id,
        av.value,
        av.active,
        av.attribute_definition_id,
        JSON_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'id', vkas.id,
                'uri', vkas.uri,
                'public_key', vkas.public_key
            )
        ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr
    FROM
        attribute_values av
    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
    WHERE av.active = TRUE
    AND av.attribute_definition_id = (SELECT id FROM target_definition)
    GROUP BY av.id
),
namespace_fqn_cte AS (
    SELECT anfqn.namespace_id, anfqn.fqn
    FROM attribute_fqns anfqn
    WHERE anfqn.attribute_id IS NULL AND anfqn.value_id IS NULL
),
namespace_grants_cte AS (
    SELECT
        ankag.namespace_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'id', kas.id,
                'uri', kas.uri,
                'public_key', kas.public_key
            )
        ) AS grants
    FROM
        attribute_namespace_key_access_grants ankag
    LEFT JOIN key_access_servers kas ON kas.id = ankag.key_access_server_id
    GROUP BY ankag.namespace_id
),
target_definition_fqn_cte AS (
    SELECT af.fqn
    FROM attribute_fqns af
    WHERE af.namespace_id = (SELECT namespace_id FROM attribute_definitions WHERE id = (SELECT id FROM target_definition))
    AND af.attribute_id = (SELECT id FROM target_definition)
    AND af.value_id IS NULL
),
subject_mappings_cte AS (
    SELECT
        av.id AS av_id,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', sm.id,
                'actions', sm.actions,
                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                    'labels', sm.metadata -> 'labels',
                    'created_at', sm.created_at,
                    'updated_at', sm.updated_at
                )),
                'subject_condition_set', JSON_BUILD_OBJECT(
                    'id', scs.id,
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                        'labels', scs.metadata -> 'labels',
                        'created_at', scs.created_at,
                        'updated_at', scs.updated_at
                    )),
                    'subject_sets', scs.condition
                )
            )
        ) AS sub_maps_arr
    FROM
        subject_mappings sm
    LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
    LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
    WHERE av.active = TRUE
    AND av.attribute_definition_id = (SELECT id FROM target_definition)
    GROUP BY av.id
)
SELECT
    ad.id,
    ad.name,
    ad.rule,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'labels', ad.metadata -> 'labels',
            'created_at', ad.created_at,
            'updated_at', ad.updated_at
        )
    ) AS metadata,
    ad.active,
    JSON_BUILD_OBJECT(
        'name', an.name,
        'id', an.id,
        'fqn', nfq.fqn,
        'grants', n_grants.grants,
        'active', an.active
    ) AS namespace,
    (SELECT fqn FROM target_definition_fqn_cte) AS definition_fqn,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', af.fqn,
            'subject_mappings', sm.sub_maps_arr,
            'grants', avt.val_grants_arr
        -- enforce order of values in response
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS values,
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'public_key', kas.public_key
        )
    ) FILTER (WHERE kas.id IS NOT NULL AND kas.uri IS NOT NULL AND kas.public_key IS NOT NULL) AS definition_grants
FROM
    attribute_definitions ad
LEFT JOIN attribute_namespaces an ON an.id = ad.namespace_id
LEFT JOIN active_attribute_values avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
LEFT JOIN attribute_fqns af ON af.value_id = avt.id
LEFT JOIN namespace_fqn_cte nfq ON nfq.namespace_id = an.id
LEFT JOIN namespace_grants_cte n_grants ON n_grants.namespace_id = an.id
LEFT JOIN subject_mappings_cte sm ON avt.id = sm.av_id
WHERE
    ad.active = TRUE
    AND ad.id = (SELECT id FROM target_definition)
    AND an.active = TRUE
GROUP BY
    ad.id, an.id, nfq.fqn, n_grants.grants
`

type GetAttributeByDefOrValueFqnRow struct {
	ID               string                  `json:"id"`
	Name             string                  `json:"name"`
	Rule             AttributeDefinitionRule `json:"rule"`
	Metadata         []byte                  `json:"metadata"`
	Active           bool                    `json:"active"`
	Namespace        []byte                  `json:"namespace"`
	DefinitionFqn    string                  `json:"definition_fqn"`
	Values           []byte                  `json:"values"`
	DefinitionGrants []byte                  `json:"definition_grants"`
}

// get the attribute definition for the provided value or definition fqn
// get the active values with KAS grants under the attribute definition
// get the namespace fqn for the attribute definition
// get the grants for the attribute's namespace
// get the definition fqn for the attribute definition (could have been provided a value fqn initially)
// get the subject mappings for the active values under the attribute definition
// get the attribute definition and give structure to the result
//
//	WITH target_definition AS (
//	    SELECT ad.id
//	    FROM attribute_definitions ad
//	    INNER JOIN attribute_fqns af ON af.attribute_id = ad.id
//	    WHERE af.fqn = $1
//	    LIMIT 1
//	),
//	active_attribute_values AS (
//	    SELECT
//	        av.id,
//	        av.value,
//	        av.active,
//	        av.attribute_definition_id,
//	        JSON_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'id', vkas.id,
//	                'uri', vkas.uri,
//	                'public_key', vkas.public_key
//	            )
//	        ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr
//	    FROM
//	        attribute_values av
//	    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
//	    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
//	    WHERE av.active = TRUE
//	    AND av.attribute_definition_id = (SELECT id FROM target_definition)
//	    GROUP BY av.id
//	),
//	namespace_fqn_cte AS (
//	    SELECT anfqn.namespace_id, anfqn.fqn
//	    FROM attribute_fqns anfqn
//	    WHERE anfqn.attribute_id IS NULL AND anfqn.value_id IS NULL
//	),
//	namespace_grants_cte AS (
//	    SELECT
//	        ankag.namespace_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'public_key', kas.public_key
//	            )
//	        ) AS grants
//	    FROM
//	        attribute_namespace_key_access_grants ankag
//	    LEFT JOIN key_access_servers kas ON kas.id = ankag.key_access_server_id
//	    GROUP BY ankag.namespace_id
//	),
//	target_definition_fqn_cte AS (
//	    SELECT af.fqn
//	    FROM attribute_fqns af
//	    WHERE af.namespace_id = (SELECT namespace_id FROM attribute_definitions WHERE id = (SELECT id FROM target_definition))
//	    AND af.attribute_id = (SELECT id FROM target_definition)
//	    AND af.value_id IS NULL
//	),
//	subject_mappings_cte AS (
//	    SELECT
//	        av.id AS av_id,
//	        JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', sm.id,
//	                'actions', sm.actions,
//	                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                    'labels', sm.metadata -> 'labels',
//	                    'created_at', sm.created_at,
//	                    'updated_at', sm.updated_at
//	                )),
//	                'subject_condition_set', JSON_BUILD_OBJECT(
//	                    'id', scs.id,
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                        'labels', scs.metadata -> 'labels',
//	                        'created_at', scs.created_at,
//	                        'updated_at', scs.updated_at
//	                    )),
//	                    'subject_sets', scs.condition
//	                )
//	            )
//	        ) AS sub_maps_arr
//	    FROM
//	        subject_mappings sm
//	    LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	    LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
//	    WHERE av.active = TRUE
//	    AND av.attribute_definition_id = (SELECT id FROM target_definition)
//	    GROUP BY av.id
//	)
//	SELECT
//	    ad.id,
//	    ad.name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'labels', ad.metadata -> 'labels',
//	            'created_at', ad.created_at,
//	            'updated_at', ad.updated_at
//	        )
//	    ) AS metadata,
//	    ad.active,
//	    JSON_BUILD_OBJECT(
//	        'name', an.name,
//	        'id', an.id,
//	        'fqn', nfq.fqn,
//	        'grants', n_grants.grants,
//	        'active', an.active
//	    ) AS namespace,
//	    (SELECT fqn FROM target_definition_fqn_cte) AS definition_fqn,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', af.fqn,
//	            'subject_mappings', sm.sub_maps_arr,
//	            'grants', avt.val_grants_arr
//	        -- enforce order of values in response
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    JSONB_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'public_key', kas.public_key
//	        )
//	    ) FILTER (WHERE kas.id IS NOT NULL AND kas.uri IS NOT NULL AND kas.public_key IS NOT NULL) AS definition_grants
//	FROM
//	    attribute_definitions ad
//	LEFT JOIN attribute_namespaces an ON an.id = ad.namespace_id
//	LEFT JOIN active_attribute_values avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
//	LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
//	LEFT JOIN attribute_fqns af ON af.value_id = avt.id
//	LEFT JOIN namespace_fqn_cte nfq ON nfq.namespace_id = an.id
//	LEFT JOIN namespace_grants_cte n_grants ON n_grants.namespace_id = an.id
//	LEFT JOIN subject_mappings_cte sm ON avt.id = sm.av_id
//	WHERE
//	    ad.active = TRUE
//	    AND ad.id = (SELECT id FROM target_definition)
//	    AND an.active = TRUE
//	GROUP BY
//	    ad.id, an.id, nfq.fqn, n_grants.grants
func (q *Queries) GetAttributeByDefOrValueFqn(ctx context.Context, fqn string) (GetAttributeByDefOrValueFqnRow, error) {
	row := q.db.QueryRow(ctx, getAttributeByDefOrValueFqn, fqn)
	var i GetAttributeByDefOrValueFqnRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Rule,
		&i.Metadata,
		&i.Active,
		&i.Namespace,
		&i.DefinitionFqn,
		&i.Values,
		&i.DefinitionGrants,
	)
	return i, err
}

const getAttributeValue = `-- name: GetAttributeValue :one
SELECT
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn,
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )
    ) FILTER (WHERE avkag.attribute_value_id IS NOT NULL) AS grants
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
WHERE av.id = $1
GROUP BY av.id, fqns.fqn
`

type GetAttributeValueRow struct {
	ID                    string      `json:"id"`
	Value                 string      `json:"value"`
	Active                bool        `json:"active"`
	Metadata              []byte      `json:"metadata"`
	AttributeDefinitionID string      `json:"attribute_definition_id"`
	Fqn                   pgtype.Text `json:"fqn"`
	Grants                []byte      `json:"grants"`
}

// GetAttributeValue
//
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn,
//	    JSONB_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )
//	    ) FILTER (WHERE avkag.attribute_value_id IS NOT NULL) AS grants
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
//	LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//	WHERE av.id = $1
//	GROUP BY av.id, fqns.fqn
func (q *Queries) GetAttributeValue(ctx context.Context, id string) (GetAttributeValueRow, error) {
	row := q.db.QueryRow(ctx, getAttributeValue, id)
	var i GetAttributeValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Metadata,
		&i.AttributeDefinitionID,
		&i.Fqn,
		&i.Grants,
	)
	return i, err
}

const getKeyAccessServer = `-- name: GetKeyAccessServer :one
SELECT id, uri, public_key, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM key_access_servers
WHERE id = $1
`

type GetKeyAccessServerRow struct {
	ID        string      `json:"id"`
	Uri       string      `json:"uri"`
	PublicKey []byte      `json:"public_key"`
	Name      pgtype.Text `json:"name"`
	Metadata  []byte      `json:"metadata"`
}

// GetKeyAccessServer
//
//	SELECT id, uri, public_key, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM key_access_servers
//	WHERE id = $1
func (q *Queries) GetKeyAccessServer(ctx context.Context, id string) (GetKeyAccessServerRow, error) {
	row := q.db.QueryRow(ctx, getKeyAccessServer, id)
	var i GetKeyAccessServerRow
	err := row.Scan(
		&i.ID,
		&i.Uri,
		&i.PublicKey,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const getNamespace = `-- name: GetNamespace :one
SELECT
    ns.id,
    ns.name,
    ns.active,
    fqns.fqn,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', kas.id,
        'uri', kas.uri,
        'name', kas.name,
        'public_key', kas.public_key
    )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL) as grants
FROM attribute_namespaces ns
LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
WHERE ns.id = $1 AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
GROUP BY ns.id, fqns.fqn
`

type GetNamespaceRow struct {
	ID       string      `json:"id"`
	Name     string      `json:"name"`
	Active   bool        `json:"active"`
	Fqn      pgtype.Text `json:"fqn"`
	Metadata []byte      `json:"metadata"`
	Grants   []byte      `json:"grants"`
}

// GetNamespace
//
//	SELECT
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    fqns.fqn,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	        'id', kas.id,
//	        'uri', kas.uri,
//	        'name', kas.name,
//	        'public_key', kas.public_key
//	    )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL) as grants
//	FROM attribute_namespaces ns
//	LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
//	LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
//	WHERE ns.id = $1 AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	GROUP BY ns.id, fqns.fqn
func (q *Queries) GetNamespace(ctx context.Context, id string) (GetNamespaceRow, error) {
	row := q.db.QueryRow(ctx, getNamespace, id)
	var i GetNamespaceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.Fqn,
		&i.Metadata,
		&i.Grants,
	)
	return i, err
}

const getResourceMapping = `-- name: GetResourceMapping :one
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
FROM resource_mappings m 
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE m.id = $1
GROUP BY av.id, m.id, fqns.fqn
`

type GetResourceMappingRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	GroupID        string   `json:"group_id"`
}

// GetResourceMapping
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE m.id = $1
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) GetResourceMapping(ctx context.Context, id string) (GetResourceMappingRow, error) {
	row := q.db.QueryRow(ctx, getResourceMapping, id)
	var i GetResourceMappingRow
	err := row.Scan(
		&i.ID,
		&i.AttributeValue,
		&i.Terms,
		&i.Metadata,
		&i.GroupID,
	)
	return i, err
}

const getResourceMappingGroup = `-- name: GetResourceMappingGroup :one
SELECT id, namespace_id, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM resource_mapping_groups
WHERE id = $1
`

type GetResourceMappingGroupRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// GetResourceMappingGroup
//
//	SELECT id, namespace_id, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM resource_mapping_groups
//	WHERE id = $1
func (q *Queries) GetResourceMappingGroup(ctx context.Context, id string) (GetResourceMappingGroupRow, error) {
	row := q.db.QueryRow(ctx, getResourceMappingGroup, id)
	var i GetResourceMappingGroupRow
	err := row.Scan(
		&i.ID,
		&i.NamespaceID,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const getSubjectConditionSet = `-- name: GetSubjectConditionSet :one
SELECT
    id,
    condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM subject_condition_set
WHERE id = $1
`

type GetSubjectConditionSetRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// GetSubjectConditionSet
//
//	SELECT
//	    id,
//	    condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM subject_condition_set
//	WHERE id = $1
func (q *Queries) GetSubjectConditionSet(ctx context.Context, id string) (GetSubjectConditionSetRow, error) {
	row := q.db.QueryRow(ctx, getSubjectConditionSet, id)
	var i GetSubjectConditionSetRow
	err := row.Scan(&i.ID, &i.Condition, &i.Metadata)
	return i, err
}

const getSubjectMapping = `-- name: GetSubjectMapping :one
SELECT
    sm.id,
    sm.actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE sm.id = $1
GROUP BY av.id, sm.id, scs.id
`

type GetSubjectMappingRow struct {
	ID                  string `json:"id"`
	Actions             []byte `json:"actions"`
	Metadata            []byte `json:"metadata"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
}

// GetSubjectMapping
//
//	SELECT
//	    sm.id,
//	    sm.actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE sm.id = $1
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) GetSubjectMapping(ctx context.Context, id string) (GetSubjectMappingRow, error) {
	row := q.db.QueryRow(ctx, getSubjectMapping, id)
	var i GetSubjectMappingRow
	err := row.Scan(
		&i.ID,
		&i.Actions,
		&i.Metadata,
		&i.SubjectConditionSet,
		&i.AttributeValue,
	)
	return i, err
}

const listAttributeValues = `-- name: ListAttributeValues :many


SELECT
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
WHERE (
    ($1::BOOLEAN IS NULL OR av.active = $1) AND
    (NULLIF($2, '') IS NULL OR av.attribute_definition_id = $2::UUID)
)
GROUP BY av.id, fqns.fqn
`

type ListAttributeValuesParams struct {
	Active                pgtype.Bool `json:"active"`
	AttributeDefinitionID interface{} `json:"attribute_definition_id"`
}

type ListAttributeValuesRow struct {
	ID                    string      `json:"id"`
	Value                 string      `json:"value"`
	Active                bool        `json:"active"`
	Metadata              []byte      `json:"metadata"`
	AttributeDefinitionID string      `json:"attribute_definition_id"`
	Fqn                   pgtype.Text `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTE VALUES
// --------------------------------------------------------------
//
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	WHERE (
//	    ($1::BOOLEAN IS NULL OR av.active = $1) AND
//	    (NULLIF($2, '') IS NULL OR av.attribute_definition_id = $2::UUID)
//	)
//	GROUP BY av.id, fqns.fqn
func (q *Queries) ListAttributeValues(ctx context.Context, arg ListAttributeValuesParams) ([]ListAttributeValuesRow, error) {
	rows, err := q.db.Query(ctx, listAttributeValues, arg.Active, arg.AttributeDefinitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributeValuesRow
	for rows.Next() {
		var i ListAttributeValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Metadata,
			&i.AttributeDefinitionID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesDetail = `-- name: ListAttributesDetail :many

SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS values,
    fqns.fqn
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
  SELECT
    av.id,
    av.value,
    av.active,
    JSON_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', vkas.id,
            'uri', vkas.uri,
            'name', vkas.name,
            'public_key', vkas.public_key
        )
    ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
    av.attribute_definition_id
  FROM attribute_values av
  LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
  LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
  GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE
    ($1::BOOLEAN IS NULL OR ad.active = $1) AND
    (NULLIF($2, '') IS NULL OR ad.namespace_id = $2::uuid) AND
    (NULLIF($3, '') IS NULL OR n.name = $3)
GROUP BY ad.id, n.name, fqns.fqn
`

type ListAttributesDetailParams struct {
	Active        pgtype.Bool `json:"active"`
	NamespaceID   interface{} `json:"namespace_id"`
	NamespaceName interface{} `json:"namespace_name"`
}

type ListAttributesDetailRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
	Values        []byte                  `json:"values"`
	Fqn           pgtype.Text             `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTES
// --------------------------------------------------------------
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    fqns.fqn
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	  SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', vkas.id,
//	            'uri', vkas.uri,
//	            'name', vkas.name,
//	            'public_key', vkas.public_key
//	        )
//	    ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
//	    av.attribute_definition_id
//	  FROM attribute_values av
//	  LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
//	  LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
//	  GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE
//	    ($1::BOOLEAN IS NULL OR ad.active = $1) AND
//	    (NULLIF($2, '') IS NULL OR ad.namespace_id = $2::uuid) AND
//	    (NULLIF($3, '') IS NULL OR n.name = $3)
//	GROUP BY ad.id, n.name, fqns.fqn
func (q *Queries) ListAttributesDetail(ctx context.Context, arg ListAttributesDetailParams) ([]ListAttributesDetailRow, error) {
	rows, err := q.db.Query(ctx, listAttributesDetail, arg.Active, arg.NamespaceID, arg.NamespaceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesDetailRow
	for rows.Next() {
		var i ListAttributesDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Values,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesSummary = `-- name: ListAttributesSummary :many
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
WHERE ad.namespace_id = $1
GROUP BY ad.id, n.name
`

type ListAttributesSummaryRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
}

// ListAttributesSummary
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	WHERE ad.namespace_id = $1
//	GROUP BY ad.id, n.name
func (q *Queries) ListAttributesSummary(ctx context.Context, namespaceID string) ([]ListAttributesSummaryRow, error) {
	rows, err := q.db.Query(ctx, listAttributesSummary, namespaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesSummaryRow
	for rows.Next() {
		var i ListAttributesSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyAccessServerGrants = `-- name: ListKeyAccessServerGrants :many

SELECT 
    kas.id AS kas_id, 
    kas.uri AS kas_uri, 
    kas.name AS kas_name,
    kas.public_key AS kas_public_key,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
        'labels', kas.metadata -> 'labels', 
        'created_at', kas.created_at, 
        'updated_at', kas.updated_at
    )) AS kas_metadata,
    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', attrkag.attribute_definition_id, 
        'fqn', fqns_on_attr.fqn
    )) FILTER (WHERE attrkag.attribute_definition_id IS NOT NULL) AS attributes_grants,
    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', valkag.attribute_value_id, 
        'fqn', fqns_on_vals.fqn
    )) FILTER (WHERE valkag.attribute_value_id IS NOT NULL) AS values_grants,
    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', nskag.namespace_id, 
        'fqn', fqns_on_ns.fqn
    )) FILTER (WHERE nskag.namespace_id IS NOT NULL) AS namespace_grants
FROM 
    key_access_servers kas
LEFT JOIN 
    attribute_definition_key_access_grants attrkag 
    ON kas.id = attrkag.key_access_server_id
LEFT JOIN 
    attribute_fqns fqns_on_attr 
    ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id 
    AND fqns_on_attr.value_id IS NULL
LEFT JOIN 
    attribute_value_key_access_grants valkag 
    ON kas.id = valkag.key_access_server_id
LEFT JOIN 
    attribute_fqns fqns_on_vals 
    ON valkag.attribute_value_id = fqns_on_vals.value_id
LEFT JOIN
    attribute_namespace_key_access_grants nskag
    ON kas.id = nskag.key_access_server_id
LEFT JOIN 
    attribute_fqns fqns_on_ns
    ON nskag.namespace_id = fqns_on_ns.namespace_id
    AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
WHERE (NULLIF($1, '') IS NULL OR kas.id = $1::uuid)
    AND (NULLIF($2, '') IS NULL OR kas.uri = $2::varchar)
    AND (NULLIF($3, '') IS NULL OR kas.name = $3::varchar)
GROUP BY 
    kas.id
`

type ListKeyAccessServerGrantsParams struct {
	KasID   interface{} `json:"kas_id"`
	KasUri  interface{} `json:"kas_uri"`
	KasName interface{} `json:"kas_name"`
}

type ListKeyAccessServerGrantsRow struct {
	KasID            string      `json:"kas_id"`
	KasUri           string      `json:"kas_uri"`
	KasName          pgtype.Text `json:"kas_name"`
	KasPublicKey     []byte      `json:"kas_public_key"`
	KasMetadata      []byte      `json:"kas_metadata"`
	AttributesGrants []byte      `json:"attributes_grants"`
	ValuesGrants     []byte      `json:"values_grants"`
	NamespaceGrants  []byte      `json:"namespace_grants"`
}

// --------------------------------------------------------------
// KEY ACCESS SERVERS
// --------------------------------------------------------------
//
//	SELECT
//	    kas.id AS kas_id,
//	    kas.uri AS kas_uri,
//	    kas.name AS kas_name,
//	    kas.public_key AS kas_public_key,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	        'labels', kas.metadata -> 'labels',
//	        'created_at', kas.created_at,
//	        'updated_at', kas.updated_at
//	    )) AS kas_metadata,
//	    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	        'id', attrkag.attribute_definition_id,
//	        'fqn', fqns_on_attr.fqn
//	    )) FILTER (WHERE attrkag.attribute_definition_id IS NOT NULL) AS attributes_grants,
//	    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	        'id', valkag.attribute_value_id,
//	        'fqn', fqns_on_vals.fqn
//	    )) FILTER (WHERE valkag.attribute_value_id IS NOT NULL) AS values_grants,
//	    JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	        'id', nskag.namespace_id,
//	        'fqn', fqns_on_ns.fqn
//	    )) FILTER (WHERE nskag.namespace_id IS NOT NULL) AS namespace_grants
//	FROM
//	    key_access_servers kas
//	LEFT JOIN
//	    attribute_definition_key_access_grants attrkag
//	    ON kas.id = attrkag.key_access_server_id
//	LEFT JOIN
//	    attribute_fqns fqns_on_attr
//	    ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id
//	    AND fqns_on_attr.value_id IS NULL
//	LEFT JOIN
//	    attribute_value_key_access_grants valkag
//	    ON kas.id = valkag.key_access_server_id
//	LEFT JOIN
//	    attribute_fqns fqns_on_vals
//	    ON valkag.attribute_value_id = fqns_on_vals.value_id
//	LEFT JOIN
//	    attribute_namespace_key_access_grants nskag
//	    ON kas.id = nskag.key_access_server_id
//	LEFT JOIN
//	    attribute_fqns fqns_on_ns
//	    ON nskag.namespace_id = fqns_on_ns.namespace_id
//	    AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
//	WHERE (NULLIF($1, '') IS NULL OR kas.id = $1::uuid)
//	    AND (NULLIF($2, '') IS NULL OR kas.uri = $2::varchar)
//	    AND (NULLIF($3, '') IS NULL OR kas.name = $3::varchar)
//	GROUP BY
//	    kas.id
func (q *Queries) ListKeyAccessServerGrants(ctx context.Context, arg ListKeyAccessServerGrantsParams) ([]ListKeyAccessServerGrantsRow, error) {
	rows, err := q.db.Query(ctx, listKeyAccessServerGrants, arg.KasID, arg.KasUri, arg.KasName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServerGrantsRow
	for rows.Next() {
		var i ListKeyAccessServerGrantsRow
		if err := rows.Scan(
			&i.KasID,
			&i.KasUri,
			&i.KasName,
			&i.KasPublicKey,
			&i.KasMetadata,
			&i.AttributesGrants,
			&i.ValuesGrants,
			&i.NamespaceGrants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyAccessServers = `-- name: ListKeyAccessServers :many
SELECT id, uri, public_key, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM key_access_servers
`

type ListKeyAccessServersRow struct {
	ID        string      `json:"id"`
	Uri       string      `json:"uri"`
	PublicKey []byte      `json:"public_key"`
	Name      pgtype.Text `json:"name"`
	Metadata  []byte      `json:"metadata"`
}

// ListKeyAccessServers
//
//	SELECT id, uri, public_key, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM key_access_servers
func (q *Queries) ListKeyAccessServers(ctx context.Context) ([]ListKeyAccessServersRow, error) {
	rows, err := q.db.Query(ctx, listKeyAccessServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServersRow
	for rows.Next() {
		var i ListKeyAccessServersRow
		if err := rows.Scan(
			&i.ID,
			&i.Uri,
			&i.PublicKey,
			&i.Name,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNamespaces = `-- name: ListNamespaces :many

SELECT
    ns.id,
    ns.name,
    ns.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    fqns.fqn
FROM attribute_namespaces ns
LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
WHERE ($1::BOOLEAN IS NULL OR ns.active = $1::BOOLEAN)
`

type ListNamespacesRow struct {
	ID       string      `json:"id"`
	Name     string      `json:"name"`
	Active   bool        `json:"active"`
	Metadata []byte      `json:"metadata"`
	Fqn      pgtype.Text `json:"fqn"`
}

// --------------------------------------------------------------
// NAMESPACES
// --------------------------------------------------------------
//
//	SELECT
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    fqns.fqn
//	FROM attribute_namespaces ns
//	LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
//	WHERE ($1::BOOLEAN IS NULL OR ns.active = $1::BOOLEAN)
func (q *Queries) ListNamespaces(ctx context.Context, active pgtype.Bool) ([]ListNamespacesRow, error) {
	rows, err := q.db.Query(ctx, listNamespaces, active)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNamespacesRow
	for rows.Next() {
		var i ListNamespacesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.Metadata,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingGroups = `-- name: ListResourceMappingGroups :many

SELECT id, namespace_id, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM resource_mapping_groups
WHERE (NULLIF($1, '') IS NULL OR namespace_id = $1::uuid)
`

type ListResourceMappingGroupsRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING GROUPS
// --------------------------------------------------------------
//
//	SELECT id, namespace_id, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM resource_mapping_groups
//	WHERE (NULLIF($1, '') IS NULL OR namespace_id = $1::uuid)
func (q *Queries) ListResourceMappingGroups(ctx context.Context, namespaceID interface{}) ([]ListResourceMappingGroupsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingGroups, namespaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingGroupsRow
	for rows.Next() {
		var i ListResourceMappingGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappings = `-- name: ListResourceMappings :many

SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
FROM resource_mappings m 
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID)
GROUP BY av.id, m.id, fqns.fqn
`

type ListResourceMappingsRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	GroupID        string   `json:"group_id"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING
// --------------------------------------------------------------
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID)
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) ListResourceMappings(ctx context.Context, groupID interface{}) ([]ListResourceMappingsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappings, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsRow
	for rows.Next() {
		var i ListResourceMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingsByFullyQualifiedGroup = `-- name: ListResourceMappingsByFullyQualifiedGroup :many
WITH groups_cte AS (
    SELECT
        g.id,
        JSON_BUILD_OBJECT(
            'id', g.id,
            'namespace_id', g.namespace_id,
            'name', g.name,
            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                'labels', g.metadata -> 'labels',
                'created_at', g.created_at,
                'updated_at', g.updated_at
            ))
        ) as group
    FROM resource_mapping_groups g
    JOIN attribute_namespaces ns on g.namespace_id = ns.id
    WHERE ns.name = $1 AND g.name = $2
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    g.group
FROM resource_mappings m
JOIN groups_cte g ON m.group_id = g.id
JOIN attribute_values av on m.attribute_value_id = av.id
JOIN attribute_fqns fqns on av.id = fqns.value_id
`

type ListResourceMappingsByFullyQualifiedGroupParams struct {
	NamespaceName string `json:"namespace_name"`
	GroupName     string `json:"group_name"`
}

type ListResourceMappingsByFullyQualifiedGroupRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	Group          []byte   `json:"group"`
}

// CTE to cache the group JSON build since it will be the same for all mappings of the group
//
//	WITH groups_cte AS (
//	    SELECT
//	        g.id,
//	        JSON_BUILD_OBJECT(
//	            'id', g.id,
//	            'namespace_id', g.namespace_id,
//	            'name', g.name,
//	            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                'labels', g.metadata -> 'labels',
//	                'created_at', g.created_at,
//	                'updated_at', g.updated_at
//	            ))
//	        ) as group
//	    FROM resource_mapping_groups g
//	    JOIN attribute_namespaces ns on g.namespace_id = ns.id
//	    WHERE ns.name = $1 AND g.name = $2
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    g.group
//	FROM resource_mappings m
//	JOIN groups_cte g ON m.group_id = g.id
//	JOIN attribute_values av on m.attribute_value_id = av.id
//	JOIN attribute_fqns fqns on av.id = fqns.value_id
func (q *Queries) ListResourceMappingsByFullyQualifiedGroup(ctx context.Context, arg ListResourceMappingsByFullyQualifiedGroupParams) ([]ListResourceMappingsByFullyQualifiedGroupRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingsByFullyQualifiedGroup, arg.NamespaceName, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsByFullyQualifiedGroupRow
	for rows.Next() {
		var i ListResourceMappingsByFullyQualifiedGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectConditionSets = `-- name: ListSubjectConditionSets :many

SELECT
    id,
    condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM subject_condition_set
`

type ListSubjectConditionSetsRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// --------------------------------------------------------------
// SUBJECT CONDITION SETS
// --------------------------------------------------------------
//
//	SELECT
//	    id,
//	    condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM subject_condition_set
func (q *Queries) ListSubjectConditionSets(ctx context.Context) ([]ListSubjectConditionSetsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectConditionSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectConditionSetsRow
	for rows.Next() {
		var i ListSubjectConditionSetsRow
		if err := rows.Scan(&i.ID, &i.Condition, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectMappings = `-- name: ListSubjectMappings :many

SELECT
    sm.id,
    sm.actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
GROUP BY av.id, sm.id, scs.id
`

type ListSubjectMappingsRow struct {
	ID                  string `json:"id"`
	Actions             []byte `json:"actions"`
	Metadata            []byte `json:"metadata"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
}

// --------------------------------------------------------------
// SUBJECT MAPPINGS
// --------------------------------------------------------------
//
//	SELECT
//	    sm.id,
//	    sm.actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) ListSubjectMappings(ctx context.Context) ([]ListSubjectMappingsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectMappingsRow
	for rows.Next() {
		var i ListSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Actions,
			&i.Metadata,
			&i.SubjectConditionSet,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttribute = `-- name: RemoveKeyAccessServerFromAttribute :execrows
DELETE FROM attribute_definition_key_access_grants
WHERE attribute_definition_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	KeyAccessServerID     string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttribute
//
//	DELETE FROM attribute_definition_key_access_grants
//	WHERE attribute_definition_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttribute(ctx context.Context, arg RemoveKeyAccessServerFromAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeKeyAccessServerFromAttributeValue = `-- name: RemoveKeyAccessServerFromAttributeValue :execrows
DELETE FROM attribute_value_key_access_grants
WHERE attribute_value_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeValueParams struct {
	AttributeValueID  string `json:"attribute_value_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttributeValue
//
//	DELETE FROM attribute_value_key_access_grants
//	WHERE attribute_value_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttributeValue(ctx context.Context, arg RemoveKeyAccessServerFromAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeKeyAccessServerFromNamespace = `-- name: RemoveKeyAccessServerFromNamespace :execrows
DELETE FROM attribute_namespace_key_access_grants
WHERE namespace_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromNamespaceParams struct {
	NamespaceID       string `json:"namespace_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromNamespace
//
//	DELETE FROM attribute_namespace_key_access_grants
//	WHERE namespace_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromNamespace(ctx context.Context, arg RemoveKeyAccessServerFromNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromNamespace, arg.NamespaceID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAttribute = `-- name: UpdateAttribute :execrows
UPDATE attribute_definitions
SET
    name = COALESCE($2, name),
    rule = COALESCE($3, rule),
    values_order = COALESCE($4, values_order),
    metadata = COALESCE($5, metadata),
    active = COALESCE($6, active)
WHERE id = $1
`

type UpdateAttributeParams struct {
	ID          string                      `json:"id"`
	Name        pgtype.Text                 `json:"name"`
	Rule        NullAttributeDefinitionRule `json:"rule"`
	ValuesOrder []string                    `json:"values_order"`
	Metadata    []byte                      `json:"metadata"`
	Active      pgtype.Bool                 `json:"active"`
}

// UpdateAttribute: Unsafe and Safe Updates both
//
//	UPDATE attribute_definitions
//	SET
//	    name = COALESCE($2, name),
//	    rule = COALESCE($3, rule),
//	    values_order = COALESCE($4, values_order),
//	    metadata = COALESCE($5, metadata),
//	    active = COALESCE($6, active)
//	WHERE id = $1
func (q *Queries) UpdateAttribute(ctx context.Context, arg UpdateAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAttribute,
		arg.ID,
		arg.Name,
		arg.Rule,
		arg.ValuesOrder,
		arg.Metadata,
		arg.Active,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAttributeValue = `-- name: UpdateAttributeValue :execrows
UPDATE attribute_values
SET
    value = COALESCE($2, value),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateAttributeValueParams struct {
	ID       string      `json:"id"`
	Value    pgtype.Text `json:"value"`
	Active   pgtype.Bool `json:"active"`
	Metadata []byte      `json:"metadata"`
}

// UpdateAttributeValue: Safe and Unsafe Updates both
//
//	UPDATE attribute_values
//	SET
//	    value = COALESCE($2, value),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateAttributeValue(ctx context.Context, arg UpdateAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAttributeValue,
		arg.ID,
		arg.Value,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateKeyAccessServer = `-- name: UpdateKeyAccessServer :execrows
UPDATE key_access_servers
SET 
    uri = COALESCE($2, uri),
    public_key = COALESCE($3, public_key),
    name = COALESCE($4, name),
    metadata = COALESCE($5, metadata)
WHERE id = $1
`

type UpdateKeyAccessServerParams struct {
	ID        string      `json:"id"`
	Uri       pgtype.Text `json:"uri"`
	PublicKey []byte      `json:"public_key"`
	Name      pgtype.Text `json:"name"`
	Metadata  []byte      `json:"metadata"`
}

// UpdateKeyAccessServer
//
//	UPDATE key_access_servers
//	SET
//	    uri = COALESCE($2, uri),
//	    public_key = COALESCE($3, public_key),
//	    name = COALESCE($4, name),
//	    metadata = COALESCE($5, metadata)
//	WHERE id = $1
func (q *Queries) UpdateKeyAccessServer(ctx context.Context, arg UpdateKeyAccessServerParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateKeyAccessServer,
		arg.ID,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateNamespace = `-- name: UpdateNamespace :execrows
UPDATE attribute_namespaces
SET
    name = COALESCE($2, name),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateNamespaceParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Active   pgtype.Bool `json:"active"`
	Metadata []byte      `json:"metadata"`
}

// UpdateNamespace: both Safe and Unsafe Updates
//
//	UPDATE attribute_namespaces
//	SET
//	    name = COALESCE($2, name),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateNamespace(ctx context.Context, arg UpdateNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateNamespace,
		arg.ID,
		arg.Name,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResourceMapping = `-- name: UpdateResourceMapping :execrows
UPDATE resource_mappings
SET
    attribute_value_id = COALESCE($2, attribute_value_id),
    terms = COALESCE($3, terms),
    metadata = COALESCE($4, metadata),
    group_id = COALESCE($5, group_id)
WHERE id = $1
`

type UpdateResourceMappingParams struct {
	ID               string      `json:"id"`
	AttributeValueID pgtype.UUID `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// UpdateResourceMapping
//
//	UPDATE resource_mappings
//	SET
//	    attribute_value_id = COALESCE($2, attribute_value_id),
//	    terms = COALESCE($3, terms),
//	    metadata = COALESCE($4, metadata),
//	    group_id = COALESCE($5, group_id)
//	WHERE id = $1
func (q *Queries) UpdateResourceMapping(ctx context.Context, arg UpdateResourceMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResourceMappingGroup = `-- name: UpdateResourceMappingGroup :execrows
UPDATE resource_mapping_groups
SET
    namespace_id = COALESCE($2, namespace_id),
    name = COALESCE($3, name),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateResourceMappingGroupParams struct {
	ID          string      `json:"id"`
	NamespaceID pgtype.UUID `json:"namespace_id"`
	Name        pgtype.Text `json:"name"`
	Metadata    []byte      `json:"metadata"`
}

// UpdateResourceMappingGroup
//
//	UPDATE resource_mapping_groups
//	SET
//	    namespace_id = COALESCE($2, namespace_id),
//	    name = COALESCE($3, name),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateResourceMappingGroup(ctx context.Context, arg UpdateResourceMappingGroupParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMappingGroup,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubjectConditionSet = `-- name: UpdateSubjectConditionSet :execrows
UPDATE subject_condition_set
SET
    condition = COALESCE($2, condition),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type UpdateSubjectConditionSetParams struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// UpdateSubjectConditionSet
//
//	UPDATE subject_condition_set
//	SET
//	    condition = COALESCE($2, condition),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateSubjectConditionSet(ctx context.Context, arg UpdateSubjectConditionSetParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectConditionSet, arg.ID, arg.Condition, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubjectMapping = `-- name: UpdateSubjectMapping :execrows
UPDATE subject_mappings
SET
    actions = COALESCE($2, actions),
    metadata = COALESCE($3, metadata),
    subject_condition_set_id = COALESCE($4, subject_condition_set_id)
WHERE id = $1
`

type UpdateSubjectMappingParams struct {
	ID                    string      `json:"id"`
	Actions               []byte      `json:"actions"`
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
}

// UpdateSubjectMapping
//
//	UPDATE subject_mappings
//	SET
//	    actions = COALESCE($2, actions),
//	    metadata = COALESCE($3, metadata),
//	    subject_condition_set_id = COALESCE($4, subject_condition_set_id)
//	WHERE id = $1
func (q *Queries) UpdateSubjectMapping(ctx context.Context, arg UpdateSubjectMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectMapping,
		arg.ID,
		arg.Actions,
		arg.Metadata,
		arg.SubjectConditionSetID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertAttributeDefinitionFqn = `-- name: UpsertAttributeDefinitionFqn :one
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT
    n.id,
    ad.id,
    NULL,
    CONCAT('https://', n.name, '/attr/', ad.name) AS fqn
FROM attribute_namespaces n
JOIN attribute_definitions ad ON n.id = ad.namespace_id
WHERE ad.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// UpsertAttributeDefinitionFqn
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    n.id,
//	    ad.id,
//	    NULL,
//	    CONCAT('https://', n.name, '/attr/', ad.name) AS fqn
//	FROM attribute_namespaces n
//	JOIN attribute_definitions ad ON n.id = ad.namespace_id
//	WHERE ad.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttributeDefinitionFqn(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, upsertAttributeDefinitionFqn, id)
	var fqn string
	err := row.Scan(&fqn)
	return fqn, err
}

const upsertAttributeNamespaceFqn = `-- name: UpsertAttributeNamespaceFqn :one
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT
    n.id,
    NULL,
    NULL,
    CONCAT('https://', n.name) AS fqn
FROM attribute_namespaces n
WHERE n.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// UpsertAttributeNamespaceFqn
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    n.id,
//	    NULL,
//	    NULL,
//	    CONCAT('https://', n.name) AS fqn
//	FROM attribute_namespaces n
//	WHERE n.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttributeNamespaceFqn(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, upsertAttributeNamespaceFqn, id)
	var fqn string
	err := row.Scan(&fqn)
	return fqn, err
}

const upsertAttributeValueFqn = `-- name: UpsertAttributeValueFqn :one

INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT
    n.id,
    ad.id,
    av.id,
    CONCAT('https://', n.name, '/attr/', ad.name, '/value/', av.value) AS fqn
FROM attribute_namespaces n
JOIN attribute_definitions ad ON n.id = ad.namespace_id
JOIN attribute_values av ON ad.id = av.attribute_definition_id
WHERE av.id = $1
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING fqn
`

// --------------------------------------------------------------
// ATTRIBUTE FQN
// --------------------------------------------------------------
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    n.id,
//	    ad.id,
//	    av.id,
//	    CONCAT('https://', n.name, '/attr/', ad.name, '/value/', av.value) AS fqn
//	FROM attribute_namespaces n
//	JOIN attribute_definitions ad ON n.id = ad.namespace_id
//	JOIN attribute_values av ON ad.id = av.attribute_definition_id
//	WHERE av.id = $1
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING fqn
func (q *Queries) UpsertAttributeValueFqn(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, upsertAttributeValueFqn, id)
	var fqn string
	err := row.Scan(&fqn)
	return fqn, err
}
