// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignKeyAccessServerToAttribute = `-- name: AssignKeyAccessServerToAttribute :execrows
INSERT INTO attribute_definition_key_access_grants (attribute_definition_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToAttributeParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	KeyAccessServerID     string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToAttribute
//
//	INSERT INTO attribute_definition_key_access_grants (attribute_definition_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToAttribute(ctx context.Context, arg AssignKeyAccessServerToAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignKeyAccessServerToAttributeValue = `-- name: AssignKeyAccessServerToAttributeValue :execrows
INSERT INTO attribute_value_key_access_grants (attribute_value_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToAttributeValueParams struct {
	AttributeValueID  string `json:"attribute_value_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToAttributeValue
//
//	INSERT INTO attribute_value_key_access_grants (attribute_value_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToAttributeValue(ctx context.Context, arg AssignKeyAccessServerToAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const assignKeyAccessServerToNamespace = `-- name: AssignKeyAccessServerToNamespace :execrows
INSERT INTO attribute_namespace_key_access_grants (namespace_id, key_access_server_id)
VALUES ($1, $2)
`

type AssignKeyAccessServerToNamespaceParams struct {
	NamespaceID       string `json:"namespace_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// AssignKeyAccessServerToNamespace
//
//	INSERT INTO attribute_namespace_key_access_grants (namespace_id, key_access_server_id)
//	VALUES ($1, $2)
func (q *Queries) AssignKeyAccessServerToNamespace(ctx context.Context, arg AssignKeyAccessServerToNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, assignKeyAccessServerToNamespace, arg.NamespaceID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const checkIfKeyExists = `-- name: CheckIfKeyExists :one
SELECT EXISTS (
    SELECT 1
    FROM key_access_server_keys
    WHERE key_access_server_id = $1 AND key_status = $2 AND key_algorithm = $3
)
`

type CheckIfKeyExistsParams struct {
	KeyAccessServerID string `json:"key_access_server_id"`
	KeyStatus         int32  `json:"key_status"`
	KeyAlgorithm      int32  `json:"key_algorithm"`
}

// CheckIfKeyExists
//
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM key_access_server_keys
//	    WHERE key_access_server_id = $1 AND key_status = $2 AND key_algorithm = $3
//	)
func (q *Queries) CheckIfKeyExists(ctx context.Context, arg CheckIfKeyExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfKeyExists, arg.KeyAccessServerID, arg.KeyStatus, arg.KeyAlgorithm)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAttribute = `-- name: CreateAttribute :one
INSERT INTO attribute_definitions (namespace_id, name, rule, metadata)
VALUES ($1, $2, $3, $4) 
RETURNING id
`

type CreateAttributeParams struct {
	NamespaceID string                  `json:"namespace_id"`
	Name        string                  `json:"name"`
	Rule        AttributeDefinitionRule `json:"rule"`
	Metadata    []byte                  `json:"metadata"`
}

// CreateAttribute
//
//	INSERT INTO attribute_definitions (namespace_id, name, rule, metadata)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateAttribute(ctx context.Context, arg CreateAttributeParams) (string, error) {
	row := q.db.QueryRow(ctx, createAttribute,
		arg.NamespaceID,
		arg.Name,
		arg.Rule,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createAttributeValue = `-- name: CreateAttributeValue :one
INSERT INTO attribute_values (attribute_definition_id, value, metadata)
VALUES ($1, $2, $3) 
RETURNING id
`

type CreateAttributeValueParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	Value                 string `json:"value"`
	Metadata              []byte `json:"metadata"`
}

// CreateAttributeValue
//
//	INSERT INTO attribute_values (attribute_definition_id, value, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateAttributeValue(ctx context.Context, arg CreateAttributeValueParams) (string, error) {
	row := q.db.QueryRow(ctx, createAttributeValue, arg.AttributeDefinitionID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createKey = `-- name: CreateKey :one
WITH inserted AS (
  INSERT INTO key_access_server_keys
    (key_access_server_id, key_algorithm, key_id, key_mode, key_status, metadata, private_key_ctx, public_key_ctx, provider_config_id)
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
  RETURNING id, key_id, key_algorithm, key_status, key_mode, public_key_ctx, private_key_ctx, expiration, provider_config_id, metadata, created_at, updated_at, key_access_server_id
)
SELECT 
  id,
  key_id,
  key_status,
  key_mode,
  key_algorithm,
  private_key_ctx,
  public_key_ctx,
  provider_config_id,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', metadata -> 'labels',         
      'created_at', created_at,               
      'updated_at', updated_at                
    )
  ) AS metadata
FROM inserted
`

type CreateKeyParams struct {
	KeyAccessServerID string      `json:"key_access_server_id"`
	KeyAlgorithm      int32       `json:"key_algorithm"`
	KeyID             string      `json:"key_id"`
	KeyMode           int32       `json:"key_mode"`
	KeyStatus         int32       `json:"key_status"`
	Metadata          []byte      `json:"metadata"`
	PrivateKeyCtx     []byte      `json:"private_key_ctx"`
	PublicKeyCtx      []byte      `json:"public_key_ctx"`
	ProviderConfigID  pgtype.UUID `json:"provider_config_id"`
}

type CreateKeyRow struct {
	ID               string      `json:"id"`
	KeyID            string      `json:"key_id"`
	KeyStatus        int32       `json:"key_status"`
	KeyMode          int32       `json:"key_mode"`
	KeyAlgorithm     int32       `json:"key_algorithm"`
	PrivateKeyCtx    []byte      `json:"private_key_ctx"`
	PublicKeyCtx     []byte      `json:"public_key_ctx"`
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	Metadata         []byte      `json:"metadata"`
}

// ---------------------------------------------------------------
// Key Access Server Keys
// ----------------------------------------------------------------
//
//	WITH inserted AS (
//	  INSERT INTO key_access_server_keys
//	    (key_access_server_id, key_algorithm, key_id, key_mode, key_status, metadata, private_key_ctx, public_key_ctx, provider_config_id)
//	  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
//	  RETURNING id, key_id, key_algorithm, key_status, key_mode, public_key_ctx, private_key_ctx, expiration, provider_config_id, metadata, created_at, updated_at, key_access_server_id
//	)
//	SELECT
//	  id,
//	  key_id,
//	  key_status,
//	  key_mode,
//	  key_algorithm,
//	  private_key_ctx,
//	  public_key_ctx,
//	  provider_config_id,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', metadata -> 'labels',
//	      'created_at', created_at,
//	      'updated_at', updated_at
//	    )
//	  ) AS metadata
//	FROM inserted
func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (CreateKeyRow, error) {
	row := q.db.QueryRow(ctx, createKey,
		arg.KeyAccessServerID,
		arg.KeyAlgorithm,
		arg.KeyID,
		arg.KeyMode,
		arg.KeyStatus,
		arg.Metadata,
		arg.PrivateKeyCtx,
		arg.PublicKeyCtx,
		arg.ProviderConfigID,
	)
	var i CreateKeyRow
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.KeyStatus,
		&i.KeyMode,
		&i.KeyAlgorithm,
		&i.PrivateKeyCtx,
		&i.PublicKeyCtx,
		&i.ProviderConfigID,
		&i.Metadata,
	)
	return i, err
}

const createKeyAccessServer = `-- name: CreateKeyAccessServer :one
INSERT INTO key_access_servers (uri, public_key, name, metadata, source_type)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateKeyAccessServerParams struct {
	Uri        string      `json:"uri"`
	PublicKey  []byte      `json:"public_key"`
	Name       pgtype.Text `json:"name"`
	Metadata   []byte      `json:"metadata"`
	SourceType pgtype.Int4 `json:"source_type"`
}

// CreateKeyAccessServer
//
//	INSERT INTO key_access_servers (uri, public_key, name, metadata, source_type)
//	VALUES ($1, $2, $3, $4, $5)
//	RETURNING id
func (q *Queries) CreateKeyAccessServer(ctx context.Context, arg CreateKeyAccessServerParams) (string, error) {
	row := q.db.QueryRow(ctx, createKeyAccessServer,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
		arg.SourceType,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createNamespace = `-- name: CreateNamespace :one
INSERT INTO attribute_namespaces (name, metadata)
VALUES ($1, $2)
RETURNING id
`

type CreateNamespaceParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// CreateNamespace
//
//	INSERT INTO attribute_namespaces (name, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateNamespace(ctx context.Context, arg CreateNamespaceParams) (string, error) {
	row := q.db.QueryRow(ctx, createNamespace, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createProviderConfig = `-- name: CreateProviderConfig :one

WITH inserted AS (
  INSERT INTO provider_config (provider_name, config, metadata)
  VALUES ($1, $2, $3)
  RETURNING id, provider_name, config, created_at, updated_at, metadata
)
SELECT 
  id,
  provider_name,
  config,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', metadata -> 'labels',         
      'created_at', created_at,               
      'updated_at', updated_at                
    )
  ) AS metadata
FROM inserted
`

type CreateProviderConfigParams struct {
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

type CreateProviderConfigRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

// --------------------------------------------------------------
// Provider Config
// --------------------------------------------------------------
//
//	WITH inserted AS (
//	  INSERT INTO provider_config (provider_name, config, metadata)
//	  VALUES ($1, $2, $3)
//	  RETURNING id, provider_name, config, created_at, updated_at, metadata
//	)
//	SELECT
//	  id,
//	  provider_name,
//	  config,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', metadata -> 'labels',
//	      'created_at', created_at,
//	      'updated_at', updated_at
//	    )
//	  ) AS metadata
//	FROM inserted
func (q *Queries) CreateProviderConfig(ctx context.Context, arg CreateProviderConfigParams) (CreateProviderConfigRow, error) {
	row := q.db.QueryRow(ctx, createProviderConfig, arg.ProviderName, arg.Config, arg.Metadata)
	var i CreateProviderConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProviderName,
		&i.Config,
		&i.Metadata,
	)
	return i, err
}

const createResourceMapping = `-- name: CreateResourceMapping :one
INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateResourceMappingParams struct {
	AttributeValueID string      `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// CreateResourceMapping
//
//	INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) CreateResourceMapping(ctx context.Context, arg CreateResourceMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMapping,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMappingGroup = `-- name: CreateResourceMappingGroup :one
INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateResourceMappingGroupParams struct {
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// CreateResourceMappingGroup
//
//	INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateResourceMappingGroup(ctx context.Context, arg CreateResourceMappingGroupParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMappingGroup, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectConditionSet = `-- name: CreateSubjectConditionSet :one
INSERT INTO subject_condition_set (condition, metadata)
VALUES ($1, $2)
RETURNING id
`

type CreateSubjectConditionSetParams struct {
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// CreateSubjectConditionSet
//
//	INSERT INTO subject_condition_set (condition, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) CreateSubjectConditionSet(ctx context.Context, arg CreateSubjectConditionSetParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectConditionSet, arg.Condition, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllUnmappedSubjectConditionSets = `-- name: DeleteAllUnmappedSubjectConditionSets :many
DELETE FROM subject_condition_set
WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
RETURNING id
`

// DeleteAllUnmappedSubjectConditionSets
//
//	DELETE FROM subject_condition_set
//	WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
//	RETURNING id
func (q *Queries) DeleteAllUnmappedSubjectConditionSets(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, deleteAllUnmappedSubjectConditionSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAttribute = `-- name: DeleteAttribute :execrows
DELETE FROM attribute_definitions WHERE id = $1
`

// DeleteAttribute
//
//	DELETE FROM attribute_definitions WHERE id = $1
func (q *Queries) DeleteAttribute(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttribute, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAttributeValue = `-- name: DeleteAttributeValue :execrows
DELETE FROM attribute_values WHERE id = $1
`

// DeleteAttributeValue
//
//	DELETE FROM attribute_values WHERE id = $1
func (q *Queries) DeleteAttributeValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAttributeValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteKey = `-- name: DeleteKey :execrows
DELETE FROM key_access_server_keys WHERE id = $1
`

// DeleteKey
//
//	DELETE FROM key_access_server_keys WHERE id = $1
func (q *Queries) DeleteKey(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteKey, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteKeyAccessServer = `-- name: DeleteKeyAccessServer :execrows
DELETE FROM key_access_servers WHERE id = $1
`

// DeleteKeyAccessServer
//
//	DELETE FROM key_access_servers WHERE id = $1
func (q *Queries) DeleteKeyAccessServer(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteKeyAccessServer, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteNamespace = `-- name: DeleteNamespace :execrows
DELETE FROM attribute_namespaces WHERE id = $1
`

// DeleteNamespace
//
//	DELETE FROM attribute_namespaces WHERE id = $1
func (q *Queries) DeleteNamespace(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNamespace, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteProviderConfig = `-- name: DeleteProviderConfig :execrows
DELETE FROM provider_config 
WHERE id = $1
`

// DeleteProviderConfig
//
//	DELETE FROM provider_config
//	WHERE id = $1
func (q *Queries) DeleteProviderConfig(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProviderConfig, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteResourceMapping = `-- name: DeleteResourceMapping :execrows
DELETE FROM resource_mappings WHERE id = $1
`

// DeleteResourceMapping
//
//	DELETE FROM resource_mappings WHERE id = $1
func (q *Queries) DeleteResourceMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteResourceMappingGroup = `-- name: DeleteResourceMappingGroup :execrows
DELETE FROM resource_mapping_groups WHERE id = $1
`

// DeleteResourceMappingGroup
//
//	DELETE FROM resource_mapping_groups WHERE id = $1
func (q *Queries) DeleteResourceMappingGroup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMappingGroup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubjectConditionSet = `-- name: DeleteSubjectConditionSet :execrows
DELETE FROM subject_condition_set WHERE id = $1
`

// DeleteSubjectConditionSet
//
//	DELETE FROM subject_condition_set WHERE id = $1
func (q *Queries) DeleteSubjectConditionSet(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectConditionSet, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAttribute = `-- name: GetAttribute :one
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS values,
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )
    ) FILTER (WHERE adkag.attribute_definition_id IS NOT NULL) AS grants,
    fqns.fqn,
    defk.keys as keys
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
    SELECT
        av.id,
        av.value,
        av.active,
        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT('id', vkas.id,'uri', vkas.uri,'name', vkas.name,'public_key', vkas.public_key )) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
        av.attribute_definition_id
    FROM attribute_values av
    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
    GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
LEFT JOIN (
    SELECT
        k.definition_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'id', kask.id,
                'key_id', kask.key_id,
                'key_status', kask.key_status,
                'key_mode', kask.key_mode,
                'key_algorithm', kask.key_algorithm,
                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                    'id', pc.id,
                    'name', pc.provider_name,
                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                ))
            )
        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
    FROM attribute_definition_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
    GROUP BY k.definition_id
) defk ON ad.id = defk.definition_id
WHERE ($1::uuid IS NULL OR ad.id = $1::uuid)
  AND ($2::text IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https?://', '') = REGEXP_REPLACE($2::text, '^https?://', ''))
GROUP BY ad.id, n.name, fqns.fqn, defk.keys
`

type GetAttributeParams struct {
	ID  pgtype.UUID `json:"id"`
	Fqn pgtype.Text `json:"fqn"`
}

type GetAttributeRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
	Values        []byte                  `json:"values"`
	Grants        []byte                  `json:"grants"`
	Fqn           pgtype.Text             `json:"fqn"`
	Keys          []byte                  `json:"keys"`
}

// GetAttribute
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    JSONB_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )
//	    ) FILTER (WHERE adkag.attribute_definition_id IS NOT NULL) AS grants,
//	    fqns.fqn,
//	    defk.keys as keys
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	    SELECT
//	        av.id,
//	        av.value,
//	        av.active,
//	        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT('id', vkas.id,'uri', vkas.uri,'name', vkas.name,'public_key', vkas.public_key )) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
//	        av.attribute_definition_id
//	    FROM attribute_values av
//	    LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
//	    LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
//	    GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_definition_key_access_grants adkag ON adkag.attribute_definition_id = ad.id
//	LEFT JOIN key_access_servers kas ON kas.id = adkag.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	LEFT JOIN (
//	    SELECT
//	        k.definition_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'id', kask.id,
//	                'key_id', kask.key_id,
//	                'key_status', kask.key_status,
//	                'key_mode', kask.key_mode,
//	                'key_algorithm', kask.key_algorithm,
//	                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                    'id', pc.id,
//	                    'name', pc.provider_name,
//	                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                ))
//	            )
//	        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	    FROM attribute_definition_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	    GROUP BY k.definition_id
//	) defk ON ad.id = defk.definition_id
//	WHERE ($1::uuid IS NULL OR ad.id = $1::uuid)
//	  AND ($2::text IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https?://', '') = REGEXP_REPLACE($2::text, '^https?://', ''))
//	GROUP BY ad.id, n.name, fqns.fqn, defk.keys
func (q *Queries) GetAttribute(ctx context.Context, arg GetAttributeParams) (GetAttributeRow, error) {
	row := q.db.QueryRow(ctx, getAttribute, arg.ID, arg.Fqn)
	var i GetAttributeRow
	err := row.Scan(
		&i.ID,
		&i.AttributeName,
		&i.Rule,
		&i.Metadata,
		&i.NamespaceID,
		&i.Active,
		&i.NamespaceName,
		&i.Values,
		&i.Grants,
		&i.Fqn,
		&i.Keys,
	)
	return i, err
}

const getAttributeValue = `-- name: GetAttributeValue :one
SELECT
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn,
    JSONB_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', kas.id,
            'uri', kas.uri,
            'name', kas.name,
            'public_key', kas.public_key
        )
    ) FILTER (WHERE avkag.attribute_value_id IS NOT NULL) AS grants,
    value_keys.keys as keys
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
LEFT JOIN (
    SELECT
        k.value_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'id', kask.id,
                'key_id', kask.key_id,
                'key_status', kask.key_status,
                'key_mode', kask.key_mode,
                'key_algorithm', kask.key_algorithm,
                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                    'id', pc.id,
                    'name', pc.provider_name,
                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                ))
            )
        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
    FROM attribute_value_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
    GROUP BY k.value_id
) value_keys ON av.id = value_keys.value_id   
WHERE ($1::uuid IS NULL OR av.id = $1::uuid)
  AND ($2::text IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https?://', '') = REGEXP_REPLACE($2::text, '^https?://', ''))
GROUP BY av.id, fqns.fqn, value_keys.keys
`

type GetAttributeValueParams struct {
	ID  pgtype.UUID `json:"id"`
	Fqn pgtype.Text `json:"fqn"`
}

type GetAttributeValueRow struct {
	ID                    string      `json:"id"`
	Value                 string      `json:"value"`
	Active                bool        `json:"active"`
	Metadata              []byte      `json:"metadata"`
	AttributeDefinitionID string      `json:"attribute_definition_id"`
	Fqn                   pgtype.Text `json:"fqn"`
	Grants                []byte      `json:"grants"`
	Keys                  []byte      `json:"keys"`
}

// GetAttributeValue
//
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn,
//	    JSONB_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', kas.id,
//	            'uri', kas.uri,
//	            'name', kas.name,
//	            'public_key', kas.public_key
//	        )
//	    ) FILTER (WHERE avkag.attribute_value_id IS NOT NULL) AS grants,
//	    value_keys.keys as keys
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
//	LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//	LEFT JOIN (
//	    SELECT
//	        k.value_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'id', kask.id,
//	                'key_id', kask.key_id,
//	                'key_status', kask.key_status,
//	                'key_mode', kask.key_mode,
//	                'key_algorithm', kask.key_algorithm,
//	                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                    'id', pc.id,
//	                    'name', pc.provider_name,
//	                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                ))
//	            )
//	        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	    FROM attribute_value_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	    GROUP BY k.value_id
//	) value_keys ON av.id = value_keys.value_id
//	WHERE ($1::uuid IS NULL OR av.id = $1::uuid)
//	  AND ($2::text IS NULL OR REGEXP_REPLACE(fqns.fqn, '^https?://', '') = REGEXP_REPLACE($2::text, '^https?://', ''))
//	GROUP BY av.id, fqns.fqn, value_keys.keys
func (q *Queries) GetAttributeValue(ctx context.Context, arg GetAttributeValueParams) (GetAttributeValueRow, error) {
	row := q.db.QueryRow(ctx, getAttributeValue, arg.ID, arg.Fqn)
	var i GetAttributeValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Metadata,
		&i.AttributeDefinitionID,
		&i.Fqn,
		&i.Grants,
		&i.Keys,
	)
	return i, err
}

const getKey = `-- name: GetKey :one
SELECT 
  kask.id,
  kask.key_id,
  kask.key_status,
  kask.key_mode,
  kask.key_algorithm,
  kask.private_key_ctx,
  kask.public_key_ctx,
  kask.provider_config_id,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', kask.metadata -> 'labels',         
      'created_at', kask.created_at,               
      'updated_at', kask.updated_at                
    )
  ) AS metadata,
  pc.provider_name,
  pc.config AS pc_config,
  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata
FROM key_access_server_keys AS kask
LEFT JOIN 
    provider_config as pc ON kask.provider_config_id = pc.id
WHERE ($1::uuid IS NULL OR kask.id = $1::uuid)
  AND ($2::text IS NULL OR kask.key_id = $2::text)
`

type GetKeyParams struct {
	ID    pgtype.UUID `json:"id"`
	KeyID pgtype.Text `json:"key_id"`
}

type GetKeyRow struct {
	ID               string      `json:"id"`
	KeyID            string      `json:"key_id"`
	KeyStatus        int32       `json:"key_status"`
	KeyMode          int32       `json:"key_mode"`
	KeyAlgorithm     int32       `json:"key_algorithm"`
	PrivateKeyCtx    []byte      `json:"private_key_ctx"`
	PublicKeyCtx     []byte      `json:"public_key_ctx"`
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	Metadata         []byte      `json:"metadata"`
	ProviderName     pgtype.Text `json:"provider_name"`
	PcConfig         []byte      `json:"pc_config"`
	PcMetadata       []byte      `json:"pc_metadata"`
}

// GetKey
//
//	SELECT
//	  kask.id,
//	  kask.key_id,
//	  kask.key_status,
//	  kask.key_mode,
//	  kask.key_algorithm,
//	  kask.private_key_ctx,
//	  kask.public_key_ctx,
//	  kask.provider_config_id,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', kask.metadata -> 'labels',
//	      'created_at', kask.created_at,
//	      'updated_at', kask.updated_at
//	    )
//	  ) AS metadata,
//	  pc.provider_name,
//	  pc.config AS pc_config,
//	  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata
//	FROM key_access_server_keys AS kask
//	LEFT JOIN
//	    provider_config as pc ON kask.provider_config_id = pc.id
//	WHERE ($1::uuid IS NULL OR kask.id = $1::uuid)
//	  AND ($2::text IS NULL OR kask.key_id = $2::text)
func (q *Queries) GetKey(ctx context.Context, arg GetKeyParams) (GetKeyRow, error) {
	row := q.db.QueryRow(ctx, getKey, arg.ID, arg.KeyID)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.KeyStatus,
		&i.KeyMode,
		&i.KeyAlgorithm,
		&i.PrivateKeyCtx,
		&i.PublicKeyCtx,
		&i.ProviderConfigID,
		&i.Metadata,
		&i.ProviderName,
		&i.PcConfig,
		&i.PcMetadata,
	)
	return i, err
}

const getKeyAccessServer = `-- name: GetKeyAccessServer :one
SELECT 
    kas.id,
    kas.uri, 
    kas.public_key, 
    kas.name,
    kas.source_type,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'labels', metadata -> 'labels', 
            'created_at', created_at, 
            'updated_at', updated_at
        )
    ) AS metadata
FROM key_access_servers AS kas
WHERE ($1::uuid IS NULL OR kas.id = $1::uuid)
  AND ($2::text IS NULL OR kas.name = $2::text)
  AND ($3::text IS NULL OR kas.uri = $3::text)
`

type GetKeyAccessServerParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
	Uri  pgtype.Text `json:"uri"`
}

type GetKeyAccessServerRow struct {
	ID         string      `json:"id"`
	Uri        string      `json:"uri"`
	PublicKey  []byte      `json:"public_key"`
	Name       pgtype.Text `json:"name"`
	SourceType pgtype.Int4 `json:"source_type"`
	Metadata   []byte      `json:"metadata"`
}

// GetKeyAccessServer
//
//	SELECT
//	    kas.id,
//	    kas.uri,
//	    kas.public_key,
//	    kas.name,
//	    kas.source_type,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'labels', metadata -> 'labels',
//	            'created_at', created_at,
//	            'updated_at', updated_at
//	        )
//	    ) AS metadata
//	FROM key_access_servers AS kas
//	WHERE ($1::uuid IS NULL OR kas.id = $1::uuid)
//	  AND ($2::text IS NULL OR kas.name = $2::text)
//	  AND ($3::text IS NULL OR kas.uri = $3::text)
func (q *Queries) GetKeyAccessServer(ctx context.Context, arg GetKeyAccessServerParams) (GetKeyAccessServerRow, error) {
	row := q.db.QueryRow(ctx, getKeyAccessServer, arg.ID, arg.Name, arg.Uri)
	var i GetKeyAccessServerRow
	err := row.Scan(
		&i.ID,
		&i.Uri,
		&i.PublicKey,
		&i.Name,
		&i.SourceType,
		&i.Metadata,
	)
	return i, err
}

const getNamespace = `-- name: GetNamespace :one
SELECT
    ns.id,
    ns.name,
    ns.active,
    fqns.fqn,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
        'id', kas.id,
        'uri', kas.uri,
        'name', kas.name,
        'public_key', kas.public_key
    )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL) as grants,
    nmp_keys.keys as keys
FROM attribute_namespaces ns
LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
LEFT JOIN (
    SELECT
        k.namespace_id,
        JSONB_AGG(
            DISTINCT JSONB_BUILD_OBJECT(
                'id', kask.id,
                'key_id', kask.key_id,
                'key_status', kask.key_status,
                'key_mode', kask.key_mode,
                'key_algorithm', kask.key_algorithm,
                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                    'id', pc.id,
                    'name', pc.provider_name,
                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                ))
            )
        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
    FROM attribute_namespace_public_key_map k
    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
    GROUP BY k.namespace_id
) nmp_keys ON ns.id = nmp_keys.namespace_id
WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL 
  AND ($1::uuid IS NULL OR ns.id = $1::uuid)
  AND ($2::text IS NULL OR ns.name = REGEXP_REPLACE($2::text, '^https?://', ''))
GROUP BY ns.id, fqns.fqn, nmp_keys.keys
`

type GetNamespaceParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type GetNamespaceRow struct {
	ID       string      `json:"id"`
	Name     string      `json:"name"`
	Active   bool        `json:"active"`
	Fqn      pgtype.Text `json:"fqn"`
	Metadata []byte      `json:"metadata"`
	Grants   []byte      `json:"grants"`
	Keys     []byte      `json:"keys"`
}

// GetNamespace
//
//	SELECT
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    fqns.fqn,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    JSONB_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	        'id', kas.id,
//	        'uri', kas.uri,
//	        'name', kas.name,
//	        'public_key', kas.public_key
//	    )) FILTER (WHERE kas_ns_grants.namespace_id IS NOT NULL) as grants,
//	    nmp_keys.keys as keys
//	FROM attribute_namespaces ns
//	LEFT JOIN attribute_namespace_key_access_grants kas_ns_grants ON kas_ns_grants.namespace_id = ns.id
//	LEFT JOIN key_access_servers kas ON kas.id = kas_ns_grants.key_access_server_id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = ns.id
//	LEFT JOIN (
//	    SELECT
//	        k.namespace_id,
//	        JSONB_AGG(
//	            DISTINCT JSONB_BUILD_OBJECT(
//	                'id', kask.id,
//	                'key_id', kask.key_id,
//	                'key_status', kask.key_status,
//	                'key_mode', kask.key_mode,
//	                'key_algorithm', kask.key_algorithm,
//	                'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                    'id', pc.id,
//	                    'name', pc.provider_name,
//	                    'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                ))
//	            )
//	        ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	    FROM attribute_namespace_public_key_map k
//	    INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	    LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	    GROUP BY k.namespace_id
//	) nmp_keys ON ns.id = nmp_keys.namespace_id
//	WHERE fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	  AND ($1::uuid IS NULL OR ns.id = $1::uuid)
//	  AND ($2::text IS NULL OR ns.name = REGEXP_REPLACE($2::text, '^https?://', ''))
//	GROUP BY ns.id, fqns.fqn, nmp_keys.keys
func (q *Queries) GetNamespace(ctx context.Context, arg GetNamespaceParams) (GetNamespaceRow, error) {
	row := q.db.QueryRow(ctx, getNamespace, arg.ID, arg.Name)
	var i GetNamespaceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Active,
		&i.Fqn,
		&i.Metadata,
		&i.Grants,
		&i.Keys,
	)
	return i, err
}

const getProviderConfig = `-- name: GetProviderConfig :one
SELECT 
    pc.id,
    pc.provider_name,
    pc.config,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata
FROM provider_config AS pc
WHERE ($1::uuid IS NULL OR pc.id = $1::uuid)
  AND ($2::text IS NULL OR pc.provider_name = $2::text)
`

type GetProviderConfigParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type GetProviderConfigRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
}

// GetProviderConfig
//
//	SELECT
//	    pc.id,
//	    pc.provider_name,
//	    pc.config,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata
//	FROM provider_config AS pc
//	WHERE ($1::uuid IS NULL OR pc.id = $1::uuid)
//	  AND ($2::text IS NULL OR pc.provider_name = $2::text)
func (q *Queries) GetProviderConfig(ctx context.Context, arg GetProviderConfigParams) (GetProviderConfigRow, error) {
	row := q.db.QueryRow(ctx, getProviderConfig, arg.ID, arg.Name)
	var i GetProviderConfigRow
	err := row.Scan(
		&i.ID,
		&i.ProviderName,
		&i.Config,
		&i.Metadata,
	)
	return i, err
}

const getResourceMapping = `-- name: GetResourceMapping :one
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
FROM resource_mappings m 
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE m.id = $1
GROUP BY av.id, m.id, fqns.fqn
`

type GetResourceMappingRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	GroupID        string   `json:"group_id"`
}

// GetResourceMapping
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE m.id = $1
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) GetResourceMapping(ctx context.Context, id string) (GetResourceMappingRow, error) {
	row := q.db.QueryRow(ctx, getResourceMapping, id)
	var i GetResourceMappingRow
	err := row.Scan(
		&i.ID,
		&i.AttributeValue,
		&i.Terms,
		&i.Metadata,
		&i.GroupID,
	)
	return i, err
}

const getResourceMappingGroup = `-- name: GetResourceMappingGroup :one
SELECT id, namespace_id, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM resource_mapping_groups
WHERE id = $1
`

type GetResourceMappingGroupRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// GetResourceMappingGroup
//
//	SELECT id, namespace_id, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM resource_mapping_groups
//	WHERE id = $1
func (q *Queries) GetResourceMappingGroup(ctx context.Context, id string) (GetResourceMappingGroupRow, error) {
	row := q.db.QueryRow(ctx, getResourceMappingGroup, id)
	var i GetResourceMappingGroupRow
	err := row.Scan(
		&i.ID,
		&i.NamespaceID,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const getSubjectConditionSet = `-- name: GetSubjectConditionSet :one
SELECT
    id,
    condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM subject_condition_set
WHERE id = $1
`

type GetSubjectConditionSetRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// GetSubjectConditionSet
//
//	SELECT
//	    id,
//	    condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM subject_condition_set
//	WHERE id = $1
func (q *Queries) GetSubjectConditionSet(ctx context.Context, id string) (GetSubjectConditionSetRow, error) {
	row := q.db.QueryRow(ctx, getSubjectConditionSet, id)
	var i GetSubjectConditionSetRow
	err := row.Scan(&i.ID, &i.Condition, &i.Metadata)
	return i, err
}

const isUpdateKeySafe = `-- name: IsUpdateKeySafe :one
WITH keyToUpdate AS (
    SELECT 
        kask.key_access_server_id AS kas_id,
        kask.key_algorithm
    FROM key_access_server_keys AS kask
    WHERE kask.id = $1
)
SELECT EXISTS (
    SELECT 1
    FROM key_access_server_keys AS kask
    INNER JOIN keyToUpdate ON kask.key_access_server_id = keyToUpdate.kas_id
    WHERE kask.key_access_server_id = keyToUpdate.kas_id 
    AND kask.key_status = $2
    AND kask.key_algorithm = keyToUpdate.key_algorithm
)
`

type IsUpdateKeySafeParams struct {
	ID        string `json:"id"`
	KeyStatus int32  `json:"key_status"`
}

// IsUpdateKeySafe
//
//	WITH keyToUpdate AS (
//	    SELECT
//	        kask.key_access_server_id AS kas_id,
//	        kask.key_algorithm
//	    FROM key_access_server_keys AS kask
//	    WHERE kask.id = $1
//	)
//	SELECT EXISTS (
//	    SELECT 1
//	    FROM key_access_server_keys AS kask
//	    INNER JOIN keyToUpdate ON kask.key_access_server_id = keyToUpdate.kas_id
//	    WHERE kask.key_access_server_id = keyToUpdate.kas_id
//	    AND kask.key_status = $2
//	    AND kask.key_algorithm = keyToUpdate.key_algorithm
//	)
func (q *Queries) IsUpdateKeySafe(ctx context.Context, arg IsUpdateKeySafeParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUpdateKeySafe, arg.ID, arg.KeyStatus)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAttributeValues = `-- name: ListAttributeValues :many

WITH counted AS (
    SELECT COUNT(av.id) AS total
    FROM attribute_values av
)
SELECT
    av.id,
    av.value,
    av.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
    av.attribute_definition_id,
    fqns.fqn,
    counted.total
FROM attribute_values av
CROSS JOIN counted
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
WHERE (
    ($1::BOOLEAN IS NULL OR av.active = $1) AND
    (NULLIF($2, '') IS NULL OR av.attribute_definition_id = $2::UUID) 
)
LIMIT $4 
OFFSET $3
`

type ListAttributeValuesParams struct {
	Active                pgtype.Bool `json:"active"`
	AttributeDefinitionID interface{} `json:"attribute_definition_id"`
	Offset                int32       `json:"offset_"`
	Limit                 int32       `json:"limit_"`
}

type ListAttributeValuesRow struct {
	ID                    string      `json:"id"`
	Value                 string      `json:"value"`
	Active                bool        `json:"active"`
	Metadata              []byte      `json:"metadata"`
	AttributeDefinitionID string      `json:"attribute_definition_id"`
	Fqn                   pgtype.Text `json:"fqn"`
	Total                 int64       `json:"total"`
}

// --------------------------------------------------------------
// ATTRIBUTE VALUES
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(av.id) AS total
//	    FROM attribute_values av
//	)
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', av.metadata -> 'labels', 'created_at', av.created_at, 'updated_at', av.updated_at)) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn,
//	    counted.total
//	FROM attribute_values av
//	CROSS JOIN counted
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	WHERE (
//	    ($1::BOOLEAN IS NULL OR av.active = $1) AND
//	    (NULLIF($2, '') IS NULL OR av.attribute_definition_id = $2::UUID)
//	)
//	LIMIT $4
//	OFFSET $3
func (q *Queries) ListAttributeValues(ctx context.Context, arg ListAttributeValuesParams) ([]ListAttributeValuesRow, error) {
	rows, err := q.db.Query(ctx, listAttributeValues,
		arg.Active,
		arg.AttributeDefinitionID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributeValuesRow
	for rows.Next() {
		var i ListAttributeValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Metadata,
			&i.AttributeDefinitionID,
			&i.Fqn,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesDetail = `-- name: ListAttributesDetail :many

WITH counted AS (
    SELECT COUNT(ad.id) AS total
    FROM attribute_definitions ad
)
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', avt.id,
            'value', avt.value,
            'active', avt.active,
            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
    ) AS values,
    fqns.fqn,
    counted.total
FROM attribute_definitions ad
CROSS JOIN counted
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN (
  SELECT
    av.id,
    av.value,
    av.active,
    JSON_AGG(
        DISTINCT JSONB_BUILD_OBJECT(
            'id', vkas.id,
            'uri', vkas.uri,
            'name', vkas.name,
            'public_key', vkas.public_key
        )
    ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
    av.attribute_definition_id
  FROM attribute_values av
  LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
  LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
  GROUP BY av.id
) avt ON avt.attribute_definition_id = ad.id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE
    ($1::BOOLEAN IS NULL OR ad.active = $1) AND
    (NULLIF($2, '') IS NULL OR ad.namespace_id = $2::uuid) AND 
    (NULLIF($3, '') IS NULL OR n.name = $3) 
GROUP BY ad.id, n.name, fqns.fqn, counted.total
LIMIT $5 
OFFSET $4
`

type ListAttributesDetailParams struct {
	Active        pgtype.Bool `json:"active"`
	NamespaceID   interface{} `json:"namespace_id"`
	NamespaceName interface{} `json:"namespace_name"`
	Offset        int32       `json:"offset_"`
	Limit         int32       `json:"limit_"`
}

type ListAttributesDetailRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
	Values        []byte                  `json:"values"`
	Fqn           pgtype.Text             `json:"fqn"`
	Total         int64                   `json:"total"`
}

// --------------------------------------------------------------
// ATTRIBUTES
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(ad.id) AS total
//	    FROM attribute_definitions ad
//	)
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', avt.id,
//	            'value', avt.value,
//	            'active', avt.active,
//	            'fqn', CONCAT(fqns.fqn, '/value/', avt.value)
//	        ) ORDER BY ARRAY_POSITION(ad.values_order, avt.id)
//	    ) AS values,
//	    fqns.fqn,
//	    counted.total
//	FROM attribute_definitions ad
//	CROSS JOIN counted
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN (
//	  SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    JSON_AGG(
//	        DISTINCT JSONB_BUILD_OBJECT(
//	            'id', vkas.id,
//	            'uri', vkas.uri,
//	            'name', vkas.name,
//	            'public_key', vkas.public_key
//	        )
//	    ) FILTER (WHERE vkas.id IS NOT NULL AND vkas.uri IS NOT NULL AND vkas.public_key IS NOT NULL) AS val_grants_arr,
//	    av.attribute_definition_id
//	  FROM attribute_values av
//	  LEFT JOIN attribute_value_key_access_grants avg ON av.id = avg.attribute_value_id
//	  LEFT JOIN key_access_servers vkas ON avg.key_access_server_id = vkas.id
//	  GROUP BY av.id
//	) avt ON avt.attribute_definition_id = ad.id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE
//	    ($1::BOOLEAN IS NULL OR ad.active = $1) AND
//	    (NULLIF($2, '') IS NULL OR ad.namespace_id = $2::uuid) AND
//	    (NULLIF($3, '') IS NULL OR n.name = $3)
//	GROUP BY ad.id, n.name, fqns.fqn, counted.total
//	LIMIT $5
//	OFFSET $4
func (q *Queries) ListAttributesDetail(ctx context.Context, arg ListAttributesDetailParams) ([]ListAttributesDetailRow, error) {
	rows, err := q.db.Query(ctx, listAttributesDetail,
		arg.Active,
		arg.NamespaceID,
		arg.NamespaceName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesDetailRow
	for rows.Next() {
		var i ListAttributesDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Values,
			&i.Fqn,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesSummary = `-- name: ListAttributesSummary :many
WITH counted AS (
    SELECT COUNT(ad.id) AS total FROM attribute_definitions ad
)
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    counted.total
FROM attribute_definitions ad
CROSS JOIN counted
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
WHERE ad.namespace_id = $1
GROUP BY ad.id, n.name, counted.total
LIMIT $3 
OFFSET $2
`

type ListAttributesSummaryParams struct {
	NamespaceID string `json:"namespace_id"`
	Offset      int32  `json:"offset_"`
	Limit       int32  `json:"limit_"`
}

type ListAttributesSummaryRow struct {
	ID            string                  `json:"id"`
	AttributeName string                  `json:"attribute_name"`
	Rule          AttributeDefinitionRule `json:"rule"`
	Metadata      []byte                  `json:"metadata"`
	NamespaceID   string                  `json:"namespace_id"`
	Active        bool                    `json:"active"`
	NamespaceName pgtype.Text             `json:"namespace_name"`
	Total         int64                   `json:"total"`
}

// ListAttributesSummary
//
//	WITH counted AS (
//	    SELECT COUNT(ad.id) AS total FROM attribute_definitions ad
//	)
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ad.metadata -> 'labels', 'created_at', ad.created_at, 'updated_at', ad.updated_at)) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    counted.total
//	FROM attribute_definitions ad
//	CROSS JOIN counted
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	WHERE ad.namespace_id = $1
//	GROUP BY ad.id, n.name, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListAttributesSummary(ctx context.Context, arg ListAttributesSummaryParams) ([]ListAttributesSummaryRow, error) {
	rows, err := q.db.Query(ctx, listAttributesSummary, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttributesSummaryRow
	for rows.Next() {
		var i ListAttributesSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyAccessServerGrants = `-- name: ListKeyAccessServerGrants :many

WITH listed AS (
    SELECT
        COUNT(*) OVER () AS total,
        kas.id AS kas_id,
        kas.uri AS kas_uri,
        kas.name AS kas_name,
        kas.public_key AS kas_public_key,
        JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
            'labels', kas.metadata -> 'labels',
            'created_at', kas.created_at,
            'updated_at', kas.updated_at
        )) AS kas_metadata,
        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', attrkag.attribute_definition_id,
            'fqn', fqns_on_attr.fqn
        )) FILTER (WHERE attrkag.attribute_definition_id IS NOT NULL) AS attributes_grants,
        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', valkag.attribute_value_id,
            'fqn', fqns_on_vals.fqn
        )) FILTER (WHERE valkag.attribute_value_id IS NOT NULL) AS values_grants,
        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
            'id', nskag.namespace_id,
            'fqn', fqns_on_ns.fqn
        )) FILTER (WHERE nskag.namespace_id IS NOT NULL) AS namespace_grants
    FROM key_access_servers AS kas
    LEFT JOIN
        attribute_definition_key_access_grants AS attrkag
        ON kas.id = attrkag.key_access_server_id
    LEFT JOIN
        attribute_fqns AS fqns_on_attr
        ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id
            AND fqns_on_attr.value_id IS NULL
    LEFT JOIN
        attribute_value_key_access_grants AS valkag
        ON kas.id = valkag.key_access_server_id
    LEFT JOIN 
        attribute_fqns AS fqns_on_vals
        ON valkag.attribute_value_id = fqns_on_vals.value_id
    LEFT JOIN
        attribute_namespace_key_access_grants AS nskag
        ON kas.id = nskag.key_access_server_id
    LEFT JOIN
        attribute_fqns AS fqns_on_ns
            ON nskag.namespace_id = fqns_on_ns.namespace_id
        AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
    WHERE (NULLIF($3, '') IS NULL OR kas.id = $3::uuid) 
        AND (NULLIF($4, '') IS NULL OR kas.uri = $4::varchar) 
        AND (NULLIF($5, '') IS NULL OR kas.name = $5::varchar) 
    GROUP BY 
        kas.id
)
SELECT 
    listed.kas_id,
    listed.kas_uri,
    listed.kas_name,
    listed.kas_public_key,
    listed.kas_metadata,
    listed.attributes_grants,
    listed.values_grants,
    listed.namespace_grants,
    listed.total  
FROM listed
LIMIT $2 
OFFSET $1
`

type ListKeyAccessServerGrantsParams struct {
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
	KasID   interface{} `json:"kas_id"`
	KasUri  interface{} `json:"kas_uri"`
	KasName interface{} `json:"kas_name"`
}

type ListKeyAccessServerGrantsRow struct {
	KasID            string      `json:"kas_id"`
	KasUri           string      `json:"kas_uri"`
	KasName          pgtype.Text `json:"kas_name"`
	KasPublicKey     []byte      `json:"kas_public_key"`
	KasMetadata      []byte      `json:"kas_metadata"`
	AttributesGrants []byte      `json:"attributes_grants"`
	ValuesGrants     []byte      `json:"values_grants"`
	NamespaceGrants  []byte      `json:"namespace_grants"`
	Total            int64       `json:"total"`
}

// --------------------------------------------------------------
// KEY ACCESS SERVERS
// --------------------------------------------------------------
//
//	WITH listed AS (
//	    SELECT
//	        COUNT(*) OVER () AS total,
//	        kas.id AS kas_id,
//	        kas.uri AS kas_uri,
//	        kas.name AS kas_name,
//	        kas.public_key AS kas_public_key,
//	        JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	            'labels', kas.metadata -> 'labels',
//	            'created_at', kas.created_at,
//	            'updated_at', kas.updated_at
//	        )) AS kas_metadata,
//	        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	            'id', attrkag.attribute_definition_id,
//	            'fqn', fqns_on_attr.fqn
//	        )) FILTER (WHERE attrkag.attribute_definition_id IS NOT NULL) AS attributes_grants,
//	        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	            'id', valkag.attribute_value_id,
//	            'fqn', fqns_on_vals.fqn
//	        )) FILTER (WHERE valkag.attribute_value_id IS NOT NULL) AS values_grants,
//	        JSON_AGG(DISTINCT JSONB_BUILD_OBJECT(
//	            'id', nskag.namespace_id,
//	            'fqn', fqns_on_ns.fqn
//	        )) FILTER (WHERE nskag.namespace_id IS NOT NULL) AS namespace_grants
//	    FROM key_access_servers AS kas
//	    LEFT JOIN
//	        attribute_definition_key_access_grants AS attrkag
//	        ON kas.id = attrkag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_attr
//	        ON attrkag.attribute_definition_id = fqns_on_attr.attribute_id
//	            AND fqns_on_attr.value_id IS NULL
//	    LEFT JOIN
//	        attribute_value_key_access_grants AS valkag
//	        ON kas.id = valkag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_vals
//	        ON valkag.attribute_value_id = fqns_on_vals.value_id
//	    LEFT JOIN
//	        attribute_namespace_key_access_grants AS nskag
//	        ON kas.id = nskag.key_access_server_id
//	    LEFT JOIN
//	        attribute_fqns AS fqns_on_ns
//	            ON nskag.namespace_id = fqns_on_ns.namespace_id
//	        AND fqns_on_ns.attribute_id IS NULL AND fqns_on_ns.value_id IS NULL
//	    WHERE (NULLIF($3, '') IS NULL OR kas.id = $3::uuid)
//	        AND (NULLIF($4, '') IS NULL OR kas.uri = $4::varchar)
//	        AND (NULLIF($5, '') IS NULL OR kas.name = $5::varchar)
//	    GROUP BY
//	        kas.id
//	)
//	SELECT
//	    listed.kas_id,
//	    listed.kas_uri,
//	    listed.kas_name,
//	    listed.kas_public_key,
//	    listed.kas_metadata,
//	    listed.attributes_grants,
//	    listed.values_grants,
//	    listed.namespace_grants,
//	    listed.total
//	FROM listed
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListKeyAccessServerGrants(ctx context.Context, arg ListKeyAccessServerGrantsParams) ([]ListKeyAccessServerGrantsRow, error) {
	rows, err := q.db.Query(ctx, listKeyAccessServerGrants,
		arg.Offset,
		arg.Limit,
		arg.KasID,
		arg.KasUri,
		arg.KasName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServerGrantsRow
	for rows.Next() {
		var i ListKeyAccessServerGrantsRow
		if err := rows.Scan(
			&i.KasID,
			&i.KasUri,
			&i.KasName,
			&i.KasPublicKey,
			&i.KasMetadata,
			&i.AttributesGrants,
			&i.ValuesGrants,
			&i.NamespaceGrants,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyAccessServers = `-- name: ListKeyAccessServers :many
WITH counted AS (
    SELECT COUNT(kas.id) AS total
    FROM key_access_servers AS kas
)
SELECT kas.id,
    kas.uri,
    kas.public_key,
    kas.name AS kas_name,
    kas.source_type,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kas.metadata -> 'labels', 'created_at', kas.created_at, 'updated_at', kas.updated_at)) AS metadata,
    counted.total
FROM key_access_servers AS kas
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type ListKeyAccessServersParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListKeyAccessServersRow struct {
	ID         string      `json:"id"`
	Uri        string      `json:"uri"`
	PublicKey  []byte      `json:"public_key"`
	KasName    pgtype.Text `json:"kas_name"`
	SourceType pgtype.Int4 `json:"source_type"`
	Metadata   []byte      `json:"metadata"`
	Total      int64       `json:"total"`
}

// ListKeyAccessServers
//
//	WITH counted AS (
//	    SELECT COUNT(kas.id) AS total
//	    FROM key_access_servers AS kas
//	)
//	SELECT kas.id,
//	    kas.uri,
//	    kas.public_key,
//	    kas.name AS kas_name,
//	    kas.source_type,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kas.metadata -> 'labels', 'created_at', kas.created_at, 'updated_at', kas.updated_at)) AS metadata,
//	    counted.total
//	FROM key_access_servers AS kas
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListKeyAccessServers(ctx context.Context, arg ListKeyAccessServersParams) ([]ListKeyAccessServersRow, error) {
	rows, err := q.db.Query(ctx, listKeyAccessServers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyAccessServersRow
	for rows.Next() {
		var i ListKeyAccessServersRow
		if err := rows.Scan(
			&i.ID,
			&i.Uri,
			&i.PublicKey,
			&i.KasName,
			&i.SourceType,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeys = `-- name: ListKeys :many
WITH listed AS (
    SELECT
        kas.id AS kas_id
    FROM key_access_servers AS kas
    WHERE ($4::uuid IS NULL OR kas.id = $4::uuid)
            AND ($5::text IS NULL OR kas.name = $5::text)
            AND ($6::text IS NULL OR kas.uri = $6::text)
)
SELECT 
  COUNT(*) OVER () AS total,
  kask.id,
  kask.key_id,
  kask.key_status,
  kask.key_mode,
  kask.key_algorithm,
  kask.private_key_ctx,
  kask.public_key_ctx,
  kask.provider_config_id,
  JSON_STRIP_NULLS(
    JSON_BUILD_OBJECT(
      'labels', kask.metadata -> 'labels',         
      'created_at', kask.created_at,               
      'updated_at', kask.updated_at                
    )
  ) AS metadata,
  pc.provider_name,
  pc.config AS provider_config,
  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata
FROM key_access_server_keys AS kask
INNER JOIN
    listed ON kask.key_access_server_id = listed.kas_id
LEFT JOIN 
    provider_config as pc ON kask.provider_config_id = pc.id
WHERE
    ($1::integer IS NULL OR kask.key_algorithm = $1::integer)
LIMIT $3 
OFFSET $2
`

type ListKeysParams struct {
	KeyAlgorithm pgtype.Int4 `json:"key_algorithm"`
	Offset       int32       `json:"offset_"`
	Limit        int32       `json:"limit_"`
	KasID        pgtype.UUID `json:"kas_id"`
	KasName      pgtype.Text `json:"kas_name"`
	KasUri       pgtype.Text `json:"kas_uri"`
}

type ListKeysRow struct {
	Total            int64       `json:"total"`
	ID               string      `json:"id"`
	KeyID            string      `json:"key_id"`
	KeyStatus        int32       `json:"key_status"`
	KeyMode          int32       `json:"key_mode"`
	KeyAlgorithm     int32       `json:"key_algorithm"`
	PrivateKeyCtx    []byte      `json:"private_key_ctx"`
	PublicKeyCtx     []byte      `json:"public_key_ctx"`
	ProviderConfigID pgtype.UUID `json:"provider_config_id"`
	Metadata         []byte      `json:"metadata"`
	ProviderName     pgtype.Text `json:"provider_name"`
	ProviderConfig   []byte      `json:"provider_config"`
	PcMetadata       []byte      `json:"pc_metadata"`
}

// ListKeys
//
//	WITH listed AS (
//	    SELECT
//	        kas.id AS kas_id
//	    FROM key_access_servers AS kas
//	    WHERE ($4::uuid IS NULL OR kas.id = $4::uuid)
//	            AND ($5::text IS NULL OR kas.name = $5::text)
//	            AND ($6::text IS NULL OR kas.uri = $6::text)
//	)
//	SELECT
//	  COUNT(*) OVER () AS total,
//	  kask.id,
//	  kask.key_id,
//	  kask.key_status,
//	  kask.key_mode,
//	  kask.key_algorithm,
//	  kask.private_key_ctx,
//	  kask.public_key_ctx,
//	  kask.provider_config_id,
//	  JSON_STRIP_NULLS(
//	    JSON_BUILD_OBJECT(
//	      'labels', kask.metadata -> 'labels',
//	      'created_at', kask.created_at,
//	      'updated_at', kask.updated_at
//	    )
//	  ) AS metadata,
//	  pc.provider_name,
//	  pc.config AS provider_config,
//	  JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS pc_metadata
//	FROM key_access_server_keys AS kask
//	INNER JOIN
//	    listed ON kask.key_access_server_id = listed.kas_id
//	LEFT JOIN
//	    provider_config as pc ON kask.provider_config_id = pc.id
//	WHERE
//	    ($1::integer IS NULL OR kask.key_algorithm = $1::integer)
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListKeys(ctx context.Context, arg ListKeysParams) ([]ListKeysRow, error) {
	rows, err := q.db.Query(ctx, listKeys,
		arg.KeyAlgorithm,
		arg.Offset,
		arg.Limit,
		arg.KasID,
		arg.KasName,
		arg.KasUri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeysRow
	for rows.Next() {
		var i ListKeysRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.KeyID,
			&i.KeyStatus,
			&i.KeyMode,
			&i.KeyAlgorithm,
			&i.PrivateKeyCtx,
			&i.PublicKeyCtx,
			&i.ProviderConfigID,
			&i.Metadata,
			&i.ProviderName,
			&i.ProviderConfig,
			&i.PcMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNamespaces = `-- name: ListNamespaces :many

WITH counted AS (
    SELECT COUNT(id) AS total FROM attribute_namespaces
)
SELECT
    ns.id,
    ns.name,
    ns.active,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
    fqns.fqn,
    counted.total
FROM attribute_namespaces ns
CROSS JOIN counted
LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
WHERE ($1::BOOLEAN IS NULL OR ns.active = $1::BOOLEAN)
LIMIT $3 
OFFSET $2
`

type ListNamespacesParams struct {
	Active pgtype.Bool `json:"active"`
	Offset int32       `json:"offset_"`
	Limit  int32       `json:"limit_"`
}

type ListNamespacesRow struct {
	ID       string      `json:"id"`
	Name     string      `json:"name"`
	Active   bool        `json:"active"`
	Metadata []byte      `json:"metadata"`
	Fqn      pgtype.Text `json:"fqn"`
	Total    int64       `json:"total"`
}

// --------------------------------------------------------------
// NAMESPACES
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total FROM attribute_namespaces
//	)
//	SELECT
//	    ns.id,
//	    ns.name,
//	    ns.active,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', ns.metadata -> 'labels', 'created_at', ns.created_at, 'updated_at', ns.updated_at)) as metadata,
//	    fqns.fqn,
//	    counted.total
//	FROM attribute_namespaces ns
//	CROSS JOIN counted
//	LEFT JOIN attribute_fqns fqns ON ns.id = fqns.namespace_id AND fqns.attribute_id IS NULL
//	WHERE ($1::BOOLEAN IS NULL OR ns.active = $1::BOOLEAN)
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListNamespaces(ctx context.Context, arg ListNamespacesParams) ([]ListNamespacesRow, error) {
	rows, err := q.db.Query(ctx, listNamespaces, arg.Active, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNamespacesRow
	for rows.Next() {
		var i ListNamespacesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.Metadata,
			&i.Fqn,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProviderConfigs = `-- name: ListProviderConfigs :many
WITH counted AS (
    SELECT COUNT(pc.id) AS total 
    FROM provider_config pc
)
SELECT 
    pc.id,
    pc.provider_name,
    pc.config,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata,
    counted.total
FROM provider_config AS pc
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type ListProviderConfigsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListProviderConfigsRow struct {
	ID           string `json:"id"`
	ProviderName string `json:"provider_name"`
	Config       []byte `json:"config"`
	Metadata     []byte `json:"metadata"`
	Total        int64  `json:"total"`
}

// ListProviderConfigs
//
//	WITH counted AS (
//	    SELECT COUNT(pc.id) AS total
//	    FROM provider_config pc
//	)
//	SELECT
//	    pc.id,
//	    pc.provider_name,
//	    pc.config,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at)) AS metadata,
//	    counted.total
//	FROM provider_config AS pc
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListProviderConfigs(ctx context.Context, arg ListProviderConfigsParams) ([]ListProviderConfigsRow, error) {
	rows, err := q.db.Query(ctx, listProviderConfigs, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProviderConfigsRow
	for rows.Next() {
		var i ListProviderConfigsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderName,
			&i.Config,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingGroups = `-- name: ListResourceMappingGroups :many

WITH counted AS (
    SELECT COUNT(rmg.id) AS total
    FROM resource_mapping_groups rmg
)
SELECT rmg.id,
    rmg.namespace_id,
    rmg.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', rmg.metadata -> 'labels', 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
    counted.total
FROM resource_mapping_groups rmg
CROSS JOIN counted
WHERE (NULLIF($1, '') IS NULL OR rmg.namespace_id = $1::uuid) 
LIMIT $3 
OFFSET $2
`

type ListResourceMappingGroupsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type ListResourceMappingGroupsRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
	Total       int64  `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING GROUPS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(rmg.id) AS total
//	    FROM resource_mapping_groups rmg
//	)
//	SELECT rmg.id,
//	    rmg.namespace_id,
//	    rmg.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', rmg.metadata -> 'labels', 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
//	    counted.total
//	FROM resource_mapping_groups rmg
//	CROSS JOIN counted
//	WHERE (NULLIF($1, '') IS NULL OR rmg.namespace_id = $1::uuid)
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListResourceMappingGroups(ctx context.Context, arg ListResourceMappingGroupsParams) ([]ListResourceMappingGroupsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingGroups, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingGroupsRow
	for rows.Next() {
		var i ListResourceMappingGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappings = `-- name: ListResourceMappings :many

WITH counted AS (
    SELECT COUNT(rm.id) AS total
    FROM resource_mappings rm
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id::TEXT, '')::TEXT as group_id,
    counted.total
FROM resource_mappings m 
CROSS JOIN counted
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID) 
GROUP BY av.id, m.id, fqns.fqn, counted.total
LIMIT $3 
OFFSET $2
`

type ListResourceMappingsParams struct {
	GroupID interface{} `json:"group_id"`
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
}

type ListResourceMappingsRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	GroupID        string   `json:"group_id"`
	Total          int64    `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(rm.id) AS total
//	    FROM resource_mappings rm
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id::TEXT, '')::TEXT as group_id,
//	    counted.total
//	FROM resource_mappings m
//	CROSS JOIN counted
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID)
//	GROUP BY av.id, m.id, fqns.fqn, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) ListResourceMappings(ctx context.Context, arg ListResourceMappingsParams) ([]ListResourceMappingsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappings, arg.GroupID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsRow
	for rows.Next() {
		var i ListResourceMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.GroupID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingsByFullyQualifiedGroup = `-- name: ListResourceMappingsByFullyQualifiedGroup :many
WITH groups_cte AS (
    SELECT
        g.id,
        JSON_BUILD_OBJECT(
            'id', g.id,
            'namespace_id', g.namespace_id,
            'name', g.name,
            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                'labels', g.metadata -> 'labels',
                'created_at', g.created_at,
                'updated_at', g.updated_at
            ))
        ) as group
    FROM resource_mapping_groups g
    JOIN attribute_namespaces ns on g.namespace_id = ns.id
    WHERE ns.name = $1 AND g.name = $2 
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    g.group
FROM resource_mappings m
JOIN groups_cte g ON m.group_id = g.id
JOIN attribute_values av on m.attribute_value_id = av.id
JOIN attribute_fqns fqns on av.id = fqns.value_id
`

type ListResourceMappingsByFullyQualifiedGroupParams struct {
	NamespaceName string `json:"namespace_name"`
	GroupName     string `json:"group_name"`
}

type ListResourceMappingsByFullyQualifiedGroupRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	Group          []byte   `json:"group"`
}

// CTE to cache the group JSON build since it will be the same for all mappings of the group
//
//	WITH groups_cte AS (
//	    SELECT
//	        g.id,
//	        JSON_BUILD_OBJECT(
//	            'id', g.id,
//	            'namespace_id', g.namespace_id,
//	            'name', g.name,
//	            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                'labels', g.metadata -> 'labels',
//	                'created_at', g.created_at,
//	                'updated_at', g.updated_at
//	            ))
//	        ) as group
//	    FROM resource_mapping_groups g
//	    JOIN attribute_namespaces ns on g.namespace_id = ns.id
//	    WHERE ns.name = $1 AND g.name = $2
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    g.group
//	FROM resource_mappings m
//	JOIN groups_cte g ON m.group_id = g.id
//	JOIN attribute_values av on m.attribute_value_id = av.id
//	JOIN attribute_fqns fqns on av.id = fqns.value_id
func (q *Queries) ListResourceMappingsByFullyQualifiedGroup(ctx context.Context, arg ListResourceMappingsByFullyQualifiedGroupParams) ([]ListResourceMappingsByFullyQualifiedGroupRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingsByFullyQualifiedGroup, arg.NamespaceName, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceMappingsByFullyQualifiedGroupRow
	for rows.Next() {
		var i ListResourceMappingsByFullyQualifiedGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectConditionSets = `-- name: ListSubjectConditionSets :many

WITH counted AS (
    SELECT COUNT(scs.id) AS total
    FROM subject_condition_set scs
)
SELECT
    scs.id,
    scs.condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
    counted.total
FROM subject_condition_set scs
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type ListSubjectConditionSetsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type ListSubjectConditionSetsRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
	Total     int64  `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT CONDITION SETS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(scs.id) AS total
//	    FROM subject_condition_set scs
//	)
//	SELECT
//	    scs.id,
//	    scs.condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
//	    counted.total
//	FROM subject_condition_set scs
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) ListSubjectConditionSets(ctx context.Context, arg ListSubjectConditionSetsParams) ([]ListSubjectConditionSetsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectConditionSets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubjectConditionSetsRow
	for rows.Next() {
		var i ListSubjectConditionSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Condition,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttribute = `-- name: RemoveKeyAccessServerFromAttribute :execrows
DELETE FROM attribute_definition_key_access_grants
WHERE attribute_definition_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	KeyAccessServerID     string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttribute
//
//	DELETE FROM attribute_definition_key_access_grants
//	WHERE attribute_definition_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttribute(ctx context.Context, arg RemoveKeyAccessServerFromAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeKeyAccessServerFromAttributeValue = `-- name: RemoveKeyAccessServerFromAttributeValue :execrows
DELETE FROM attribute_value_key_access_grants
WHERE attribute_value_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromAttributeValueParams struct {
	AttributeValueID  string `json:"attribute_value_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromAttributeValue
//
//	DELETE FROM attribute_value_key_access_grants
//	WHERE attribute_value_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromAttributeValue(ctx context.Context, arg RemoveKeyAccessServerFromAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeKeyAccessServerFromNamespace = `-- name: RemoveKeyAccessServerFromNamespace :execrows
DELETE FROM attribute_namespace_key_access_grants
WHERE namespace_id = $1 AND key_access_server_id = $2
`

type RemoveKeyAccessServerFromNamespaceParams struct {
	NamespaceID       string `json:"namespace_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// RemoveKeyAccessServerFromNamespace
//
//	DELETE FROM attribute_namespace_key_access_grants
//	WHERE namespace_id = $1 AND key_access_server_id = $2
func (q *Queries) RemoveKeyAccessServerFromNamespace(ctx context.Context, arg RemoveKeyAccessServerFromNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeKeyAccessServerFromNamespace, arg.NamespaceID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAttribute = `-- name: UpdateAttribute :execrows
UPDATE attribute_definitions
SET
    name = COALESCE($2, name),
    rule = COALESCE($3, rule),
    values_order = COALESCE($4, values_order),
    metadata = COALESCE($5, metadata),
    active = COALESCE($6, active)
WHERE id = $1
`

type UpdateAttributeParams struct {
	ID          string                      `json:"id"`
	Name        pgtype.Text                 `json:"name"`
	Rule        NullAttributeDefinitionRule `json:"rule"`
	ValuesOrder []string                    `json:"values_order"`
	Metadata    []byte                      `json:"metadata"`
	Active      pgtype.Bool                 `json:"active"`
}

// UpdateAttribute: Unsafe and Safe Updates both
//
//	UPDATE attribute_definitions
//	SET
//	    name = COALESCE($2, name),
//	    rule = COALESCE($3, rule),
//	    values_order = COALESCE($4, values_order),
//	    metadata = COALESCE($5, metadata),
//	    active = COALESCE($6, active)
//	WHERE id = $1
func (q *Queries) UpdateAttribute(ctx context.Context, arg UpdateAttributeParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAttribute,
		arg.ID,
		arg.Name,
		arg.Rule,
		arg.ValuesOrder,
		arg.Metadata,
		arg.Active,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateAttributeValue = `-- name: UpdateAttributeValue :execrows
UPDATE attribute_values
SET
    value = COALESCE($2, value),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateAttributeValueParams struct {
	ID       string      `json:"id"`
	Value    pgtype.Text `json:"value"`
	Active   pgtype.Bool `json:"active"`
	Metadata []byte      `json:"metadata"`
}

// UpdateAttributeValue: Safe and Unsafe Updates both
//
//	UPDATE attribute_values
//	SET
//	    value = COALESCE($2, value),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateAttributeValue(ctx context.Context, arg UpdateAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateAttributeValue,
		arg.ID,
		arg.Value,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateKey = `-- name: UpdateKey :execrows
UPDATE key_access_server_keys
SET
    key_status = COALESCE($2, key_status),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type UpdateKeyParams struct {
	ID        string      `json:"id"`
	KeyStatus pgtype.Int4 `json:"key_status"`
	Metadata  []byte      `json:"metadata"`
}

// UpdateKey
//
//	UPDATE key_access_server_keys
//	SET
//	    key_status = COALESCE($2, key_status),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateKey, arg.ID, arg.KeyStatus, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateKeyAccessServer = `-- name: UpdateKeyAccessServer :execrows
UPDATE key_access_servers
SET
    uri = COALESCE($2, uri),
    public_key = COALESCE($3, public_key),
    name = COALESCE($4, name),
    metadata = COALESCE($5, metadata),
    source_type = COALESCE($6, source_type)
WHERE id = $1
`

type UpdateKeyAccessServerParams struct {
	ID         string      `json:"id"`
	Uri        pgtype.Text `json:"uri"`
	PublicKey  []byte      `json:"public_key"`
	Name       pgtype.Text `json:"name"`
	Metadata   []byte      `json:"metadata"`
	SourceType pgtype.Int4 `json:"source_type"`
}

// UpdateKeyAccessServer
//
//	UPDATE key_access_servers
//	SET
//	    uri = COALESCE($2, uri),
//	    public_key = COALESCE($3, public_key),
//	    name = COALESCE($4, name),
//	    metadata = COALESCE($5, metadata),
//	    source_type = COALESCE($6, source_type)
//	WHERE id = $1
func (q *Queries) UpdateKeyAccessServer(ctx context.Context, arg UpdateKeyAccessServerParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateKeyAccessServer,
		arg.ID,
		arg.Uri,
		arg.PublicKey,
		arg.Name,
		arg.Metadata,
		arg.SourceType,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateNamespace = `-- name: UpdateNamespace :execrows
UPDATE attribute_namespaces
SET
    name = COALESCE($2, name),
    active = COALESCE($3, active),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateNamespaceParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Active   pgtype.Bool `json:"active"`
	Metadata []byte      `json:"metadata"`
}

// UpdateNamespace: both Safe and Unsafe Updates
//
//	UPDATE attribute_namespaces
//	SET
//	    name = COALESCE($2, name),
//	    active = COALESCE($3, active),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateNamespace(ctx context.Context, arg UpdateNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateNamespace,
		arg.ID,
		arg.Name,
		arg.Active,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateProviderConfig = `-- name: UpdateProviderConfig :execrows
UPDATE provider_config
SET
    provider_name = COALESCE($2, provider_name),
    config = COALESCE($3, config),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateProviderConfigParams struct {
	ID           string      `json:"id"`
	ProviderName pgtype.Text `json:"provider_name"`
	Config       []byte      `json:"config"`
	Metadata     []byte      `json:"metadata"`
}

// UpdateProviderConfig
//
//	UPDATE provider_config
//	SET
//	    provider_name = COALESCE($2, provider_name),
//	    config = COALESCE($3, config),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateProviderConfig(ctx context.Context, arg UpdateProviderConfigParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateProviderConfig,
		arg.ID,
		arg.ProviderName,
		arg.Config,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResourceMapping = `-- name: UpdateResourceMapping :execrows
UPDATE resource_mappings
SET
    attribute_value_id = COALESCE($2, attribute_value_id),
    terms = COALESCE($3, terms),
    metadata = COALESCE($4, metadata),
    group_id = COALESCE($5, group_id)
WHERE id = $1
`

type UpdateResourceMappingParams struct {
	ID               string      `json:"id"`
	AttributeValueID pgtype.UUID `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// UpdateResourceMapping
//
//	UPDATE resource_mappings
//	SET
//	    attribute_value_id = COALESCE($2, attribute_value_id),
//	    terms = COALESCE($3, terms),
//	    metadata = COALESCE($4, metadata),
//	    group_id = COALESCE($5, group_id)
//	WHERE id = $1
func (q *Queries) UpdateResourceMapping(ctx context.Context, arg UpdateResourceMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResourceMappingGroup = `-- name: UpdateResourceMappingGroup :execrows
UPDATE resource_mapping_groups
SET
    namespace_id = COALESCE($2, namespace_id),
    name = COALESCE($3, name),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type UpdateResourceMappingGroupParams struct {
	ID          string      `json:"id"`
	NamespaceID pgtype.UUID `json:"namespace_id"`
	Name        pgtype.Text `json:"name"`
	Metadata    []byte      `json:"metadata"`
}

// UpdateResourceMappingGroup
//
//	UPDATE resource_mapping_groups
//	SET
//	    namespace_id = COALESCE($2, namespace_id),
//	    name = COALESCE($3, name),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) UpdateResourceMappingGroup(ctx context.Context, arg UpdateResourceMappingGroupParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMappingGroup,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubjectConditionSet = `-- name: UpdateSubjectConditionSet :execrows
UPDATE subject_condition_set
SET
    condition = COALESCE($2, condition),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type UpdateSubjectConditionSetParams struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// UpdateSubjectConditionSet
//
//	UPDATE subject_condition_set
//	SET
//	    condition = COALESCE($2, condition),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) UpdateSubjectConditionSet(ctx context.Context, arg UpdateSubjectConditionSetParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectConditionSet, arg.ID, arg.Condition, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertAttributeDefinitionFqn = `-- name: UpsertAttributeDefinitionFqn :many
WITH new_fqns_cte AS (
    -- get attribute definition fqns
    SELECT
        ns.id AS namespace_id,
        ad.id AS attribute_id,
        NULL::UUID AS value_id,
        CONCAT('https://', ns.name, '/attr/', ad.name) AS fqn
    FROM attribute_definitions ad
    JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
    WHERE ad.id = $1 
    UNION
    -- get attribute value fqns
    SELECT
        ns.id as namespace_id,
        ad.id as attribute_id,
        av.id as value_id,
        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
    FROM attribute_values av
    JOIN attribute_definitions ad on av.attribute_definition_id = ad.id
    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
    WHERE ad.id = $1 
)
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT 
    namespace_id,
    attribute_id,
    value_id,
    fqn
FROM new_fqns_cte
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING
    COALESCE(namespace_id::TEXT, '')::TEXT as namespace_id,
    COALESCE(attribute_id::TEXT, '')::TEXT as attribute_id,
    COALESCE(value_id::TEXT, '')::TEXT as value_id,
    fqn
`

type UpsertAttributeDefinitionFqnRow struct {
	NamespaceID string `json:"namespace_id"`
	AttributeID string `json:"attribute_id"`
	ValueID     string `json:"value_id"`
	Fqn         string `json:"fqn"`
}

// UpsertAttributeDefinitionFqn
//
//	WITH new_fqns_cte AS (
//	    -- get attribute definition fqns
//	    SELECT
//	        ns.id AS namespace_id,
//	        ad.id AS attribute_id,
//	        NULL::UUID AS value_id,
//	        CONCAT('https://', ns.name, '/attr/', ad.name) AS fqn
//	    FROM attribute_definitions ad
//	    JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	    WHERE ad.id = $1
//	    UNION
//	    -- get attribute value fqns
//	    SELECT
//	        ns.id as namespace_id,
//	        ad.id as attribute_id,
//	        av.id as value_id,
//	        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
//	    FROM attribute_values av
//	    JOIN attribute_definitions ad on av.attribute_definition_id = ad.id
//	    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
//	    WHERE ad.id = $1
//	)
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    namespace_id,
//	    attribute_id,
//	    value_id,
//	    fqn
//	FROM new_fqns_cte
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING
//	    COALESCE(namespace_id::TEXT, '')::TEXT as namespace_id,
//	    COALESCE(attribute_id::TEXT, '')::TEXT as attribute_id,
//	    COALESCE(value_id::TEXT, '')::TEXT as value_id,
//	    fqn
func (q *Queries) UpsertAttributeDefinitionFqn(ctx context.Context, attributeID string) ([]UpsertAttributeDefinitionFqnRow, error) {
	rows, err := q.db.Query(ctx, upsertAttributeDefinitionFqn, attributeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertAttributeDefinitionFqnRow
	for rows.Next() {
		var i UpsertAttributeDefinitionFqnRow
		if err := rows.Scan(
			&i.NamespaceID,
			&i.AttributeID,
			&i.ValueID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAttributeNamespaceFqn = `-- name: UpsertAttributeNamespaceFqn :many
WITH new_fqns_cte AS (
    -- get namespace fqns
    SELECT
        ns.id as namespace_id,
        NULL::UUID as attribute_id,
        NULL::UUID as value_id,
        CONCAT('https://', ns.name) AS fqn
    FROM attribute_namespaces ns
    WHERE ns.id = $1 
    UNION
    -- get attribute definition fqns
    SELECT
        ns.id as namespace_id,
        ad.id as attribute_id,
        NULL::UUID as value_id,
        CONCAT('https://', ns.name, '/attr/', ad.name) AS fqn
    FROM attribute_definitions ad
    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
    WHERE ns.id = $1 
    UNION
    -- get attribute value fqns
    SELECT
        ns.id as namespace_id,
        ad.id as attribute_id,
        av.id as value_id,
        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
    FROM attribute_values av
    JOIN attribute_definitions ad on av.attribute_definition_id = ad.id
    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
    WHERE ns.id = $1 
)
INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT 
    namespace_id,
    attribute_id,
    value_id,
    fqn
FROM new_fqns_cte
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING
    COALESCE(namespace_id::TEXT, '')::TEXT as namespace_id,
    COALESCE(attribute_id::TEXT, '')::TEXT as attribute_id,
    COALESCE(value_id::TEXT, '')::TEXT as value_id,
    fqn
`

type UpsertAttributeNamespaceFqnRow struct {
	NamespaceID string `json:"namespace_id"`
	AttributeID string `json:"attribute_id"`
	ValueID     string `json:"value_id"`
	Fqn         string `json:"fqn"`
}

// UpsertAttributeNamespaceFqn
//
//	WITH new_fqns_cte AS (
//	    -- get namespace fqns
//	    SELECT
//	        ns.id as namespace_id,
//	        NULL::UUID as attribute_id,
//	        NULL::UUID as value_id,
//	        CONCAT('https://', ns.name) AS fqn
//	    FROM attribute_namespaces ns
//	    WHERE ns.id = $1
//	    UNION
//	    -- get attribute definition fqns
//	    SELECT
//	        ns.id as namespace_id,
//	        ad.id as attribute_id,
//	        NULL::UUID as value_id,
//	        CONCAT('https://', ns.name, '/attr/', ad.name) AS fqn
//	    FROM attribute_definitions ad
//	    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
//	    WHERE ns.id = $1
//	    UNION
//	    -- get attribute value fqns
//	    SELECT
//	        ns.id as namespace_id,
//	        ad.id as attribute_id,
//	        av.id as value_id,
//	        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
//	    FROM attribute_values av
//	    JOIN attribute_definitions ad on av.attribute_definition_id = ad.id
//	    JOIN attribute_namespaces ns on ad.namespace_id = ns.id
//	    WHERE ns.id = $1
//	)
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    namespace_id,
//	    attribute_id,
//	    value_id,
//	    fqn
//	FROM new_fqns_cte
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING
//	    COALESCE(namespace_id::TEXT, '')::TEXT as namespace_id,
//	    COALESCE(attribute_id::TEXT, '')::TEXT as attribute_id,
//	    COALESCE(value_id::TEXT, '')::TEXT as value_id,
//	    fqn
func (q *Queries) UpsertAttributeNamespaceFqn(ctx context.Context, namespaceID string) ([]UpsertAttributeNamespaceFqnRow, error) {
	rows, err := q.db.Query(ctx, upsertAttributeNamespaceFqn, namespaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertAttributeNamespaceFqnRow
	for rows.Next() {
		var i UpsertAttributeNamespaceFqnRow
		if err := rows.Scan(
			&i.NamespaceID,
			&i.AttributeID,
			&i.ValueID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAttributeValueFqn = `-- name: UpsertAttributeValueFqn :many

WITH new_fqns_cte AS (
    -- get attribute value fqns
    SELECT
        ns.id AS namespace_id,
        ad.id AS attribute_id,
        av.id AS value_id,
        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
    FROM attribute_values av
    INNER JOIN attribute_definitions AS ad ON av.attribute_definition_id = ad.id
    INNER JOIN attribute_namespaces AS ns ON ad.namespace_id = ns.id
    WHERE av.id = $1 
)

INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
SELECT
    namespace_id,
    attribute_id,
    value_id,
    fqn
FROM new_fqns_cte
ON CONFLICT (namespace_id, attribute_id, value_id) 
    DO UPDATE 
        SET fqn = EXCLUDED.fqn
RETURNING
    COALESCE(namespace_id::TEXT, '')::TEXT AS namespace_id,
    COALESCE(attribute_id::TEXT, '')::TEXT AS attribute_id,
    COALESCE(value_id::TEXT, '')::TEXT AS value_id,
    fqn
`

type UpsertAttributeValueFqnRow struct {
	NamespaceID string `json:"namespace_id"`
	AttributeID string `json:"attribute_id"`
	ValueID     string `json:"value_id"`
	Fqn         string `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTE FQN
// --------------------------------------------------------------
//
//	WITH new_fqns_cte AS (
//	    -- get attribute value fqns
//	    SELECT
//	        ns.id AS namespace_id,
//	        ad.id AS attribute_id,
//	        av.id AS value_id,
//	        CONCAT('https://', ns.name, '/attr/', ad.name, '/value/', av.value) AS fqn
//	    FROM attribute_values av
//	    INNER JOIN attribute_definitions AS ad ON av.attribute_definition_id = ad.id
//	    INNER JOIN attribute_namespaces AS ns ON ad.namespace_id = ns.id
//	    WHERE av.id = $1
//	)
//
//	INSERT INTO attribute_fqns (namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    namespace_id,
//	    attribute_id,
//	    value_id,
//	    fqn
//	FROM new_fqns_cte
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE
//	        SET fqn = EXCLUDED.fqn
//	RETURNING
//	    COALESCE(namespace_id::TEXT, '')::TEXT AS namespace_id,
//	    COALESCE(attribute_id::TEXT, '')::TEXT AS attribute_id,
//	    COALESCE(value_id::TEXT, '')::TEXT AS value_id,
//	    fqn
func (q *Queries) UpsertAttributeValueFqn(ctx context.Context, valueID string) ([]UpsertAttributeValueFqnRow, error) {
	rows, err := q.db.Query(ctx, upsertAttributeValueFqn, valueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpsertAttributeValueFqnRow
	for rows.Next() {
		var i UpsertAttributeValueFqnRow
		if err := rows.Scan(
			&i.NamespaceID,
			&i.AttributeID,
			&i.ValueID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignPublicKeyToAttributeDefinition = `-- name: assignPublicKeyToAttributeDefinition :one
INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING definition_id, key_access_server_key_id
`

type assignPublicKeyToAttributeDefinitionParams struct {
	DefinitionID         string `json:"definition_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// assignPublicKeyToAttributeDefinition
//
//	INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING definition_id, key_access_server_key_id
func (q *Queries) assignPublicKeyToAttributeDefinition(ctx context.Context, arg assignPublicKeyToAttributeDefinitionParams) (AttributeDefinitionPublicKeyMap, error) {
	row := q.db.QueryRow(ctx, assignPublicKeyToAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	var i AttributeDefinitionPublicKeyMap
	err := row.Scan(&i.DefinitionID, &i.KeyAccessServerKeyID)
	return i, err
}

const assignPublicKeyToAttributeValue = `-- name: assignPublicKeyToAttributeValue :one
INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING value_id, key_access_server_key_id
`

type assignPublicKeyToAttributeValueParams struct {
	ValueID              string `json:"value_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// assignPublicKeyToAttributeValue
//
//	INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING value_id, key_access_server_key_id
func (q *Queries) assignPublicKeyToAttributeValue(ctx context.Context, arg assignPublicKeyToAttributeValueParams) (AttributeValuePublicKeyMap, error) {
	row := q.db.QueryRow(ctx, assignPublicKeyToAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	var i AttributeValuePublicKeyMap
	err := row.Scan(&i.ValueID, &i.KeyAccessServerKeyID)
	return i, err
}

const assignPublicKeyToNamespace = `-- name: assignPublicKeyToNamespace :one
INSERT INTO attribute_namespace_public_key_map (namespace_id, key_access_server_key_id)
VALUES ($1, $2)
RETURNING namespace_id, key_access_server_key_id
`

type assignPublicKeyToNamespaceParams struct {
	NamespaceID          string `json:"namespace_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// assignPublicKeyToNamespace
//
//	INSERT INTO attribute_namespace_public_key_map (namespace_id, key_access_server_key_id)
//	VALUES ($1, $2)
//	RETURNING namespace_id, key_access_server_key_id
func (q *Queries) assignPublicKeyToNamespace(ctx context.Context, arg assignPublicKeyToNamespaceParams) (AttributeNamespacePublicKeyMap, error) {
	row := q.db.QueryRow(ctx, assignPublicKeyToNamespace, arg.NamespaceID, arg.KeyAccessServerKeyID)
	var i AttributeNamespacePublicKeyMap
	err := row.Scan(&i.NamespaceID, &i.KeyAccessServerKeyID)
	return i, err
}

const createCustomAction = `-- name: createCustomAction :one
INSERT INTO actions (name, metadata, is_standard)
VALUES ($1, $2, FALSE)
RETURNING id
`

type createCustomActionParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// createCustomAction
//
//	INSERT INTO actions (name, metadata, is_standard)
//	VALUES ($1, $2, FALSE)
//	RETURNING id
func (q *Queries) createCustomAction(ctx context.Context, arg createCustomActionParams) (string, error) {
	row := q.db.QueryRow(ctx, createCustomAction, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createOrListActionsByName = `-- name: createOrListActionsByName :many
WITH input_actions AS (
    SELECT unnest($1::text[]) AS name
),
new_actions AS (
    INSERT INTO actions (name, is_standard)
    SELECT 
        input.name, 
        FALSE -- custom actions
    FROM input_actions input
    WHERE NOT EXISTS (
        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
    )
    ON CONFLICT (name) DO NOTHING
    RETURNING id, name, is_standard, created_at
),
all_actions AS (
    -- Get existing actions that match input names
    SELECT a.id, a.name, a.is_standard, a.created_at, 
           TRUE AS pre_existing
    FROM actions a
    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
    
    UNION ALL
    
    -- Include newly created actions
    SELECT id, name, is_standard, created_at,
           FALSE AS pre_existing
    FROM new_actions
)
SELECT 
    id,
    name,
    is_standard,
    created_at,
    pre_existing
FROM all_actions
ORDER BY name
`

type createOrListActionsByNameRow struct {
	ID          string             `json:"id"`
	Name        string             `json:"name"`
	IsStandard  bool               `json:"is_standard"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	PreExisting bool               `json:"pre_existing"`
}

// createOrListActionsByName
//
//	WITH input_actions AS (
//	    SELECT unnest($1::text[]) AS name
//	),
//	new_actions AS (
//	    INSERT INTO actions (name, is_standard)
//	    SELECT
//	        input.name,
//	        FALSE -- custom actions
//	    FROM input_actions input
//	    WHERE NOT EXISTS (
//	        SELECT 1 FROM actions a WHERE LOWER(a.name) = LOWER(input.name)
//	    )
//	    ON CONFLICT (name) DO NOTHING
//	    RETURNING id, name, is_standard, created_at
//	),
//	all_actions AS (
//	    -- Get existing actions that match input names
//	    SELECT a.id, a.name, a.is_standard, a.created_at,
//	           TRUE AS pre_existing
//	    FROM actions a
//	    JOIN input_actions input ON LOWER(a.name) = LOWER(input.name)
//
//	    UNION ALL
//
//	    -- Include newly created actions
//	    SELECT id, name, is_standard, created_at,
//	           FALSE AS pre_existing
//	    FROM new_actions
//	)
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    created_at,
//	    pre_existing
//	FROM all_actions
//	ORDER BY name
func (q *Queries) createOrListActionsByName(ctx context.Context, actionNames []string) ([]createOrListActionsByNameRow, error) {
	rows, err := q.db.Query(ctx, createOrListActionsByName, actionNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []createOrListActionsByNameRow
	for rows.Next() {
		var i createOrListActionsByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsStandard,
			&i.CreatedAt,
			&i.PreExisting,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createRegisteredResource = `-- name: createRegisteredResource :one

INSERT INTO registered_resources (name, metadata)
VALUES ($1, $2)
RETURNING id
`

type createRegisteredResourceParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resources (name, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) createRegisteredResource(ctx context.Context, arg createRegisteredResourceParams) (string, error) {
	row := q.db.QueryRow(ctx, createRegisteredResource, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createRegisteredResourceValue = `-- name: createRegisteredResourceValue :one

INSERT INTO registered_resource_values (registered_resource_id, value, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type createRegisteredResourceValueParams struct {
	RegisteredResourceID string `json:"registered_resource_id"`
	Value                string `json:"value"`
	Metadata             []byte `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCE VALUES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resource_values (registered_resource_id, value, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) createRegisteredResourceValue(ctx context.Context, arg createRegisteredResourceValueParams) (string, error) {
	row := q.db.QueryRow(ctx, createRegisteredResourceValue, arg.RegisteredResourceID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectMapping = `-- name: createSubjectMapping :one
WITH inserted_mapping AS (
    INSERT INTO subject_mappings (
        attribute_value_id,
        metadata,
        subject_condition_set_id
    )
    VALUES ($1, $2, $3)
    RETURNING id
),
inserted_actions AS (
    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
    SELECT 
        (SELECT id FROM inserted_mapping),
        unnest($4::uuid[])
)
SELECT id FROM inserted_mapping
`

type createSubjectMappingParams struct {
	AttributeValueID      string      `json:"attribute_value_id"`
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
	ActionIds             []string    `json:"action_ids"`
}

// createSubjectMapping
//
//	WITH inserted_mapping AS (
//	    INSERT INTO subject_mappings (
//	        attribute_value_id,
//	        metadata,
//	        subject_condition_set_id
//	    )
//	    VALUES ($1, $2, $3)
//	    RETURNING id
//	),
//	inserted_actions AS (
//	    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
//	    SELECT
//	        (SELECT id FROM inserted_mapping),
//	        unnest($4::uuid[])
//	)
//	SELECT id FROM inserted_mapping
func (q *Queries) createSubjectMapping(ctx context.Context, arg createSubjectMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectMapping,
		arg.AttributeValueID,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ActionIds,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteCustomAction = `-- name: deleteCustomAction :execrows
DELETE FROM actions
WHERE id = $1
  AND is_standard = FALSE
`

// deleteCustomAction
//
//	DELETE FROM actions
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) deleteCustomAction(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCustomAction, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRegisteredResource = `-- name: deleteRegisteredResource :execrows
DELETE FROM registered_resources WHERE id = $1
`

// deleteRegisteredResource
//
//	DELETE FROM registered_resources WHERE id = $1
func (q *Queries) deleteRegisteredResource(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRegisteredResource, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRegisteredResourceValue = `-- name: deleteRegisteredResourceValue :execrows
DELETE FROM registered_resource_values WHERE id = $1
`

// deleteRegisteredResourceValue
//
//	DELETE FROM registered_resource_values WHERE id = $1
func (q *Queries) deleteRegisteredResourceValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRegisteredResourceValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubjectMapping = `-- name: deleteSubjectMapping :execrows
DELETE FROM subject_mappings WHERE id = $1
`

// deleteSubjectMapping
//
//	DELETE FROM subject_mappings WHERE id = $1
func (q *Queries) deleteSubjectMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAction = `-- name: getAction :one
SELECT 
    id,
    name,
    is_standard,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) AS metadata
FROM actions a
WHERE 
  ($1::uuid IS NULL OR a.id = $1::uuid)
  AND ($2::text IS NULL OR a.name = $2::text)
`

type getActionParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type getActionRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	IsStandard bool   `json:"is_standard"`
	Metadata   []byte `json:"metadata"`
}

// getAction
//
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) AS metadata
//	FROM actions a
//	WHERE
//	  ($1::uuid IS NULL OR a.id = $1::uuid)
//	  AND ($2::text IS NULL OR a.name = $2::text)
func (q *Queries) getAction(ctx context.Context, arg getActionParams) (getActionRow, error) {
	row := q.db.QueryRow(ctx, getAction, arg.ID, arg.Name)
	var i getActionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsStandard,
		&i.Metadata,
	)
	return i, err
}

const getRegisteredResource = `-- name: getRegisteredResource :one
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', v.id,
            'value', v.value
        )
    ) FILTER (WHERE v.id IS NOT NULL) as values
FROM registered_resources r
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
WHERE r.id = $1
GROUP BY r.id
`

type getRegisteredResourceRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
	Values   []byte `json:"values"`
}

// TODO add FQN support
//
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', v.id,
//	            'value', v.value
//	        )
//	    ) FILTER (WHERE v.id IS NOT NULL) as values
//	FROM registered_resources r
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	WHERE r.id = $1
//	GROUP BY r.id
func (q *Queries) getRegisteredResource(ctx context.Context, id string) (getRegisteredResourceRow, error) {
	row := q.db.QueryRow(ctx, getRegisteredResource, id)
	var i getRegisteredResourceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const getRegisteredResourceValue = `-- name: getRegisteredResourceValue :one
SELECT
    id,
    registered_resource_id,
    value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM registered_resource_values
WHERE id = $1
`

type getRegisteredResourceValueRow struct {
	ID                   string `json:"id"`
	RegisteredResourceID string `json:"registered_resource_id"`
	Value                string `json:"value"`
	Metadata             []byte `json:"metadata"`
}

// getRegisteredResourceValue
//
//	SELECT
//	    id,
//	    registered_resource_id,
//	    value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM registered_resource_values
//	WHERE id = $1
func (q *Queries) getRegisteredResourceValue(ctx context.Context, id string) (getRegisteredResourceValueRow, error) {
	row := q.db.QueryRow(ctx, getRegisteredResourceValue, id)
	var i getRegisteredResourceValueRow
	err := row.Scan(
		&i.ID,
		&i.RegisteredResourceID,
		&i.Value,
		&i.Metadata,
	)
	return i, err
}

const getSubjectMapping = `-- name: getSubjectMapping :one
SELECT
    sm.id,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
    ) AS standard_actions,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
    ) AS custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE sm.id = $1
GROUP BY av.id, sm.id, scs.id
`

type getSubjectMappingRow struct {
	ID                  string `json:"id"`
	StandardActions     []byte `json:"standard_actions"`
	CustomActions       []byte `json:"custom_actions"`
	Metadata            []byte `json:"metadata"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
}

// getSubjectMapping
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
//	    ) AS standard_actions,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
//	    ) AS custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE sm.id = $1
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) getSubjectMapping(ctx context.Context, id string) (getSubjectMappingRow, error) {
	row := q.db.QueryRow(ctx, getSubjectMapping, id)
	var i getSubjectMappingRow
	err := row.Scan(
		&i.ID,
		&i.StandardActions,
		&i.CustomActions,
		&i.Metadata,
		&i.SubjectConditionSet,
		&i.AttributeValue,
	)
	return i, err
}

const listActions = `-- name: listActions :many

WITH counted AS (
    SELECT COUNT(id) AS total FROM actions
)
SELECT 
    a.id,
    a.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
        'labels', a.metadata -> 'labels', 
        'created_at', a.created_at, 
        'updated_at', a.updated_at
    )) as metadata,
    a.is_standard,
    counted.total
FROM actions a
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type listActionsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listActionsRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	Metadata   []byte `json:"metadata"`
	IsStandard bool   `json:"is_standard"`
	Total      int64  `json:"total"`
}

// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total FROM actions
//	)
//	SELECT
//	    a.id,
//	    a.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	        'labels', a.metadata -> 'labels',
//	        'created_at', a.created_at,
//	        'updated_at', a.updated_at
//	    )) as metadata,
//	    a.is_standard,
//	    counted.total
//	FROM actions a
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listActions(ctx context.Context, arg listActionsParams) ([]listActionsRow, error) {
	rows, err := q.db.Query(ctx, listActions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listActionsRow
	for rows.Next() {
		var i listActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.IsStandard,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesByDefOrValueFqns = `-- name: listAttributesByDefOrValueFqns :many
WITH target_definition AS (
    SELECT DISTINCT
        ad.id,
        ad.namespace_id,
        ad.name,
        ad.rule,
        ad.active,
        ad.values_order,
        JSONB_AGG(
	        DISTINCT JSONB_BUILD_OBJECT(
	            'id', kas.id,
	            'uri', kas.uri,
                'name', kas.name,
	            'public_key', kas.public_key
	        )
	    ) FILTER (WHERE kas.id IS NOT NULL) AS grants,
        defk.keys AS keys
    FROM attribute_fqns fqns
    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
    LEFT JOIN attribute_definition_key_access_grants adkag ON ad.id = adkag.attribute_definition_id
    LEFT JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
    LEFT JOIN (
        SELECT
            k.definition_id,
            JSONB_AGG(
                DISTINCT JSONB_BUILD_OBJECT(
                    'id', kask.id,
                    'key_id', kask.key_id,
                    'key_status', kask.key_status,
                    'key_mode', kask.key_mode,
                    'key_algorithm', kask.key_algorithm,
                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                        'id', pc.id,
                        'name', pc.provider_name,
                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                    ))
                )
            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
        FROM attribute_definition_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
        GROUP BY k.definition_id
    ) defk ON ad.id = defk.definition_id
    WHERE fqns.fqn = ANY($1::TEXT[]) 
        AND ad.active = TRUE
    GROUP BY ad.id, defk.keys
),
namespaces AS (
	SELECT
		n.id,
		JSON_BUILD_OBJECT(
			'id', n.id,
			'name', n.name,
			'active', n.active,
	        'fqn', fqns.fqn,
	        'grants', JSONB_AGG(
	            DISTINCT JSONB_BUILD_OBJECT(
	                'id', kas.id,
	                'uri', kas.uri,
                    'name', kas.name,
	                'public_key', kas.public_key
	            )
	        ) FILTER (WHERE kas.id IS NOT NULL),
            'keys', nmp_keys.keys
    	) AS namespace
	FROM target_definition td
	INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
	INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
	LEFT JOIN attribute_namespace_key_access_grants ankag ON n.id = ankag.namespace_id
	LEFT JOIN key_access_servers kas ON ankag.key_access_server_id = kas.id
    LEFT JOIN (
        SELECT
            k.namespace_id,
            JSONB_AGG(
                DISTINCT JSONB_BUILD_OBJECT(
                    'id', kask.id,
                    'key_id', kask.key_id,
                    'key_status', kask.key_status,
                    'key_mode', kask.key_mode,
                    'key_algorithm', kask.key_algorithm,
                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                        'id', pc.id,
                        'name', pc.provider_name,
                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                    ))
                )
            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
        FROM attribute_namespace_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
        GROUP BY k.namespace_id
    ) nmp_keys ON n.id = nmp_keys.namespace_id
	WHERE n.active = TRUE
		AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
	GROUP BY n.id, fqns.fqn, nmp_keys.keys
),
value_grants AS (
	SELECT
		av.id,
		JSON_AGG(
			DISTINCT JSONB_BUILD_OBJECT(
				'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
		) FILTER (WHERE kas.id IS NOT NULL) AS grants
	FROM target_definition td
	LEFT JOIN attribute_values av on td.id = av.attribute_definition_id
	LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
	LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
	GROUP BY av.id
),
value_subject_mappings AS (
	SELECT
		av.id,
		JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', sm.id,
                'actions', (
                    SELECT COALESCE(
                        JSON_AGG(
                            JSON_BUILD_OBJECT(
                                'id', a.id,
                                'name', a.name
                            )
                        ) FILTER (WHERE a.id IS NOT NULL),
                        '[]'::JSON
                    )
                    FROM subject_mapping_actions sma
                    LEFT JOIN actions a ON sma.action_id = a.id
                    WHERE sma.subject_mapping_id = sm.id
                ),
                'subject_condition_set', JSON_BUILD_OBJECT(
                    'id', scs.id,
                    'subject_sets', scs.condition
                )
            )
        ) FILTER (WHERE sm.id IS NOT NULL) AS sub_maps
	FROM target_definition td
	LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
	LEFT JOIN subject_mappings sm ON av.id = sm.attribute_value_id
	LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
	GROUP BY av.id
),
values AS (
    SELECT
		av.attribute_definition_id,
		JSON_AGG(
	        JSON_BUILD_OBJECT(
	            'id', av.id,
	            'value', av.value,
	            'active', av.active,
	            'fqn', fqns.fqn,
	            'grants', avg.grants,
	            'subject_mappings', avsm.sub_maps,
                'keys', value_keys.keys
	        -- enforce order of values in response
	        ) ORDER BY ARRAY_POSITION(td.values_order, av.id)
	    ) AS values
	FROM target_definition td
	LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
	LEFT JOIN value_grants avg ON av.id = avg.id
	LEFT JOIN value_subject_mappings avsm ON av.id = avsm.id
    LEFT JOIN (
        SELECT
            k.value_id,
            JSONB_AGG(
                DISTINCT JSONB_BUILD_OBJECT(
                    'id', kask.id,
                    'key_id', kask.key_id,
                    'key_status', kask.key_status,
                    'key_mode', kask.key_mode,
                    'key_algorithm', kask.key_algorithm,
                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                        'id', pc.id,
                        'name', pc.provider_name,
                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
                    ))
                )
            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
        FROM attribute_value_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
        GROUP BY k.value_id
    ) value_keys ON av.id = value_keys.value_id                        
	WHERE av.active = TRUE
	GROUP BY av.attribute_definition_id
)
SELECT
	td.id,
	td.name,
    td.rule,
	td.active,
	n.namespace,
	fqns.fqn,
	values.values,
	td.grants,
    td.keys
FROM target_definition td
INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
INNER JOIN namespaces n ON td.namespace_id = n.id
LEFT JOIN values ON td.id = values.attribute_definition_id
WHERE fqns.value_id IS NULL
`

type listAttributesByDefOrValueFqnsRow struct {
	ID        string                  `json:"id"`
	Name      string                  `json:"name"`
	Rule      AttributeDefinitionRule `json:"rule"`
	Active    bool                    `json:"active"`
	Namespace []byte                  `json:"namespace"`
	Fqn       string                  `json:"fqn"`
	Values    []byte                  `json:"values"`
	Grants    []byte                  `json:"grants"`
	Keys      []byte                  `json:"keys"`
}

// get the attribute definition for the provided value or definition fqn
//
//	WITH target_definition AS (
//	    SELECT DISTINCT
//	        ad.id,
//	        ad.namespace_id,
//	        ad.name,
//	        ad.rule,
//	        ad.active,
//	        ad.values_order,
//	        JSONB_AGG(
//		        DISTINCT JSONB_BUILD_OBJECT(
//		            'id', kas.id,
//		            'uri', kas.uri,
//	                'name', kas.name,
//		            'public_key', kas.public_key
//		        )
//		    ) FILTER (WHERE kas.id IS NOT NULL) AS grants,
//	        defk.keys AS keys
//	    FROM attribute_fqns fqns
//	    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
//	    LEFT JOIN attribute_definition_key_access_grants adkag ON ad.id = adkag.attribute_definition_id
//	    LEFT JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
//	    LEFT JOIN (
//	        SELECT
//	            k.definition_id,
//	            JSONB_AGG(
//	                DISTINCT JSONB_BUILD_OBJECT(
//	                    'id', kask.id,
//	                    'key_id', kask.key_id,
//	                    'key_status', kask.key_status,
//	                    'key_mode', kask.key_mode,
//	                    'key_algorithm', kask.key_algorithm,
//	                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                        'id', pc.id,
//	                        'name', pc.provider_name,
//	                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                    ))
//	                )
//	            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	        FROM attribute_definition_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	        GROUP BY k.definition_id
//	    ) defk ON ad.id = defk.definition_id
//	    WHERE fqns.fqn = ANY($1::TEXT[])
//	        AND ad.active = TRUE
//	    GROUP BY ad.id, defk.keys
//	),
//	namespaces AS (
//		SELECT
//			n.id,
//			JSON_BUILD_OBJECT(
//				'id', n.id,
//				'name', n.name,
//				'active', n.active,
//		        'fqn', fqns.fqn,
//		        'grants', JSONB_AGG(
//		            DISTINCT JSONB_BUILD_OBJECT(
//		                'id', kas.id,
//		                'uri', kas.uri,
//	                    'name', kas.name,
//		                'public_key', kas.public_key
//		            )
//		        ) FILTER (WHERE kas.id IS NOT NULL),
//	            'keys', nmp_keys.keys
//	    	) AS namespace
//		FROM target_definition td
//		INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
//		INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
//		LEFT JOIN attribute_namespace_key_access_grants ankag ON n.id = ankag.namespace_id
//		LEFT JOIN key_access_servers kas ON ankag.key_access_server_id = kas.id
//	    LEFT JOIN (
//	        SELECT
//	            k.namespace_id,
//	            JSONB_AGG(
//	                DISTINCT JSONB_BUILD_OBJECT(
//	                    'id', kask.id,
//	                    'key_id', kask.key_id,
//	                    'key_status', kask.key_status,
//	                    'key_mode', kask.key_mode,
//	                    'key_algorithm', kask.key_algorithm,
//	                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                        'id', pc.id,
//	                        'name', pc.provider_name,
//	                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                    ))
//	                )
//	            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	        FROM attribute_namespace_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	        GROUP BY k.namespace_id
//	    ) nmp_keys ON n.id = nmp_keys.namespace_id
//		WHERE n.active = TRUE
//			AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
//		GROUP BY n.id, fqns.fqn, nmp_keys.keys
//	),
//	value_grants AS (
//		SELECT
//			av.id,
//			JSON_AGG(
//				DISTINCT JSONB_BUILD_OBJECT(
//					'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//			) FILTER (WHERE kas.id IS NOT NULL) AS grants
//		FROM target_definition td
//		LEFT JOIN attribute_values av on td.id = av.attribute_definition_id
//		LEFT JOIN attribute_value_key_access_grants avkag ON av.id = avkag.attribute_value_id
//		LEFT JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//		GROUP BY av.id
//	),
//	value_subject_mappings AS (
//		SELECT
//			av.id,
//			JSON_AGG(
//	            JSON_BUILD_OBJECT(
//	                'id', sm.id,
//	                'actions', (
//	                    SELECT COALESCE(
//	                        JSON_AGG(
//	                            JSON_BUILD_OBJECT(
//	                                'id', a.id,
//	                                'name', a.name
//	                            )
//	                        ) FILTER (WHERE a.id IS NOT NULL),
//	                        '[]'::JSON
//	                    )
//	                    FROM subject_mapping_actions sma
//	                    LEFT JOIN actions a ON sma.action_id = a.id
//	                    WHERE sma.subject_mapping_id = sm.id
//	                ),
//	                'subject_condition_set', JSON_BUILD_OBJECT(
//	                    'id', scs.id,
//	                    'subject_sets', scs.condition
//	                )
//	            )
//	        ) FILTER (WHERE sm.id IS NOT NULL) AS sub_maps
//		FROM target_definition td
//		LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
//		LEFT JOIN subject_mappings sm ON av.id = sm.attribute_value_id
//		LEFT JOIN subject_condition_set scs ON sm.subject_condition_set_id = scs.id
//		GROUP BY av.id
//	),
//	values AS (
//	    SELECT
//			av.attribute_definition_id,
//			JSON_AGG(
//		        JSON_BUILD_OBJECT(
//		            'id', av.id,
//		            'value', av.value,
//		            'active', av.active,
//		            'fqn', fqns.fqn,
//		            'grants', avg.grants,
//		            'subject_mappings', avsm.sub_maps,
//	                'keys', value_keys.keys
//		        -- enforce order of values in response
//		        ) ORDER BY ARRAY_POSITION(td.values_order, av.id)
//		    ) AS values
//		FROM target_definition td
//		LEFT JOIN attribute_values av ON td.id = av.attribute_definition_id
//		LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//		LEFT JOIN value_grants avg ON av.id = avg.id
//		LEFT JOIN value_subject_mappings avsm ON av.id = avsm.id
//	    LEFT JOIN (
//	        SELECT
//	            k.value_id,
//	            JSONB_AGG(
//	                DISTINCT JSONB_BUILD_OBJECT(
//	                    'id', kask.id,
//	                    'key_id', kask.key_id,
//	                    'key_status', kask.key_status,
//	                    'key_mode', kask.key_mode,
//	                    'key_algorithm', kask.key_algorithm,
//	                    'private_key_ctx', ENCODE(kask.private_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'public_key_ctx', ENCODE(kask.public_key_ctx::TEXT::BYTEA, 'base64'),
//	                    'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', kask.metadata -> 'labels', 'created_at', kask.created_at, 'updated_at', kask.updated_at)),
//	                    'provider_config', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                        'id', pc.id,
//	                        'name', pc.provider_name,
//	                        'config_json', ENCODE(pc.config::TEXT::BYTEA, 'base64'),
//	                        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', pc.metadata -> 'labels', 'created_at', pc.created_at, 'updated_at', pc.updated_at))
//	                    ))
//	                )
//	            ) FILTER (WHERE kask.id IS NOT NULL) AS keys
//	        FROM attribute_value_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        LEFT JOIN provider_config pc ON kask.provider_config_id = pc.id
//	        GROUP BY k.value_id
//	    ) value_keys ON av.id = value_keys.value_id
//		WHERE av.active = TRUE
//		GROUP BY av.attribute_definition_id
//	)
//	SELECT
//		td.id,
//		td.name,
//	    td.rule,
//		td.active,
//		n.namespace,
//		fqns.fqn,
//		values.values,
//		td.grants,
//	    td.keys
//	FROM target_definition td
//	INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
//	INNER JOIN namespaces n ON td.namespace_id = n.id
//	LEFT JOIN values ON td.id = values.attribute_definition_id
//	WHERE fqns.value_id IS NULL
func (q *Queries) listAttributesByDefOrValueFqns(ctx context.Context, fqns []string) ([]listAttributesByDefOrValueFqnsRow, error) {
	rows, err := q.db.Query(ctx, listAttributesByDefOrValueFqns, fqns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listAttributesByDefOrValueFqnsRow
	for rows.Next() {
		var i listAttributesByDefOrValueFqnsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Rule,
			&i.Active,
			&i.Namespace,
			&i.Fqn,
			&i.Values,
			&i.Grants,
			&i.Keys,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredResourceValues = `-- name: listRegisteredResourceValues :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM registered_resource_values
    WHERE
        NULLIF($1, '') IS NULL OR registered_resource_id = $1::UUID
)
SELECT
    id,
    registered_resource_id,
    value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata,
    counted.total
FROM registered_resource_values
CROSS JOIN counted
WHERE
    NULLIF($1, '') IS NULL OR registered_resource_id = $1::UUID
LIMIT $3
OFFSET $2
`

type listRegisteredResourceValuesParams struct {
	RegisteredResourceID interface{} `json:"registered_resource_id"`
	Offset               int32       `json:"offset_"`
	Limit                int32       `json:"limit_"`
}

type listRegisteredResourceValuesRow struct {
	ID                   string `json:"id"`
	RegisteredResourceID string `json:"registered_resource_id"`
	Value                string `json:"value"`
	Metadata             []byte `json:"metadata"`
	Total                int64  `json:"total"`
}

// listRegisteredResourceValues
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM registered_resource_values
//	    WHERE
//	        NULLIF($1, '') IS NULL OR registered_resource_id = $1::UUID
//	)
//	SELECT
//	    id,
//	    registered_resource_id,
//	    value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata,
//	    counted.total
//	FROM registered_resource_values
//	CROSS JOIN counted
//	WHERE
//	    NULLIF($1, '') IS NULL OR registered_resource_id = $1::UUID
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listRegisteredResourceValues(ctx context.Context, arg listRegisteredResourceValuesParams) ([]listRegisteredResourceValuesRow, error) {
	rows, err := q.db.Query(ctx, listRegisteredResourceValues, arg.RegisteredResourceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listRegisteredResourceValuesRow
	for rows.Next() {
		var i listRegisteredResourceValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredResourceID,
			&i.Value,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredResources = `-- name: listRegisteredResources :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM registered_resources
)
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', v.id,
            'value', v.value
        )
    ) FILTER (WHERE v.id IS NOT NULL) as values,
    counted.total
FROM registered_resources r
CROSS JOIN counted
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
GROUP BY r.id, counted.total
LIMIT $2 
OFFSET $1
`

type listRegisteredResourcesParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listRegisteredResourcesRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
	Values   []byte `json:"values"`
	Total    int64  `json:"total"`
}

// listRegisteredResources
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM registered_resources
//	)
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', v.id,
//	            'value', v.value
//	        )
//	    ) FILTER (WHERE v.id IS NOT NULL) as values,
//	    counted.total
//	FROM registered_resources r
//	CROSS JOIN counted
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	GROUP BY r.id, counted.total
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listRegisteredResources(ctx context.Context, arg listRegisteredResourcesParams) ([]listRegisteredResourcesRow, error) {
	rows, err := q.db.Query(ctx, listRegisteredResources, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listRegisteredResourcesRow
	for rows.Next() {
		var i listRegisteredResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectMappings = `-- name: listSubjectMappings :many

WITH counted AS (
    SELECT COUNT(sm.id) AS total
    FROM subject_mappings sm
)
SELECT
    sm.id,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
    ) AS standard_actions,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
    ) AS custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value,
    counted.total
FROM subject_mappings sm
CROSS JOIN counted
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
GROUP BY av.id, sm.id, scs.id, counted.total, fqns.fqn
LIMIT $2
OFFSET $1
`

type listSubjectMappingsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listSubjectMappingsRow struct {
	ID                  string `json:"id"`
	StandardActions     []byte `json:"standard_actions"`
	CustomActions       []byte `json:"custom_actions"`
	Metadata            []byte `json:"metadata"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
	Total               int64  `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT MAPPINGS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(sm.id) AS total
//	    FROM subject_mappings sm
//	)
//	SELECT
//	    sm.id,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
//	    ) AS standard_actions,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
//	    ) AS custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value,
//	    counted.total
//	FROM subject_mappings sm
//	CROSS JOIN counted
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	GROUP BY av.id, sm.id, scs.id, counted.total, fqns.fqn
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listSubjectMappings(ctx context.Context, arg listSubjectMappingsParams) ([]listSubjectMappingsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectMappings, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listSubjectMappingsRow
	for rows.Next() {
		var i listSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.Metadata,
			&i.SubjectConditionSet,
			&i.AttributeValue,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchSubjectMappings = `-- name: matchSubjectMappings :many
SELECT
    sm.id,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
    ) AS standard_actions,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
    ) AS custom_actions,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE ns.active = true AND ad.active = true and av.active = true AND EXISTS (
    SELECT 1
    FROM JSONB_ARRAY_ELEMENTS(scs.condition) AS ss, JSONB_ARRAY_ELEMENTS(ss->'conditionGroups') AS cg, JSONB_ARRAY_ELEMENTS(cg->'conditions') AS each_condition
    WHERE (each_condition->>'subjectExternalSelectorValue' = ANY($1::TEXT[])) 
)
GROUP BY av.id, sm.id, scs.id
`

type matchSubjectMappingsRow struct {
	ID                  string `json:"id"`
	StandardActions     []byte `json:"standard_actions"`
	CustomActions       []byte `json:"custom_actions"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
}

// matchSubjectMappings
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
//	    ) AS standard_actions,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
//	    ) AS custom_actions,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE ns.active = true AND ad.active = true and av.active = true AND EXISTS (
//	    SELECT 1
//	    FROM JSONB_ARRAY_ELEMENTS(scs.condition) AS ss, JSONB_ARRAY_ELEMENTS(ss->'conditionGroups') AS cg, JSONB_ARRAY_ELEMENTS(cg->'conditions') AS each_condition
//	    WHERE (each_condition->>'subjectExternalSelectorValue' = ANY($1::TEXT[]))
//	)
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) matchSubjectMappings(ctx context.Context, selectors []string) ([]matchSubjectMappingsRow, error) {
	rows, err := q.db.Query(ctx, matchSubjectMappings, selectors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []matchSubjectMappingsRow
	for rows.Next() {
		var i matchSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.SubjectConditionSet,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePublicKeyFromAttributeDefinition = `-- name: removePublicKeyFromAttributeDefinition :execrows
DELETE FROM attribute_definition_public_key_map
WHERE definition_id = $1 AND key_access_server_key_id = $2
`

type removePublicKeyFromAttributeDefinitionParams struct {
	DefinitionID         string `json:"definition_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// removePublicKeyFromAttributeDefinition
//
//	DELETE FROM attribute_definition_public_key_map
//	WHERE definition_id = $1 AND key_access_server_key_id = $2
func (q *Queries) removePublicKeyFromAttributeDefinition(ctx context.Context, arg removePublicKeyFromAttributeDefinitionParams) (int64, error) {
	result, err := q.db.Exec(ctx, removePublicKeyFromAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removePublicKeyFromAttributeValue = `-- name: removePublicKeyFromAttributeValue :execrows
DELETE FROM attribute_value_public_key_map
WHERE value_id = $1 AND key_access_server_key_id = $2
`

type removePublicKeyFromAttributeValueParams struct {
	ValueID              string `json:"value_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// removePublicKeyFromAttributeValue
//
//	DELETE FROM attribute_value_public_key_map
//	WHERE value_id = $1 AND key_access_server_key_id = $2
func (q *Queries) removePublicKeyFromAttributeValue(ctx context.Context, arg removePublicKeyFromAttributeValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, removePublicKeyFromAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removePublicKeyFromNamespace = `-- name: removePublicKeyFromNamespace :execrows
DELETE FROM attribute_namespace_public_key_map
WHERE namespace_id = $1 AND key_access_server_key_id = $2
`

type removePublicKeyFromNamespaceParams struct {
	NamespaceID          string `json:"namespace_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// removePublicKeyFromNamespace
//
//	DELETE FROM attribute_namespace_public_key_map
//	WHERE namespace_id = $1 AND key_access_server_key_id = $2
func (q *Queries) removePublicKeyFromNamespace(ctx context.Context, arg removePublicKeyFromNamespaceParams) (int64, error) {
	result, err := q.db.Exec(ctx, removePublicKeyFromNamespace, arg.NamespaceID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateCustomAction = `-- name: updateCustomAction :execrows
UPDATE actions
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
  AND is_standard = FALSE
`

type updateCustomActionParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateCustomAction
//
//	UPDATE actions
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
//	  AND is_standard = FALSE
func (q *Queries) updateCustomAction(ctx context.Context, arg updateCustomActionParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateCustomAction, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRegisteredResource = `-- name: updateRegisteredResource :execrows
UPDATE registered_resources
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateRegisteredResourceParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateRegisteredResource
//
//	UPDATE registered_resources
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateRegisteredResource(ctx context.Context, arg updateRegisteredResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateRegisteredResource, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRegisteredResourceValue = `-- name: updateRegisteredResourceValue :execrows
UPDATE registered_resource_values
SET
    value = COALESCE($2, value),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateRegisteredResourceValueParams struct {
	ID       string      `json:"id"`
	Value    pgtype.Text `json:"value"`
	Metadata []byte      `json:"metadata"`
}

// updateRegisteredResourceValue
//
//	UPDATE registered_resource_values
//	SET
//	    value = COALESCE($2, value),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateRegisteredResourceValue(ctx context.Context, arg updateRegisteredResourceValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateRegisteredResourceValue, arg.ID, arg.Value, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubjectMapping = `-- name: updateSubjectMapping :execrows
WITH
    subject_mapping_update AS (
        UPDATE subject_mappings
        SET
            metadata = COALESCE($1::JSONB, metadata),
            subject_condition_set_id = COALESCE($2::UUID, subject_condition_set_id)
        WHERE id = $3
        RETURNING id
    ),
    -- Delete any actions that are NOT in the new list
    action_delete AS (
        DELETE FROM subject_mapping_actions
        WHERE
            subject_mapping_id = $3
            AND $4::UUID[] IS NOT NULL
            AND action_id NOT IN (SELECT unnest($4::UUID[]))
    ),
    -- Insert actions that are not already related to the mapping
    action_insert AS (
        INSERT INTO
            subject_mapping_actions (subject_mapping_id, action_id)
        SELECT
            $3,
            a
        FROM unnest($4::UUID[]) AS a
        WHERE
            $4::UUID[] IS NOT NULL
            AND NOT EXISTS (
                SELECT 1
                FROM subject_mapping_actions
                WHERE subject_mapping_id = $3 AND action_id = a
            )
    ),
    update_count AS (
        SELECT COUNT(*) AS cnt
        FROM subject_mapping_update
    )
SELECT cnt
FROM update_count
`

type updateSubjectMappingParams struct {
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
	ID                    string      `json:"id"`
	ActionIds             []string    `json:"action_ids"`
}

// updateSubjectMapping
//
//	WITH
//	    subject_mapping_update AS (
//	        UPDATE subject_mappings
//	        SET
//	            metadata = COALESCE($1::JSONB, metadata),
//	            subject_condition_set_id = COALESCE($2::UUID, subject_condition_set_id)
//	        WHERE id = $3
//	        RETURNING id
//	    ),
//	    -- Delete any actions that are NOT in the new list
//	    action_delete AS (
//	        DELETE FROM subject_mapping_actions
//	        WHERE
//	            subject_mapping_id = $3
//	            AND $4::UUID[] IS NOT NULL
//	            AND action_id NOT IN (SELECT unnest($4::UUID[]))
//	    ),
//	    -- Insert actions that are not already related to the mapping
//	    action_insert AS (
//	        INSERT INTO
//	            subject_mapping_actions (subject_mapping_id, action_id)
//	        SELECT
//	            $3,
//	            a
//	        FROM unnest($4::UUID[]) AS a
//	        WHERE
//	            $4::UUID[] IS NOT NULL
//	            AND NOT EXISTS (
//	                SELECT 1
//	                FROM subject_mapping_actions
//	                WHERE subject_mapping_id = $3 AND action_id = a
//	            )
//	    ),
//	    update_count AS (
//	        SELECT COUNT(*) AS cnt
//	        FROM subject_mapping_update
//	    )
//	SELECT cnt
//	FROM update_count
func (q *Queries) updateSubjectMapping(ctx context.Context, arg updateSubjectMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectMapping,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ID,
		arg.ActionIds,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
