// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: registered_resources.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRegisteredResource = `-- name: createRegisteredResource :one

INSERT INTO registered_resources (name, metadata)
VALUES ($1, $2)
RETURNING id
`

type createRegisteredResourceParams struct {
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resources (name, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) createRegisteredResource(ctx context.Context, arg createRegisteredResourceParams) (string, error) {
	row := q.db.QueryRow(ctx, createRegisteredResource, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

type createRegisteredResourceActionAttributeValuesParams struct {
	RegisteredResourceValueID string `json:"registered_resource_value_id"`
	ActionID                  string `json:"action_id"`
	AttributeValueID          string `json:"attribute_value_id"`
}

const createRegisteredResourceValue = `-- name: createRegisteredResourceValue :one

INSERT INTO registered_resource_values (registered_resource_id, value, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type createRegisteredResourceValueParams struct {
	RegisteredResourceID string `json:"registered_resource_id"`
	Value                string `json:"value"`
	Metadata             []byte `json:"metadata"`
}

// --------------------------------------------------------------
// REGISTERED RESOURCE VALUES
// --------------------------------------------------------------
//
//	INSERT INTO registered_resource_values (registered_resource_id, value, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) createRegisteredResourceValue(ctx context.Context, arg createRegisteredResourceValueParams) (string, error) {
	row := q.db.QueryRow(ctx, createRegisteredResourceValue, arg.RegisteredResourceID, arg.Value, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteRegisteredResource = `-- name: deleteRegisteredResource :execrows
DELETE FROM registered_resources WHERE id = $1
`

// deleteRegisteredResource
//
//	DELETE FROM registered_resources WHERE id = $1
func (q *Queries) deleteRegisteredResource(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRegisteredResource, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRegisteredResourceActionAttributeValues = `-- name: deleteRegisteredResourceActionAttributeValues :execrows
DELETE FROM registered_resource_action_attribute_values
WHERE registered_resource_value_id = $1
`

// deleteRegisteredResourceActionAttributeValues
//
//	DELETE FROM registered_resource_action_attribute_values
//	WHERE registered_resource_value_id = $1
func (q *Queries) deleteRegisteredResourceActionAttributeValues(ctx context.Context, registeredResourceValueID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRegisteredResourceActionAttributeValues, registeredResourceValueID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteRegisteredResourceValue = `-- name: deleteRegisteredResourceValue :execrows
DELETE FROM registered_resource_values WHERE id = $1
`

// deleteRegisteredResourceValue
//
//	DELETE FROM registered_resource_values WHERE id = $1
func (q *Queries) deleteRegisteredResourceValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRegisteredResourceValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getRegisteredResource = `-- name: getRegisteredResource :one
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', v.id,
            'value', v.value
        )
    ) FILTER (WHERE v.id IS NOT NULL) as values
FROM registered_resources r
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
WHERE
    ($1::uuid IS NULL OR r.id = $1::uuid) AND
    ($2::text IS NULL OR r.name = $2::text)
GROUP BY r.id
`

type getRegisteredResourceParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

type getRegisteredResourceRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
	Values   []byte `json:"values"`
}

// getRegisteredResource
//
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', v.id,
//	            'value', v.value
//	        )
//	    ) FILTER (WHERE v.id IS NOT NULL) as values
//	FROM registered_resources r
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	WHERE
//	    ($1::uuid IS NULL OR r.id = $1::uuid) AND
//	    ($2::text IS NULL OR r.name = $2::text)
//	GROUP BY r.id
func (q *Queries) getRegisteredResource(ctx context.Context, arg getRegisteredResourceParams) (getRegisteredResourceRow, error) {
	row := q.db.QueryRow(ctx, getRegisteredResource, arg.ID, arg.Name)
	var i getRegisteredResourceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const getRegisteredResourceValue = `-- name: getRegisteredResourceValue :one
SELECT
    v.id,
    v.registered_resource_id,
    v.value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', v.metadata -> 'labels', 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
    JSON_AGG(
    	JSON_BUILD_OBJECT(
    		'action', JSON_BUILD_OBJECT(
    			'id', a.id,
    			'name', a.name
    		),
    		'attribute_value', JSON_BUILD_OBJECT(
    			'id', av.id,
    			'value', av.value,
    			'fqn', fqns.fqn
    		)
    	)
    ) FILTER (WHERE rav.id IS NOT NULL) as action_attribute_values
FROM registered_resource_values v
JOIN registered_resources r ON v.registered_resource_id = r.id
LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
LEFT JOIN actions a on rav.action_id = a.id
LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE
    ($1::uuid IS NULL OR v.id = $1::uuid) AND
    ($2::text IS NULL OR r.name = $2::text) AND
    ($3::text IS NULL OR v.value = $3::text)
GROUP BY v.id
`

type getRegisteredResourceValueParams struct {
	ID    pgtype.UUID `json:"id"`
	Name  pgtype.Text `json:"name"`
	Value pgtype.Text `json:"value"`
}

type getRegisteredResourceValueRow struct {
	ID                    string `json:"id"`
	RegisteredResourceID  string `json:"registered_resource_id"`
	Value                 string `json:"value"`
	Metadata              []byte `json:"metadata"`
	ActionAttributeValues []byte `json:"action_attribute_values"`
}

// getRegisteredResourceValue
//
//	SELECT
//	    v.id,
//	    v.registered_resource_id,
//	    v.value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', v.metadata -> 'labels', 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
//	    JSON_AGG(
//	    	JSON_BUILD_OBJECT(
//	    		'action', JSON_BUILD_OBJECT(
//	    			'id', a.id,
//	    			'name', a.name
//	    		),
//	    		'attribute_value', JSON_BUILD_OBJECT(
//	    			'id', av.id,
//	    			'value', av.value,
//	    			'fqn', fqns.fqn
//	    		)
//	    	)
//	    ) FILTER (WHERE rav.id IS NOT NULL) as action_attribute_values
//	FROM registered_resource_values v
//	JOIN registered_resources r ON v.registered_resource_id = r.id
//	LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
//	LEFT JOIN actions a on rav.action_id = a.id
//	LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE
//	    ($1::uuid IS NULL OR v.id = $1::uuid) AND
//	    ($2::text IS NULL OR r.name = $2::text) AND
//	    ($3::text IS NULL OR v.value = $3::text)
//	GROUP BY v.id
func (q *Queries) getRegisteredResourceValue(ctx context.Context, arg getRegisteredResourceValueParams) (getRegisteredResourceValueRow, error) {
	row := q.db.QueryRow(ctx, getRegisteredResourceValue, arg.ID, arg.Name, arg.Value)
	var i getRegisteredResourceValueRow
	err := row.Scan(
		&i.ID,
		&i.RegisteredResourceID,
		&i.Value,
		&i.Metadata,
		&i.ActionAttributeValues,
	)
	return i, err
}

const listRegisteredResourceValues = `-- name: listRegisteredResourceValues :many
WITH counted AS (
    SELECT COUNT(v.id) AS total
    FROM registered_resource_values v
    WHERE $1::uuid IS NULL OR v.registered_resource_id = $1::uuid
)
SELECT
    v.id,
    v.registered_resource_id,
    v.value,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', v.metadata -> 'labels', 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
    JSON_AGG(
    	JSON_BUILD_OBJECT(
    		'action', JSON_BUILD_OBJECT(
    			'id', a.id,
    			'name', a.name
    		),
    		'attribute_value', JSON_BUILD_OBJECT(
    			'id', av.id,
    			'value', av.value,
    			'fqn', fqns.fqn
    		)
    	)
    ) FILTER (WHERE rav.id IS NOT NULL) as action_attribute_values,
    counted.total
FROM registered_resource_values v
JOIN registered_resources r ON v.registered_resource_id = r.id
LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
LEFT JOIN actions a on rav.action_id = a.id
LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id  
CROSS JOIN counted
WHERE
    $1::uuid IS NULL OR v.registered_resource_id = $1::uuid
GROUP BY v.id, counted.total
ORDER BY v.created_at DESC
LIMIT $3
OFFSET $2
`

type listRegisteredResourceValuesParams struct {
	RegisteredResourceID pgtype.UUID `json:"registered_resource_id"`
	Offset               int32       `json:"offset_"`
	Limit                int32       `json:"limit_"`
}

type listRegisteredResourceValuesRow struct {
	ID                    string `json:"id"`
	RegisteredResourceID  string `json:"registered_resource_id"`
	Value                 string `json:"value"`
	Metadata              []byte `json:"metadata"`
	ActionAttributeValues []byte `json:"action_attribute_values"`
	Total                 int64  `json:"total"`
}

// listRegisteredResourceValues
//
//	WITH counted AS (
//	    SELECT COUNT(v.id) AS total
//	    FROM registered_resource_values v
//	    WHERE $1::uuid IS NULL OR v.registered_resource_id = $1::uuid
//	)
//	SELECT
//	    v.id,
//	    v.registered_resource_id,
//	    v.value,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', v.metadata -> 'labels', 'created_at', v.created_at, 'updated_at', v.updated_at)) as metadata,
//	    JSON_AGG(
//	    	JSON_BUILD_OBJECT(
//	    		'action', JSON_BUILD_OBJECT(
//	    			'id', a.id,
//	    			'name', a.name
//	    		),
//	    		'attribute_value', JSON_BUILD_OBJECT(
//	    			'id', av.id,
//	    			'value', av.value,
//	    			'fqn', fqns.fqn
//	    		)
//	    	)
//	    ) FILTER (WHERE rav.id IS NOT NULL) as action_attribute_values,
//	    counted.total
//	FROM registered_resource_values v
//	JOIN registered_resources r ON v.registered_resource_id = r.id
//	LEFT JOIN registered_resource_action_attribute_values rav ON v.id = rav.registered_resource_value_id
//	LEFT JOIN actions a on rav.action_id = a.id
//	LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	CROSS JOIN counted
//	WHERE
//	    $1::uuid IS NULL OR v.registered_resource_id = $1::uuid
//	GROUP BY v.id, counted.total
//	ORDER BY v.created_at DESC
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listRegisteredResourceValues(ctx context.Context, arg listRegisteredResourceValuesParams) ([]listRegisteredResourceValuesRow, error) {
	rows, err := q.db.Query(ctx, listRegisteredResourceValues, arg.RegisteredResourceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listRegisteredResourceValuesRow
	for rows.Next() {
		var i listRegisteredResourceValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.RegisteredResourceID,
			&i.Value,
			&i.Metadata,
			&i.ActionAttributeValues,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegisteredResources = `-- name: listRegisteredResources :many
WITH counted AS (
    SELECT COUNT(id) AS total
    FROM registered_resources
)
SELECT
    r.id,
    r.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
    -- Aggregate all values for this resource into a JSON array, filtering NULL entries
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', v.id,
            'value', v.value,
            'action_attribute_values', action_attrs.values
        )
    ) FILTER (WHERE v.id IS NOT NULL) as values,
    counted.total
FROM registered_resources r
CROSS JOIN counted
LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
LEFT JOIN LATERAL (
    SELECT JSON_AGG(
        JSON_BUILD_OBJECT(
            'action', JSON_BUILD_OBJECT(
                'id', a.id,
                'name', a.name
            ),
            'attribute_value', JSON_BUILD_OBJECT(
                'id', av.id,
                'value', av.value,
                'fqn', fqns.fqn
            )
        )
    ) AS values
    -- Join to get all action-attribute relationships for this resource value
    FROM registered_resource_action_attribute_values rav
    LEFT JOIN actions a on rav.action_id = a.id
    LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
    LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
    -- Correlate to the outer query's resource value
    WHERE rav.registered_resource_value_id = v.id
) action_attrs ON true  -- required syntax for LATERAL joins
GROUP BY r.id, counted.total
ORDER BY r.created_at DESC
LIMIT $2 
OFFSET $1
`

type listRegisteredResourcesParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listRegisteredResourcesRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Metadata []byte `json:"metadata"`
	Values   []byte `json:"values"`
	Total    int64  `json:"total"`
}

// Build a JSON array of action/attribute pairs for each resource value
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total
//	    FROM registered_resources
//	)
//	SELECT
//	    r.id,
//	    r.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', r.metadata -> 'labels', 'created_at', r.created_at, 'updated_at', r.updated_at)) as metadata,
//	    -- Aggregate all values for this resource into a JSON array, filtering NULL entries
//	    JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'id', v.id,
//	            'value', v.value,
//	            'action_attribute_values', action_attrs.values
//	        )
//	    ) FILTER (WHERE v.id IS NOT NULL) as values,
//	    counted.total
//	FROM registered_resources r
//	CROSS JOIN counted
//	LEFT JOIN registered_resource_values v ON v.registered_resource_id = r.id
//	LEFT JOIN LATERAL (
//	    SELECT JSON_AGG(
//	        JSON_BUILD_OBJECT(
//	            'action', JSON_BUILD_OBJECT(
//	                'id', a.id,
//	                'name', a.name
//	            ),
//	            'attribute_value', JSON_BUILD_OBJECT(
//	                'id', av.id,
//	                'value', av.value,
//	                'fqn', fqns.fqn
//	            )
//	        )
//	    ) AS values
//	    -- Join to get all action-attribute relationships for this resource value
//	    FROM registered_resource_action_attribute_values rav
//	    LEFT JOIN actions a on rav.action_id = a.id
//	    LEFT JOIN attribute_values av on rav.attribute_value_id = av.id
//	    LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	    -- Correlate to the outer query's resource value
//	    WHERE rav.registered_resource_value_id = v.id
//	) action_attrs ON true  -- required syntax for LATERAL joins
//	GROUP BY r.id, counted.total
//	ORDER BY r.created_at DESC
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listRegisteredResources(ctx context.Context, arg listRegisteredResourcesParams) ([]listRegisteredResourcesRow, error) {
	rows, err := q.db.Query(ctx, listRegisteredResources, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listRegisteredResourcesRow
	for rows.Next() {
		var i listRegisteredResourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRegisteredResource = `-- name: updateRegisteredResource :execrows
UPDATE registered_resources
SET
    name = COALESCE($2, name),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateRegisteredResourceParams struct {
	ID       string      `json:"id"`
	Name     pgtype.Text `json:"name"`
	Metadata []byte      `json:"metadata"`
}

// updateRegisteredResource
//
//	UPDATE registered_resources
//	SET
//	    name = COALESCE($2, name),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateRegisteredResource(ctx context.Context, arg updateRegisteredResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateRegisteredResource, arg.ID, arg.Name, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRegisteredResourceValue = `-- name: updateRegisteredResourceValue :execrows
UPDATE registered_resource_values
SET
    value = COALESCE($2, value),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateRegisteredResourceValueParams struct {
	ID       string      `json:"id"`
	Value    pgtype.Text `json:"value"`
	Metadata []byte      `json:"metadata"`
}

// updateRegisteredResourceValue
//
//	UPDATE registered_resource_values
//	SET
//	    value = COALESCE($2, value),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateRegisteredResourceValue(ctx context.Context, arg updateRegisteredResourceValueParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateRegisteredResourceValue, arg.ID, arg.Value, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
