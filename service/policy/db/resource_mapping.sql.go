// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: resource_mapping.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createResourceMapping = `-- name: createResourceMapping :one
INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type createResourceMappingParams struct {
	AttributeValueID string      `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// createResourceMapping
//
//	INSERT INTO resource_mappings (attribute_value_id, terms, metadata, group_id)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id
func (q *Queries) createResourceMapping(ctx context.Context, arg createResourceMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMapping,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMappingGroup = `-- name: createResourceMappingGroup :one
INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
VALUES ($1, $2, $3)
RETURNING id
`

type createResourceMappingGroupParams struct {
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// createResourceMappingGroup
//
//	INSERT INTO resource_mapping_groups (namespace_id, name, metadata)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) createResourceMappingGroup(ctx context.Context, arg createResourceMappingGroupParams) (string, error) {
	row := q.db.QueryRow(ctx, createResourceMappingGroup, arg.NamespaceID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteResourceMapping = `-- name: deleteResourceMapping :execrows
DELETE FROM resource_mappings WHERE id = $1
`

// deleteResourceMapping
//
//	DELETE FROM resource_mappings WHERE id = $1
func (q *Queries) deleteResourceMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteResourceMappingGroup = `-- name: deleteResourceMappingGroup :execrows
DELETE FROM resource_mapping_groups WHERE id = $1
`

// deleteResourceMappingGroup
//
//	DELETE FROM resource_mapping_groups WHERE id = $1
func (q *Queries) deleteResourceMappingGroup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResourceMappingGroup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getResourceMapping = `-- name: getResourceMapping :one
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
FROM resource_mappings m 
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE m.id = $1
GROUP BY av.id, m.id, fqns.fqn
`

type getResourceMappingRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	GroupID        string   `json:"group_id"`
}

// getResourceMapping
//
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    COALESCE(m.group_id::TEXT, '')::TEXT as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE m.id = $1
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) getResourceMapping(ctx context.Context, id string) (getResourceMappingRow, error) {
	row := q.db.QueryRow(ctx, getResourceMapping, id)
	var i getResourceMappingRow
	err := row.Scan(
		&i.ID,
		&i.AttributeValue,
		&i.Terms,
		&i.Metadata,
		&i.GroupID,
	)
	return i, err
}

const getResourceMappingGroup = `-- name: getResourceMappingGroup :one
SELECT id, namespace_id, name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM resource_mapping_groups
WHERE id = $1
`

type getResourceMappingGroupRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
}

// getResourceMappingGroup
//
//	SELECT id, namespace_id, name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM resource_mapping_groups
//	WHERE id = $1
func (q *Queries) getResourceMappingGroup(ctx context.Context, id string) (getResourceMappingGroupRow, error) {
	row := q.db.QueryRow(ctx, getResourceMappingGroup, id)
	var i getResourceMappingGroupRow
	err := row.Scan(
		&i.ID,
		&i.NamespaceID,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const listResourceMappingGroups = `-- name: listResourceMappingGroups :many

WITH counted AS (
    SELECT COUNT(rmg.id) AS total
    FROM resource_mapping_groups rmg
)
SELECT rmg.id,
    rmg.namespace_id,
    rmg.name,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', rmg.metadata -> 'labels', 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
    counted.total
FROM resource_mapping_groups rmg
CROSS JOIN counted
WHERE (NULLIF($1, '') IS NULL OR rmg.namespace_id = $1::uuid) 
LIMIT $3 
OFFSET $2
`

type listResourceMappingGroupsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int32       `json:"offset_"`
	Limit       int32       `json:"limit_"`
}

type listResourceMappingGroupsRow struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
	Name        string `json:"name"`
	Metadata    []byte `json:"metadata"`
	Total       int64  `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING GROUPS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(rmg.id) AS total
//	    FROM resource_mapping_groups rmg
//	)
//	SELECT rmg.id,
//	    rmg.namespace_id,
//	    rmg.name,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', rmg.metadata -> 'labels', 'created_at', rmg.created_at, 'updated_at', rmg.updated_at)) as metadata,
//	    counted.total
//	FROM resource_mapping_groups rmg
//	CROSS JOIN counted
//	WHERE (NULLIF($1, '') IS NULL OR rmg.namespace_id = $1::uuid)
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listResourceMappingGroups(ctx context.Context, arg listResourceMappingGroupsParams) ([]listResourceMappingGroupsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingGroups, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingGroupsRow
	for rows.Next() {
		var i listResourceMappingGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappings = `-- name: listResourceMappings :many

WITH counted AS (
    SELECT COUNT(rm.id) AS total
    FROM resource_mappings rm
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    JSON_STRIP_NULLS(
        JSON_BUILD_OBJECT(
            'id', rmg.id,
            'name', rmg.name,
            'namespace_id', rmg.namespace_id
        )
    ) AS group,
    counted.total
FROM resource_mappings m 
CROSS JOIN counted
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID)
GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id, counted.total
LIMIT $3 
OFFSET $2
`

type listResourceMappingsParams struct {
	GroupID interface{} `json:"group_id"`
	Offset  int32       `json:"offset_"`
	Limit   int32       `json:"limit_"`
}

type listResourceMappingsRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	Group          []byte   `json:"group"`
	Total          int64    `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(rm.id) AS total
//	    FROM resource_mappings rm
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    JSON_STRIP_NULLS(
//	        JSON_BUILD_OBJECT(
//	            'id', rmg.id,
//	            'name', rmg.name,
//	            'namespace_id', rmg.namespace_id
//	        )
//	    ) AS group,
//	    counted.total
//	FROM resource_mappings m
//	CROSS JOIN counted
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
//	WHERE (NULLIF($1, '') IS NULL OR m.group_id = $1::UUID)
//	GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id, counted.total
//	LIMIT $3
//	OFFSET $2
func (q *Queries) listResourceMappings(ctx context.Context, arg listResourceMappingsParams) ([]listResourceMappingsRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappings, arg.GroupID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingsRow
	for rows.Next() {
		var i listResourceMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingsByFullyQualifiedGroup = `-- name: listResourceMappingsByFullyQualifiedGroup :many
WITH groups_cte AS (
    SELECT
        g.id,
        JSON_BUILD_OBJECT(
            'id', g.id,
            'namespace_id', g.namespace_id,
            'name', g.name,
            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
                'labels', g.metadata -> 'labels',
                'created_at', g.created_at,
                'updated_at', g.updated_at
            ))
        ) as group
    FROM resource_mapping_groups g
    JOIN attribute_namespaces ns on g.namespace_id = ns.id
    WHERE ns.name = $1 AND g.name = $2 
)
SELECT
    m.id,
    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
    g.group
FROM resource_mappings m
JOIN groups_cte g ON m.group_id = g.id
JOIN attribute_values av on m.attribute_value_id = av.id
JOIN attribute_fqns fqns on av.id = fqns.value_id
`

type listResourceMappingsByFullyQualifiedGroupParams struct {
	NamespaceName string `json:"namespace_name"`
	GroupName     string `json:"group_name"`
}

type listResourceMappingsByFullyQualifiedGroupRow struct {
	ID             string   `json:"id"`
	AttributeValue []byte   `json:"attribute_value"`
	Terms          []string `json:"terms"`
	Metadata       []byte   `json:"metadata"`
	Group          []byte   `json:"group"`
}

// CTE to cache the group JSON build since it will be the same for all mappings of the group
//
//	WITH groups_cte AS (
//	    SELECT
//	        g.id,
//	        JSON_BUILD_OBJECT(
//	            'id', g.id,
//	            'namespace_id', g.namespace_id,
//	            'name', g.name,
//	            'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT(
//	                'labels', g.metadata -> 'labels',
//	                'created_at', g.created_at,
//	                'updated_at', g.updated_at
//	            ))
//	        ) as group
//	    FROM resource_mapping_groups g
//	    JOIN attribute_namespaces ns on g.namespace_id = ns.id
//	    WHERE ns.name = $1 AND g.name = $2
//	)
//	SELECT
//	    m.id,
//	    JSON_BUILD_OBJECT('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', m.metadata -> 'labels', 'created_at', m.created_at, 'updated_at', m.updated_at)) as metadata,
//	    g.group
//	FROM resource_mappings m
//	JOIN groups_cte g ON m.group_id = g.id
//	JOIN attribute_values av on m.attribute_value_id = av.id
//	JOIN attribute_fqns fqns on av.id = fqns.value_id
func (q *Queries) listResourceMappingsByFullyQualifiedGroup(ctx context.Context, arg listResourceMappingsByFullyQualifiedGroupParams) ([]listResourceMappingsByFullyQualifiedGroupRow, error) {
	rows, err := q.db.Query(ctx, listResourceMappingsByFullyQualifiedGroup, arg.NamespaceName, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingsByFullyQualifiedGroupRow
	for rows.Next() {
		var i listResourceMappingsByFullyQualifiedGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceMapping = `-- name: updateResourceMapping :execrows
UPDATE resource_mappings
SET
    attribute_value_id = COALESCE($2, attribute_value_id),
    terms = COALESCE($3, terms),
    metadata = COALESCE($4, metadata),
    group_id = COALESCE($5, group_id)
WHERE id = $1
`

type updateResourceMappingParams struct {
	ID               string      `json:"id"`
	AttributeValueID pgtype.UUID `json:"attribute_value_id"`
	Terms            []string    `json:"terms"`
	Metadata         []byte      `json:"metadata"`
	GroupID          pgtype.UUID `json:"group_id"`
}

// updateResourceMapping
//
//	UPDATE resource_mappings
//	SET
//	    attribute_value_id = COALESCE($2, attribute_value_id),
//	    terms = COALESCE($3, terms),
//	    metadata = COALESCE($4, metadata),
//	    group_id = COALESCE($5, group_id)
//	WHERE id = $1
func (q *Queries) updateResourceMapping(ctx context.Context, arg updateResourceMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateResourceMappingGroup = `-- name: updateResourceMappingGroup :execrows
UPDATE resource_mapping_groups
SET
    namespace_id = COALESCE($2, namespace_id),
    name = COALESCE($3, name),
    metadata = COALESCE($4, metadata)
WHERE id = $1
`

type updateResourceMappingGroupParams struct {
	ID          string      `json:"id"`
	NamespaceID pgtype.UUID `json:"namespace_id"`
	Name        pgtype.Text `json:"name"`
	Metadata    []byte      `json:"metadata"`
}

// updateResourceMappingGroup
//
//	UPDATE resource_mapping_groups
//	SET
//	    namespace_id = COALESCE($2, namespace_id),
//	    name = COALESCE($3, name),
//	    metadata = COALESCE($4, metadata)
//	WHERE id = $1
func (q *Queries) updateResourceMappingGroup(ctx context.Context, arg updateResourceMappingGroupParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateResourceMappingGroup,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
