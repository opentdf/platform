// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createCustomAction = `-- name: createCustomAction :one
INSERT INTO actions (id, name, metadata, is_standard)
VALUES (?1, ?2, ?3, 0)
RETURNING id
`

type createCustomActionParams struct {
	ID       string         `json:"id"`
	Name     string         `json:"name"`
	Metadata sql.NullString `json:"metadata"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO actions (id, name, metadata, is_standard)
//	VALUES (?1, ?2, ?3, 0)
//	RETURNING id
func (q *Queries) createCustomAction(ctx context.Context, arg createCustomActionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createCustomAction, arg.ID, arg.Name, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteCustomAction = `-- name: deleteCustomAction :execrows
DELETE FROM actions
WHERE id = ?1
  AND is_standard = 0
`

// deleteCustomAction
//
//	DELETE FROM actions
//	WHERE id = ?1
//	  AND is_standard = 0
func (q *Queries) deleteCustomAction(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomAction, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAction = `-- name: getAction :one
SELECT
    id,
    name,
    is_standard,
    json_object(
        'labels', json_extract(metadata, '$.labels'),
        'created_at', created_at,
        'updated_at', updated_at
    ) AS metadata
FROM actions a
WHERE
  (?1 IS NULL OR a.id = ?1)
  AND (?2 IS NULL OR a.name = ?2)
`

type getActionParams struct {
	ID   interface{} `json:"id"`
	Name interface{} `json:"name"`
}

type getActionRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	IsStandard int64       `json:"is_standard"`
	Metadata   interface{} `json:"metadata"`
}

// getAction
//
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    json_object(
//	        'labels', json_extract(metadata, '$.labels'),
//	        'created_at', created_at,
//	        'updated_at', updated_at
//	    ) AS metadata
//	FROM actions a
//	WHERE
//	  (?1 IS NULL OR a.id = ?1)
//	  AND (?2 IS NULL OR a.name = ?2)
func (q *Queries) getAction(ctx context.Context, arg getActionParams) (getActionRow, error) {
	row := q.db.QueryRowContext(ctx, getAction, arg.ID, arg.Name)
	var i getActionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsStandard,
		&i.Metadata,
	)
	return i, err
}

const getActionsByNames = `-- name: getActionsByNames :many
SELECT
    id,
    name,
    is_standard,
    json_object(
        'labels', json_extract(metadata, '$.labels'),
        'created_at', created_at,
        'updated_at', updated_at
    ) AS metadata
FROM actions
WHERE LOWER(name) IN (SELECT LOWER(value) FROM json_each(@action_names))
`

type getActionsByNamesRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	IsStandard int64       `json:"is_standard"`
	Metadata   interface{} `json:"metadata"`
}

// Note: Uses json_each instead of unnest for array matching
//
//	SELECT
//	    id,
//	    name,
//	    is_standard,
//	    json_object(
//	        'labels', json_extract(metadata, '$.labels'),
//	        'created_at', created_at,
//	        'updated_at', updated_at
//	    ) AS metadata
//	FROM actions
//	WHERE LOWER(name) IN (SELECT LOWER(value) FROM json_each(@action_names))
func (q *Queries) getActionsByNames(ctx context.Context) ([]getActionsByNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, getActionsByNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getActionsByNamesRow
	for rows.Next() {
		var i getActionsByNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsStandard,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActions = `-- name: listActions :many

WITH counted AS (
    SELECT COUNT(id) AS total FROM actions
)
SELECT
    a.id,
    a.name,
    json_object(
        'labels', json_extract(a.metadata, '$.labels'),
        'created_at', a.created_at,
        'updated_at', a.updated_at
    ) as metadata,
    a.is_standard,
    counted.total
FROM actions a
CROSS JOIN counted
LIMIT ?2
OFFSET ?1
`

type listActionsParams struct {
	Offset int64 `json:"offset_"`
	Limit  int64 `json:"limit_"`
}

type listActionsRow struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	Metadata   interface{} `json:"metadata"`
	IsStandard int64       `json:"is_standard"`
	Total      int64       `json:"total"`
}

// --------------------------------------------------------------
// ACTIONS (SQLite)
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(id) AS total FROM actions
//	)
//	SELECT
//	    a.id,
//	    a.name,
//	    json_object(
//	        'labels', json_extract(a.metadata, '$.labels'),
//	        'created_at', a.created_at,
//	        'updated_at', a.updated_at
//	    ) as metadata,
//	    a.is_standard,
//	    counted.total
//	FROM actions a
//	CROSS JOIN counted
//	LIMIT ?2
//	OFFSET ?1
func (q *Queries) listActions(ctx context.Context, arg listActionsParams) ([]listActionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listActions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listActionsRow
	for rows.Next() {
		var i listActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.IsStandard,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomAction = `-- name: updateCustomAction :execrows
UPDATE actions
SET
    name = COALESCE(?1, name),
    metadata = COALESCE(?2, metadata)
WHERE id = ?3
  AND is_standard = 0
`

type updateCustomActionParams struct {
	Name     sql.NullString `json:"name"`
	Metadata sql.NullString `json:"metadata"`
	ID       string         `json:"id"`
}

// updateCustomAction
//
//	UPDATE actions
//	SET
//	    name = COALESCE(?1, name),
//	    metadata = COALESCE(?2, metadata)
//	WHERE id = ?3
//	  AND is_standard = 0
func (q *Queries) updateCustomAction(ctx context.Context, arg updateCustomActionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomAction, arg.Name, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
