// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute_fqn.sql

package sqlite

import (
	"context"
	"database/sql"
)

const getDefinitionFqnsByNamespace = `-- name: getDefinitionFqnsByNamespace :many
SELECT
    ad.id AS attribute_id,
    ns.id AS namespace_id,
    'https://' || ns.name || '/attr/' || ad.name AS fqn
FROM attribute_definitions ad
JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
WHERE ns.id = ?1
`

type getDefinitionFqnsByNamespaceRow struct {
	AttributeID string      `json:"attribute_id"`
	NamespaceID string      `json:"namespace_id"`
	Fqn         interface{} `json:"fqn"`
}

// Helper to get all definition FQNs for a namespace
//
//	SELECT
//	    ad.id AS attribute_id,
//	    ns.id AS namespace_id,
//	    'https://' || ns.name || '/attr/' || ad.name AS fqn
//	FROM attribute_definitions ad
//	JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	WHERE ns.id = ?1
func (q *Queries) getDefinitionFqnsByNamespace(ctx context.Context, namespaceID string) ([]getDefinitionFqnsByNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, getDefinitionFqnsByNamespace, namespaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getDefinitionFqnsByNamespaceRow
	for rows.Next() {
		var i getDefinitionFqnsByNamespaceRow
		if err := rows.Scan(&i.AttributeID, &i.NamespaceID, &i.Fqn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueFqnsByDefinition = `-- name: getValueFqnsByDefinition :many
SELECT
    av.id AS value_id,
    ns.id AS namespace_id,
    ad.id AS attribute_id,
    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value AS fqn
FROM attribute_values av
JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
WHERE ad.id = ?1
`

type getValueFqnsByDefinitionRow struct {
	ValueID     string      `json:"value_id"`
	NamespaceID string      `json:"namespace_id"`
	AttributeID string      `json:"attribute_id"`
	Fqn         interface{} `json:"fqn"`
}

// Helper to get all value FQNs for a definition (used to upsert after definition update)
//
//	SELECT
//	    av.id AS value_id,
//	    ns.id AS namespace_id,
//	    ad.id AS attribute_id,
//	    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value AS fqn
//	FROM attribute_values av
//	JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	WHERE ad.id = ?1
func (q *Queries) getValueFqnsByDefinition(ctx context.Context, attributeID string) ([]getValueFqnsByDefinitionRow, error) {
	rows, err := q.db.QueryContext(ctx, getValueFqnsByDefinition, attributeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getValueFqnsByDefinitionRow
	for rows.Next() {
		var i getValueFqnsByDefinitionRow
		if err := rows.Scan(
			&i.ValueID,
			&i.NamespaceID,
			&i.AttributeID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueFqnsByNamespace = `-- name: getValueFqnsByNamespace :many
SELECT
    av.id AS value_id,
    ad.id AS attribute_id,
    ns.id AS namespace_id,
    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value AS fqn
FROM attribute_values av
JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
WHERE ns.id = ?1
`

type getValueFqnsByNamespaceRow struct {
	ValueID     string      `json:"value_id"`
	AttributeID string      `json:"attribute_id"`
	NamespaceID string      `json:"namespace_id"`
	Fqn         interface{} `json:"fqn"`
}

// Helper to get all value FQNs for a namespace
//
//	SELECT
//	    av.id AS value_id,
//	    ad.id AS attribute_id,
//	    ns.id AS namespace_id,
//	    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value AS fqn
//	FROM attribute_values av
//	JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	WHERE ns.id = ?1
func (q *Queries) getValueFqnsByNamespace(ctx context.Context, namespaceID string) ([]getValueFqnsByNamespaceRow, error) {
	rows, err := q.db.QueryContext(ctx, getValueFqnsByNamespace, namespaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getValueFqnsByNamespaceRow
	for rows.Next() {
		var i getValueFqnsByNamespaceRow
		if err := rows.Scan(
			&i.ValueID,
			&i.AttributeID,
			&i.NamespaceID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAttributeDefinitionFqn = `-- name: upsertAttributeDefinitionFqn :one
INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
SELECT
    ?1,
    ns.id,
    ad.id,
    NULL,
    'https://' || ns.name || '/attr/' || ad.name
FROM attribute_definitions ad
JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
WHERE ad.id = ?2
ON CONFLICT (namespace_id, attribute_id, value_id)
    DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING namespace_id, attribute_id, COALESCE(value_id, '') AS value_id, fqn
`

type upsertAttributeDefinitionFqnParams struct {
	ID          string `json:"id"`
	AttributeID string `json:"attribute_id"`
}

type upsertAttributeDefinitionFqnRow struct {
	NamespaceID string         `json:"namespace_id"`
	AttributeID sql.NullString `json:"attribute_id"`
	ValueID     string         `json:"value_id"`
	Fqn         string         `json:"fqn"`
}

// Note: ID generated in application layer. Values FQNs inserted separately.
//
//	INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    ?1,
//	    ns.id,
//	    ad.id,
//	    NULL,
//	    'https://' || ns.name || '/attr/' || ad.name
//	FROM attribute_definitions ad
//	JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	WHERE ad.id = ?2
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING namespace_id, attribute_id, COALESCE(value_id, '') AS value_id, fqn
func (q *Queries) upsertAttributeDefinitionFqn(ctx context.Context, arg upsertAttributeDefinitionFqnParams) (upsertAttributeDefinitionFqnRow, error) {
	row := q.db.QueryRowContext(ctx, upsertAttributeDefinitionFqn, arg.ID, arg.AttributeID)
	var i upsertAttributeDefinitionFqnRow
	err := row.Scan(
		&i.NamespaceID,
		&i.AttributeID,
		&i.ValueID,
		&i.Fqn,
	)
	return i, err
}

const upsertAttributeNamespaceFqn = `-- name: upsertAttributeNamespaceFqn :one
INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
SELECT
    ?1,
    ns.id,
    NULL,
    NULL,
    'https://' || ns.name
FROM attribute_namespaces ns
WHERE ns.id = ?2
ON CONFLICT (namespace_id, attribute_id, value_id)
    DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING namespace_id, COALESCE(attribute_id, '') AS attribute_id, COALESCE(value_id, '') AS value_id, fqn
`

type upsertAttributeNamespaceFqnParams struct {
	ID          string `json:"id"`
	NamespaceID string `json:"namespace_id"`
}

type upsertAttributeNamespaceFqnRow struct {
	NamespaceID string `json:"namespace_id"`
	AttributeID string `json:"attribute_id"`
	ValueID     string `json:"value_id"`
	Fqn         string `json:"fqn"`
}

// Note: ID generated in application layer. Definition/Value FQNs inserted separately.
//
//	INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    ?1,
//	    ns.id,
//	    NULL,
//	    NULL,
//	    'https://' || ns.name
//	FROM attribute_namespaces ns
//	WHERE ns.id = ?2
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING namespace_id, COALESCE(attribute_id, '') AS attribute_id, COALESCE(value_id, '') AS value_id, fqn
func (q *Queries) upsertAttributeNamespaceFqn(ctx context.Context, arg upsertAttributeNamespaceFqnParams) (upsertAttributeNamespaceFqnRow, error) {
	row := q.db.QueryRowContext(ctx, upsertAttributeNamespaceFqn, arg.ID, arg.NamespaceID)
	var i upsertAttributeNamespaceFqnRow
	err := row.Scan(
		&i.NamespaceID,
		&i.AttributeID,
		&i.ValueID,
		&i.Fqn,
	)
	return i, err
}

const upsertAttributeValueFqn = `-- name: upsertAttributeValueFqn :one

INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
SELECT
    ?1,
    ns.id,
    ad.id,
    av.id,
    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value
FROM attribute_values av
INNER JOIN attribute_definitions AS ad ON av.attribute_definition_id = ad.id
INNER JOIN attribute_namespaces AS ns ON ad.namespace_id = ns.id
WHERE av.id = ?2
ON CONFLICT (namespace_id, attribute_id, value_id)
    DO UPDATE SET fqn = EXCLUDED.fqn
RETURNING namespace_id, attribute_id, value_id, fqn
`

type upsertAttributeValueFqnParams struct {
	ID      string `json:"id"`
	ValueID string `json:"value_id"`
}

type upsertAttributeValueFqnRow struct {
	NamespaceID string         `json:"namespace_id"`
	AttributeID sql.NullString `json:"attribute_id"`
	ValueID     sql.NullString `json:"value_id"`
	Fqn         string         `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTE FQN (SQLite)
// Note: UUID generation handled in application layer
// These queries use INSERT OR REPLACE for upsert semantics
// --------------------------------------------------------------
// Note: ID generated in application layer
//
//	INSERT INTO attribute_fqns (id, namespace_id, attribute_id, value_id, fqn)
//	SELECT
//	    ?1,
//	    ns.id,
//	    ad.id,
//	    av.id,
//	    'https://' || ns.name || '/attr/' || ad.name || '/value/' || av.value
//	FROM attribute_values av
//	INNER JOIN attribute_definitions AS ad ON av.attribute_definition_id = ad.id
//	INNER JOIN attribute_namespaces AS ns ON ad.namespace_id = ns.id
//	WHERE av.id = ?2
//	ON CONFLICT (namespace_id, attribute_id, value_id)
//	    DO UPDATE SET fqn = EXCLUDED.fqn
//	RETURNING namespace_id, attribute_id, value_id, fqn
func (q *Queries) upsertAttributeValueFqn(ctx context.Context, arg upsertAttributeValueFqnParams) (upsertAttributeValueFqnRow, error) {
	row := q.db.QueryRowContext(ctx, upsertAttributeValueFqn, arg.ID, arg.ValueID)
	var i upsertAttributeValueFqnRow
	err := row.Scan(
		&i.NamespaceID,
		&i.AttributeID,
		&i.ValueID,
		&i.Fqn,
	)
	return i, err
}
