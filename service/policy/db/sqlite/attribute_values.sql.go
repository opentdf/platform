// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attribute_values.sql

package sqlite

import (
	"context"
	"database/sql"
)

const assignPublicKeyToAttributeValue = `-- name: assignPublicKeyToAttributeValue :one
INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
VALUES (?1, ?2)
RETURNING value_id, key_access_server_key_id
`

type assignPublicKeyToAttributeValueParams struct {
	ValueID              string `json:"value_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// assignPublicKeyToAttributeValue
//
//	INSERT INTO attribute_value_public_key_map (value_id, key_access_server_key_id)
//	VALUES (?1, ?2)
//	RETURNING value_id, key_access_server_key_id
func (q *Queries) assignPublicKeyToAttributeValue(ctx context.Context, arg assignPublicKeyToAttributeValueParams) (AttributeValuePublicKeyMap, error) {
	row := q.db.QueryRowContext(ctx, assignPublicKeyToAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	var i AttributeValuePublicKeyMap
	err := row.Scan(&i.ValueID, &i.KeyAccessServerKeyID)
	return i, err
}

const createAttributeValue = `-- name: createAttributeValue :one
INSERT INTO attribute_values (id, attribute_definition_id, value, metadata)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type createAttributeValueParams struct {
	ID                    string         `json:"id"`
	AttributeDefinitionID string         `json:"attribute_definition_id"`
	Value                 string         `json:"value"`
	Metadata              sql.NullString `json:"metadata"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO attribute_values (id, attribute_definition_id, value, metadata)
//	VALUES (?1, ?2, ?3, ?4)
//	RETURNING id
func (q *Queries) createAttributeValue(ctx context.Context, arg createAttributeValueParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createAttributeValue,
		arg.ID,
		arg.AttributeDefinitionID,
		arg.Value,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAttributeValue = `-- name: deleteAttributeValue :execrows
DELETE FROM attribute_values WHERE id = ?1
`

// deleteAttributeValue
//
//	DELETE FROM attribute_values WHERE id = ?1
func (q *Queries) deleteAttributeValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAttributeValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAttributeValue = `-- name: getAttributeValue :one
SELECT
    av.id,
    av.value,
    av.active,
    json_object(
        'labels', json_extract(av.metadata, '$.labels'),
        'created_at', av.created_at,
        'updated_at', av.updated_at
    ) as metadata,
    av.attribute_definition_id,
    fqns.fqn,
    -- Grants as correlated subquery
    (
        SELECT json_group_array(
            json_object(
                'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
        )
        FROM attribute_value_key_access_grants avkag
        JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
        WHERE avkag.attribute_value_id = av.id
    ) AS grants,
    -- Keys as correlated subquery
    (
        SELECT json_group_array(
            json_object(
                'kas_uri', kas.uri,
                'kas_id', kas.id,
                'public_key', json_object(
                    'algorithm', kask.key_algorithm,
                    'kid', kask.key_id,
                    'pem', json_extract(kask.public_key_ctx, '$.pem')
                )
            )
        )
        FROM attribute_value_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kas.id = kask.key_access_server_id
        WHERE k.value_id = av.id
    ) AS keys,
    -- Obligations fetched separately in app layer for SQLite
    NULL AS obligations
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
WHERE (?1 IS NULL OR av.id = ?1)
  AND (?2 IS NULL OR REPLACE(REPLACE(fqns.fqn, 'https://', ''), 'http://', '') = REPLACE(REPLACE(?2, 'https://', ''), 'http://', ''))
`

type getAttributeValueParams struct {
	ID  interface{} `json:"id"`
	Fqn interface{} `json:"fqn"`
}

type getAttributeValueRow struct {
	ID                    string         `json:"id"`
	Value                 string         `json:"value"`
	Active                int64          `json:"active"`
	Metadata              interface{}    `json:"metadata"`
	AttributeDefinitionID string         `json:"attribute_definition_id"`
	Fqn                   sql.NullString `json:"fqn"`
	Grants                interface{}    `json:"grants"`
	Keys                  interface{}    `json:"keys"`
	Obligations           interface{}    `json:"obligations"`
}

// Note: SQLite version - complex obligation aggregations handled separately
//
//	SELECT
//	    av.id,
//	    av.value,
//	    av.active,
//	    json_object(
//	        'labels', json_extract(av.metadata, '$.labels'),
//	        'created_at', av.created_at,
//	        'updated_at', av.updated_at
//	    ) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn,
//	    -- Grants as correlated subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//	        )
//	        FROM attribute_value_key_access_grants avkag
//	        JOIN key_access_servers kas ON avkag.key_access_server_id = kas.id
//	        WHERE avkag.attribute_value_id = av.id
//	    ) AS grants,
//	    -- Keys as correlated subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'kas_uri', kas.uri,
//	                'kas_id', kas.id,
//	                'public_key', json_object(
//	                    'algorithm', kask.key_algorithm,
//	                    'kid', kask.key_id,
//	                    'pem', json_extract(kask.public_key_ctx, '$.pem')
//	                )
//	            )
//	        )
//	        FROM attribute_value_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kas.id = kask.key_access_server_id
//	        WHERE k.value_id = av.id
//	    ) AS keys,
//	    -- Obligations fetched separately in app layer for SQLite
//	    NULL AS obligations
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	WHERE (?1 IS NULL OR av.id = ?1)
//	  AND (?2 IS NULL OR REPLACE(REPLACE(fqns.fqn, 'https://', ''), 'http://', '') = REPLACE(REPLACE(?2, 'https://', ''), 'http://', ''))
func (q *Queries) getAttributeValue(ctx context.Context, arg getAttributeValueParams) (getAttributeValueRow, error) {
	row := q.db.QueryRowContext(ctx, getAttributeValue, arg.ID, arg.Fqn)
	var i getAttributeValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Active,
		&i.Metadata,
		&i.AttributeDefinitionID,
		&i.Fqn,
		&i.Grants,
		&i.Keys,
		&i.Obligations,
	)
	return i, err
}

const listAttributeValues = `-- name: listAttributeValues :many

SELECT
    COUNT(*) OVER() AS total,
    av.id,
    av.value,
    av.active,
    json_object(
        'labels', json_extract(av.metadata, '$.labels'),
        'created_at', av.created_at,
        'updated_at', av.updated_at
    ) as metadata,
    av.attribute_definition_id,
    fqns.fqn
FROM attribute_values av
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
WHERE (
    (?1 IS NULL OR av.active = ?1) AND
    (NULLIF(?2, '') IS NULL OR av.attribute_definition_id = ?2)
)
LIMIT ?4
OFFSET ?3
`

type listAttributeValuesParams struct {
	Active                interface{} `json:"active"`
	AttributeDefinitionID interface{} `json:"attribute_definition_id"`
	Offset                int64       `json:"offset_"`
	Limit                 int64       `json:"limit_"`
}

type listAttributeValuesRow struct {
	Total                 int64          `json:"total"`
	ID                    string         `json:"id"`
	Value                 string         `json:"value"`
	Active                int64          `json:"active"`
	Metadata              interface{}    `json:"metadata"`
	AttributeDefinitionID string         `json:"attribute_definition_id"`
	Fqn                   sql.NullString `json:"fqn"`
}

// --------------------------------------------------------------
// ATTRIBUTE VALUES (SQLite)
// --------------------------------------------------------------
//
//	SELECT
//	    COUNT(*) OVER() AS total,
//	    av.id,
//	    av.value,
//	    av.active,
//	    json_object(
//	        'labels', json_extract(av.metadata, '$.labels'),
//	        'created_at', av.created_at,
//	        'updated_at', av.updated_at
//	    ) as metadata,
//	    av.attribute_definition_id,
//	    fqns.fqn
//	FROM attribute_values av
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	WHERE (
//	    (?1 IS NULL OR av.active = ?1) AND
//	    (NULLIF(?2, '') IS NULL OR av.attribute_definition_id = ?2)
//	)
//	LIMIT ?4
//	OFFSET ?3
func (q *Queries) listAttributeValues(ctx context.Context, arg listAttributeValuesParams) ([]listAttributeValuesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributeValues,
		arg.Active,
		arg.AttributeDefinitionID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listAttributeValuesRow
	for rows.Next() {
		var i listAttributeValuesRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.Value,
			&i.Active,
			&i.Metadata,
			&i.AttributeDefinitionID,
			&i.Fqn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttributeValue = `-- name: removeKeyAccessServerFromAttributeValue :execrows
DELETE FROM attribute_value_key_access_grants
WHERE attribute_value_id = ?1 AND key_access_server_id = ?2
`

type removeKeyAccessServerFromAttributeValueParams struct {
	AttributeValueID  string `json:"attribute_value_id"`
	KeyAccessServerID string `json:"key_access_server_id"`
}

// removeKeyAccessServerFromAttributeValue
//
//	DELETE FROM attribute_value_key_access_grants
//	WHERE attribute_value_id = ?1 AND key_access_server_id = ?2
func (q *Queries) removeKeyAccessServerFromAttributeValue(ctx context.Context, arg removeKeyAccessServerFromAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeKeyAccessServerFromAttributeValue, arg.AttributeValueID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removePublicKeyFromAttributeValue = `-- name: removePublicKeyFromAttributeValue :execrows
DELETE FROM attribute_value_public_key_map
WHERE value_id = ?1 AND key_access_server_key_id = ?2
`

type removePublicKeyFromAttributeValueParams struct {
	ValueID              string `json:"value_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// removePublicKeyFromAttributeValue
//
//	DELETE FROM attribute_value_public_key_map
//	WHERE value_id = ?1 AND key_access_server_key_id = ?2
func (q *Queries) removePublicKeyFromAttributeValue(ctx context.Context, arg removePublicKeyFromAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removePublicKeyFromAttributeValue, arg.ValueID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rotatePublicKeyForAttributeValue = `-- name: rotatePublicKeyForAttributeValue :many
UPDATE attribute_value_public_key_map
SET key_access_server_key_id = ?1
WHERE (key_access_server_key_id = ?2)
RETURNING value_id
`

type rotatePublicKeyForAttributeValueParams struct {
	NewKeyID string `json:"new_key_id"`
	OldKeyID string `json:"old_key_id"`
}

// rotatePublicKeyForAttributeValue
//
//	UPDATE attribute_value_public_key_map
//	SET key_access_server_key_id = ?1
//	WHERE (key_access_server_key_id = ?2)
//	RETURNING value_id
func (q *Queries) rotatePublicKeyForAttributeValue(ctx context.Context, arg rotatePublicKeyForAttributeValueParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, rotatePublicKeyForAttributeValue, arg.NewKeyID, arg.OldKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var value_id string
		if err := rows.Scan(&value_id); err != nil {
			return nil, err
		}
		items = append(items, value_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttributeValue = `-- name: updateAttributeValue :execrows
UPDATE attribute_values
SET
    value = COALESCE(?1, value),
    active = COALESCE(?2, active),
    metadata = COALESCE(?3, metadata)
WHERE id = ?4
`

type updateAttributeValueParams struct {
	Value    sql.NullString `json:"value"`
	Active   sql.NullInt64  `json:"active"`
	Metadata sql.NullString `json:"metadata"`
	ID       string         `json:"id"`
}

// updateAttributeValue: Safe and Unsafe Updates both
//
//	UPDATE attribute_values
//	SET
//	    value = COALESCE(?1, value),
//	    active = COALESCE(?2, active),
//	    metadata = COALESCE(?3, metadata)
//	WHERE id = ?4
func (q *Queries) updateAttributeValue(ctx context.Context, arg updateAttributeValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAttributeValue,
		arg.Value,
		arg.Active,
		arg.Metadata,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
