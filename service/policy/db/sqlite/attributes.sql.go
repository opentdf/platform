// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attributes.sql

package sqlite

import (
	"context"
	"database/sql"
)

const assignPublicKeyToAttributeDefinition = `-- name: assignPublicKeyToAttributeDefinition :one
INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
VALUES (?1, ?2)
RETURNING definition_id, key_access_server_key_id
`

type assignPublicKeyToAttributeDefinitionParams struct {
	DefinitionID         string `json:"definition_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// assignPublicKeyToAttributeDefinition
//
//	INSERT INTO attribute_definition_public_key_map (definition_id, key_access_server_key_id)
//	VALUES (?1, ?2)
//	RETURNING definition_id, key_access_server_key_id
func (q *Queries) assignPublicKeyToAttributeDefinition(ctx context.Context, arg assignPublicKeyToAttributeDefinitionParams) (AttributeDefinitionPublicKeyMap, error) {
	row := q.db.QueryRowContext(ctx, assignPublicKeyToAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	var i AttributeDefinitionPublicKeyMap
	err := row.Scan(&i.DefinitionID, &i.KeyAccessServerKeyID)
	return i, err
}

const createAttribute = `-- name: createAttribute :one
INSERT INTO attribute_definitions (id, namespace_id, name, rule, metadata)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id
`

type createAttributeParams struct {
	ID          string         `json:"id"`
	NamespaceID string         `json:"namespace_id"`
	Name        string         `json:"name"`
	Rule        string         `json:"rule"`
	Metadata    sql.NullString `json:"metadata"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO attribute_definitions (id, namespace_id, name, rule, metadata)
//	VALUES (?1, ?2, ?3, ?4, ?5)
//	RETURNING id
func (q *Queries) createAttribute(ctx context.Context, arg createAttributeParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createAttribute,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Rule,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAttribute = `-- name: deleteAttribute :execrows
DELETE FROM attribute_definitions WHERE id = ?1
`

// deleteAttribute
//
//	DELETE FROM attribute_definitions WHERE id = ?1
func (q *Queries) deleteAttribute(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAttribute, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAttribute = `-- name: getAttribute :one
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    json_object(
        'labels', json_extract(ad.metadata, '$.labels'),
        'created_at', ad.created_at,
        'updated_at', ad.updated_at
    ) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    -- Values as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', av.id,
                'value', av.value,
                'active', av.active,
                'fqn', fqns.fqn || '/value/' || av.value
            )
        )
        FROM attribute_values av
        WHERE av.attribute_definition_id = ad.id
    ) AS "values",
    -- Grants as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
        )
        FROM attribute_definition_key_access_grants adkag
        JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
        WHERE adkag.attribute_definition_id = ad.id
    ) AS grants,
    fqns.fqn,
    -- Keys simplified
    (
        SELECT json_group_array(
            json_object(
                'kas_uri', kas.uri,
                'kas_id', kas.id,
                'public_key', json_object(
                    'algorithm', kask.key_algorithm,
                    'kid', kask.key_id,
                    'pem', json_extract(kask.public_key_ctx, '$.pem')
                )
            )
        )
        FROM attribute_definition_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        WHERE k.definition_id = ad.id
    ) AS keys
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE (?1 IS NULL OR ad.id = ?1)
  AND (?2 IS NULL OR REPLACE(REPLACE(fqns.fqn, 'https://', ''), 'http://', '') = REPLACE(REPLACE(?2, 'https://', ''), 'http://', ''))
GROUP BY ad.id, n.name, fqns.fqn
`

type getAttributeParams struct {
	ID  interface{} `json:"id"`
	Fqn interface{} `json:"fqn"`
}

type getAttributeRow struct {
	ID            string         `json:"id"`
	AttributeName string         `json:"attribute_name"`
	Rule          string         `json:"rule"`
	Metadata      interface{}    `json:"metadata"`
	NamespaceID   string         `json:"namespace_id"`
	Active        int64          `json:"active"`
	NamespaceName sql.NullString `json:"namespace_name"`
	Values        interface{}    `json:"values"`
	Grants        interface{}    `json:"grants"`
	Fqn           sql.NullString `json:"fqn"`
	Keys          interface{}    `json:"keys"`
}

// getAttribute
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    json_object(
//	        'labels', json_extract(ad.metadata, '$.labels'),
//	        'created_at', ad.created_at,
//	        'updated_at', ad.updated_at
//	    ) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    -- Values as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', av.id,
//	                'value', av.value,
//	                'active', av.active,
//	                'fqn', fqns.fqn || '/value/' || av.value
//	            )
//	        )
//	        FROM attribute_values av
//	        WHERE av.attribute_definition_id = ad.id
//	    ) AS "values",
//	    -- Grants as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//	        )
//	        FROM attribute_definition_key_access_grants adkag
//	        JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
//	        WHERE adkag.attribute_definition_id = ad.id
//	    ) AS grants,
//	    fqns.fqn,
//	    -- Keys simplified
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'kas_uri', kas.uri,
//	                'kas_id', kas.id,
//	                'public_key', json_object(
//	                    'algorithm', kask.key_algorithm,
//	                    'kid', kask.key_id,
//	                    'pem', json_extract(kask.public_key_ctx, '$.pem')
//	                )
//	            )
//	        )
//	        FROM attribute_definition_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        WHERE k.definition_id = ad.id
//	    ) AS keys
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE (?1 IS NULL OR ad.id = ?1)
//	  AND (?2 IS NULL OR REPLACE(REPLACE(fqns.fqn, 'https://', ''), 'http://', '') = REPLACE(REPLACE(?2, 'https://', ''), 'http://', ''))
//	GROUP BY ad.id, n.name, fqns.fqn
func (q *Queries) getAttribute(ctx context.Context, arg getAttributeParams) (getAttributeRow, error) {
	row := q.db.QueryRowContext(ctx, getAttribute, arg.ID, arg.Fqn)
	var i getAttributeRow
	err := row.Scan(
		&i.ID,
		&i.AttributeName,
		&i.Rule,
		&i.Metadata,
		&i.NamespaceID,
		&i.Active,
		&i.NamespaceName,
		&i.Values,
		&i.Grants,
		&i.Fqn,
		&i.Keys,
	)
	return i, err
}

const listAttributesByDefOrValueFqns = `-- name: listAttributesByDefOrValueFqns :many
WITH target_definition AS (
    SELECT DISTINCT
        ad.id,
        ad.namespace_id,
        ad.name,
        ad.rule,
        ad.active,
        ad.values_order
    FROM attribute_fqns fqns
    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
    WHERE fqns.fqn IN (SELECT value FROM json_each(@fqns))
        AND ad.active = 1
    GROUP BY ad.id
),
namespaces AS (
    SELECT
        n.id,
        json_object(
            'id', n.id,
            'name', n.name,
            'active', n.active,
            'fqn', fqns.fqn
        ) AS namespace
    FROM target_definition td
    INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
    INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
    WHERE n.active = 1
        AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
    GROUP BY n.id, fqns.fqn
)
SELECT
    td.id,
    td.name,
    td.rule,
    td.active,
    n.namespace,
    fqns.fqn,
    -- Values fetched in app layer for proper ordering
    (
        SELECT json_group_array(
            json_object(
                'id', av.id,
                'value', av.value,
                'active', av.active,
                'fqn', vfqns.fqn
            )
        )
        FROM attribute_values av
        LEFT JOIN attribute_fqns vfqns ON av.id = vfqns.value_id
        WHERE av.attribute_definition_id = td.id AND av.active = 1
    ) AS "values",
    -- Grants as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', kas.id,
                'uri', kas.uri,
                'name', kas.name,
                'public_key', kas.public_key
            )
        )
        FROM attribute_definition_key_access_grants adkag
        JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
        WHERE adkag.attribute_definition_id = td.id
    ) AS grants,
    -- Keys simplified, full details in app layer
    (
        SELECT json_group_array(
            json_object(
                'kas_uri', kas.uri,
                'kas_id', kas.id,
                'public_key', json_object(
                    'algorithm', kask.key_algorithm,
                    'kid', kask.key_id,
                    'pem', json_extract(kask.public_key_ctx, '$.pem')
                )
            )
        )
        FROM attribute_definition_public_key_map k
        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
        WHERE k.definition_id = td.id
    ) AS keys
FROM target_definition td
INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
INNER JOIN namespaces n ON td.namespace_id = n.id
WHERE fqns.value_id IS NULL
`

type listAttributesByDefOrValueFqnsRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Rule      string      `json:"rule"`
	Active    int64       `json:"active"`
	Namespace interface{} `json:"namespace"`
	Fqn       string      `json:"fqn"`
	Values    interface{} `json:"values"`
	Grants    interface{} `json:"grants"`
	Keys      interface{} `json:"keys"`
}

// Note: SQLite version - complex query simplified, some data fetched in app layer
// Uses json_each instead of ANY() for array matching
//
//	WITH target_definition AS (
//	    SELECT DISTINCT
//	        ad.id,
//	        ad.namespace_id,
//	        ad.name,
//	        ad.rule,
//	        ad.active,
//	        ad.values_order
//	    FROM attribute_fqns fqns
//	    INNER JOIN attribute_definitions ad ON fqns.attribute_id = ad.id
//	    WHERE fqns.fqn IN (SELECT value FROM json_each(@fqns))
//	        AND ad.active = 1
//	    GROUP BY ad.id
//	),
//	namespaces AS (
//	    SELECT
//	        n.id,
//	        json_object(
//	            'id', n.id,
//	            'name', n.name,
//	            'active', n.active,
//	            'fqn', fqns.fqn
//	        ) AS namespace
//	    FROM target_definition td
//	    INNER JOIN attribute_namespaces n ON td.namespace_id = n.id
//	    INNER JOIN attribute_fqns fqns ON n.id = fqns.namespace_id
//	    WHERE n.active = 1
//	        AND (fqns.attribute_id IS NULL AND fqns.value_id IS NULL)
//	    GROUP BY n.id, fqns.fqn
//	)
//	SELECT
//	    td.id,
//	    td.name,
//	    td.rule,
//	    td.active,
//	    n.namespace,
//	    fqns.fqn,
//	    -- Values fetched in app layer for proper ordering
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', av.id,
//	                'value', av.value,
//	                'active', av.active,
//	                'fqn', vfqns.fqn
//	            )
//	        )
//	        FROM attribute_values av
//	        LEFT JOIN attribute_fqns vfqns ON av.id = vfqns.value_id
//	        WHERE av.attribute_definition_id = td.id AND av.active = 1
//	    ) AS "values",
//	    -- Grants as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', kas.id,
//	                'uri', kas.uri,
//	                'name', kas.name,
//	                'public_key', kas.public_key
//	            )
//	        )
//	        FROM attribute_definition_key_access_grants adkag
//	        JOIN key_access_servers kas ON adkag.key_access_server_id = kas.id
//	        WHERE adkag.attribute_definition_id = td.id
//	    ) AS grants,
//	    -- Keys simplified, full details in app layer
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'kas_uri', kas.uri,
//	                'kas_id', kas.id,
//	                'public_key', json_object(
//	                    'algorithm', kask.key_algorithm,
//	                    'kid', kask.key_id,
//	                    'pem', json_extract(kask.public_key_ctx, '$.pem')
//	                )
//	            )
//	        )
//	        FROM attribute_definition_public_key_map k
//	        INNER JOIN key_access_server_keys kask ON k.key_access_server_key_id = kask.id
//	        INNER JOIN key_access_servers kas ON kask.key_access_server_id = kas.id
//	        WHERE k.definition_id = td.id
//	    ) AS keys
//	FROM target_definition td
//	INNER JOIN attribute_fqns fqns ON td.id = fqns.attribute_id
//	INNER JOIN namespaces n ON td.namespace_id = n.id
//	WHERE fqns.value_id IS NULL
func (q *Queries) listAttributesByDefOrValueFqns(ctx context.Context) ([]listAttributesByDefOrValueFqnsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesByDefOrValueFqns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listAttributesByDefOrValueFqnsRow
	for rows.Next() {
		var i listAttributesByDefOrValueFqnsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Rule,
			&i.Active,
			&i.Namespace,
			&i.Fqn,
			&i.Values,
			&i.Grants,
			&i.Keys,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesDetail = `-- name: listAttributesDetail :many

SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    json_object(
        'labels', json_extract(ad.metadata, '$.labels'),
        'created_at', ad.created_at,
        'updated_at', ad.updated_at
    ) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    -- Values aggregation with ordering via subquery
    (
        SELECT json_group_array(
            json_object(
                'id', av.id,
                'value', av.value,
                'active', av.active,
                'fqn', fqns.fqn || '/value/' || av.value
            )
        )
        FROM attribute_values av
        LEFT JOIN attribute_fqns fqns ON av.attribute_definition_id = fqns.attribute_id AND fqns.value_id IS NULL
        WHERE av.attribute_definition_id = ad.id
        -- Note: values_order is JSON array in SQLite, ordering handled in app layer
    ) AS "values",
    fqns.fqn,
    COUNT(*) OVER() AS total
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
WHERE
    (?1 IS NULL OR ad.active = ?1) AND
    (NULLIF(?2, '') IS NULL OR ad.namespace_id = ?2) AND
    (NULLIF(?3, '') IS NULL OR n.name = ?3)
GROUP BY ad.id, n.name, fqns.fqn
LIMIT ?5
OFFSET ?4
`

type listAttributesDetailParams struct {
	Active        interface{} `json:"active"`
	NamespaceID   interface{} `json:"namespace_id"`
	NamespaceName interface{} `json:"namespace_name"`
	Offset        int64       `json:"offset_"`
	Limit         int64       `json:"limit_"`
}

type listAttributesDetailRow struct {
	ID            string         `json:"id"`
	AttributeName string         `json:"attribute_name"`
	Rule          string         `json:"rule"`
	Metadata      interface{}    `json:"metadata"`
	NamespaceID   string         `json:"namespace_id"`
	Active        int64          `json:"active"`
	NamespaceName sql.NullString `json:"namespace_name"`
	Values        interface{}    `json:"values"`
	Fqn           sql.NullString `json:"fqn"`
	Total         int64          `json:"total"`
}

// --------------------------------------------------------------
// ATTRIBUTES (SQLite)
// --------------------------------------------------------------
// Note: SQLite version - values_order ordering handled differently
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    json_object(
//	        'labels', json_extract(ad.metadata, '$.labels'),
//	        'created_at', ad.created_at,
//	        'updated_at', ad.updated_at
//	    ) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    -- Values aggregation with ordering via subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', av.id,
//	                'value', av.value,
//	                'active', av.active,
//	                'fqn', fqns.fqn || '/value/' || av.value
//	            )
//	        )
//	        FROM attribute_values av
//	        LEFT JOIN attribute_fqns fqns ON av.attribute_definition_id = fqns.attribute_id AND fqns.value_id IS NULL
//	        WHERE av.attribute_definition_id = ad.id
//	        -- Note: values_order is JSON array in SQLite, ordering handled in app layer
//	    ) AS "values",
//	    fqns.fqn,
//	    COUNT(*) OVER() AS total
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	LEFT JOIN attribute_fqns fqns ON fqns.attribute_id = ad.id AND fqns.value_id IS NULL
//	WHERE
//	    (?1 IS NULL OR ad.active = ?1) AND
//	    (NULLIF(?2, '') IS NULL OR ad.namespace_id = ?2) AND
//	    (NULLIF(?3, '') IS NULL OR n.name = ?3)
//	GROUP BY ad.id, n.name, fqns.fqn
//	LIMIT ?5
//	OFFSET ?4
func (q *Queries) listAttributesDetail(ctx context.Context, arg listAttributesDetailParams) ([]listAttributesDetailRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesDetail,
		arg.Active,
		arg.NamespaceID,
		arg.NamespaceName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listAttributesDetailRow
	for rows.Next() {
		var i listAttributesDetailRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Values,
			&i.Fqn,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAttributesSummary = `-- name: listAttributesSummary :many
SELECT
    ad.id,
    ad.name as attribute_name,
    ad.rule,
    json_object(
        'labels', json_extract(ad.metadata, '$.labels'),
        'created_at', ad.created_at,
        'updated_at', ad.updated_at
    ) AS metadata,
    ad.namespace_id,
    ad.active,
    n.name as namespace_name,
    COUNT(*) OVER() AS total
FROM attribute_definitions ad
LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
WHERE ad.namespace_id = ?1
GROUP BY ad.id, n.name
LIMIT ?3
OFFSET ?2
`

type listAttributesSummaryParams struct {
	NamespaceID string `json:"namespace_id"`
	Offset      int64  `json:"offset_"`
	Limit       int64  `json:"limit_"`
}

type listAttributesSummaryRow struct {
	ID            string         `json:"id"`
	AttributeName string         `json:"attribute_name"`
	Rule          string         `json:"rule"`
	Metadata      interface{}    `json:"metadata"`
	NamespaceID   string         `json:"namespace_id"`
	Active        int64          `json:"active"`
	NamespaceName sql.NullString `json:"namespace_name"`
	Total         int64          `json:"total"`
}

// listAttributesSummary
//
//	SELECT
//	    ad.id,
//	    ad.name as attribute_name,
//	    ad.rule,
//	    json_object(
//	        'labels', json_extract(ad.metadata, '$.labels'),
//	        'created_at', ad.created_at,
//	        'updated_at', ad.updated_at
//	    ) AS metadata,
//	    ad.namespace_id,
//	    ad.active,
//	    n.name as namespace_name,
//	    COUNT(*) OVER() AS total
//	FROM attribute_definitions ad
//	LEFT JOIN attribute_namespaces n ON n.id = ad.namespace_id
//	WHERE ad.namespace_id = ?1
//	GROUP BY ad.id, n.name
//	LIMIT ?3
//	OFFSET ?2
func (q *Queries) listAttributesSummary(ctx context.Context, arg listAttributesSummaryParams) ([]listAttributesSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, listAttributesSummary, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listAttributesSummaryRow
	for rows.Next() {
		var i listAttributesSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeName,
			&i.Rule,
			&i.Metadata,
			&i.NamespaceID,
			&i.Active,
			&i.NamespaceName,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeKeyAccessServerFromAttribute = `-- name: removeKeyAccessServerFromAttribute :execrows
DELETE FROM attribute_definition_key_access_grants
WHERE attribute_definition_id = ?1 AND key_access_server_id = ?2
`

type removeKeyAccessServerFromAttributeParams struct {
	AttributeDefinitionID string `json:"attribute_definition_id"`
	KeyAccessServerID     string `json:"key_access_server_id"`
}

// removeKeyAccessServerFromAttribute
//
//	DELETE FROM attribute_definition_key_access_grants
//	WHERE attribute_definition_id = ?1 AND key_access_server_id = ?2
func (q *Queries) removeKeyAccessServerFromAttribute(ctx context.Context, arg removeKeyAccessServerFromAttributeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeKeyAccessServerFromAttribute, arg.AttributeDefinitionID, arg.KeyAccessServerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removePublicKeyFromAttributeDefinition = `-- name: removePublicKeyFromAttributeDefinition :execrows
DELETE FROM attribute_definition_public_key_map
WHERE definition_id = ?1 AND key_access_server_key_id = ?2
`

type removePublicKeyFromAttributeDefinitionParams struct {
	DefinitionID         string `json:"definition_id"`
	KeyAccessServerKeyID string `json:"key_access_server_key_id"`
}

// removePublicKeyFromAttributeDefinition
//
//	DELETE FROM attribute_definition_public_key_map
//	WHERE definition_id = ?1 AND key_access_server_key_id = ?2
func (q *Queries) removePublicKeyFromAttributeDefinition(ctx context.Context, arg removePublicKeyFromAttributeDefinitionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removePublicKeyFromAttributeDefinition, arg.DefinitionID, arg.KeyAccessServerKeyID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rotatePublicKeyForAttributeDefinition = `-- name: rotatePublicKeyForAttributeDefinition :many
UPDATE attribute_definition_public_key_map
SET key_access_server_key_id = ?1
WHERE (key_access_server_key_id = ?2)
RETURNING definition_id
`

type rotatePublicKeyForAttributeDefinitionParams struct {
	NewKeyID string `json:"new_key_id"`
	OldKeyID string `json:"old_key_id"`
}

// rotatePublicKeyForAttributeDefinition
//
//	UPDATE attribute_definition_public_key_map
//	SET key_access_server_key_id = ?1
//	WHERE (key_access_server_key_id = ?2)
//	RETURNING definition_id
func (q *Queries) rotatePublicKeyForAttributeDefinition(ctx context.Context, arg rotatePublicKeyForAttributeDefinitionParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, rotatePublicKeyForAttributeDefinition, arg.NewKeyID, arg.OldKeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var definition_id string
		if err := rows.Scan(&definition_id); err != nil {
			return nil, err
		}
		items = append(items, definition_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttribute = `-- name: updateAttribute :execrows
UPDATE attribute_definitions
SET
    name = COALESCE(?1, name),
    rule = COALESCE(?2, rule),
    values_order = COALESCE(?3, values_order),
    metadata = COALESCE(?4, metadata),
    active = COALESCE(?5, active)
WHERE id = ?6
`

type updateAttributeParams struct {
	Name        sql.NullString `json:"name"`
	Rule        sql.NullString `json:"rule"`
	ValuesOrder sql.NullString `json:"values_order"`
	Metadata    sql.NullString `json:"metadata"`
	Active      sql.NullInt64  `json:"active"`
	ID          string         `json:"id"`
}

// updateAttribute: Unsafe and Safe Updates both
//
//	UPDATE attribute_definitions
//	SET
//	    name = COALESCE(?1, name),
//	    rule = COALESCE(?2, rule),
//	    values_order = COALESCE(?3, values_order),
//	    metadata = COALESCE(?4, metadata),
//	    active = COALESCE(?5, active)
//	WHERE id = ?6
func (q *Queries) updateAttribute(ctx context.Context, arg updateAttributeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAttribute,
		arg.Name,
		arg.Rule,
		arg.ValuesOrder,
		arg.Metadata,
		arg.Active,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
