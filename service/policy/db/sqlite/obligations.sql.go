// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: obligations.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createObligation = `-- name: createObligation :one

INSERT INTO obligation_definitions (id, namespace_id, name, metadata)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type createObligationParams struct {
	ID          string         `json:"id"`
	NamespaceID string         `json:"namespace_id"`
	Name        string         `json:"name"`
	Metadata    sql.NullString `json:"metadata"`
}

// --------------------------------------------------------------
// OBLIGATIONS (SQLite)
// Note: Some complex multi-table inserts with UNNEST simplified
// App layer handles value insertion separately
// --------------------------------------------------------------
// Note: ID generated in application layer. Values created separately via createObligationValue
//
//	INSERT INTO obligation_definitions (id, namespace_id, name, metadata)
//	VALUES (?1, ?2, ?3, ?4)
//	RETURNING id
func (q *Queries) createObligation(ctx context.Context, arg createObligationParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createObligation,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createObligationTrigger = `-- name: createObligationTrigger :one

INSERT INTO obligation_triggers (id, obligation_value_id, action_id, attribute_value_id, metadata, client_id)
VALUES (?1, ?2, ?3, ?4, ?5, NULLIF(?6, ''))
RETURNING id
`

type createObligationTriggerParams struct {
	ID                string         `json:"id"`
	ObligationValueID string         `json:"obligation_value_id"`
	ActionID          string         `json:"action_id"`
	AttributeValueID  string         `json:"attribute_value_id"`
	Metadata          sql.NullString `json:"metadata"`
	ClientID          interface{}    `json:"client_id"`
}

// --------------------------------------------------------------
// OBLIGATION TRIGGERS (SQLite)
// --------------------------------------------------------------
// Note: ID generated in application layer before INSERT
//
//	INSERT INTO obligation_triggers (id, obligation_value_id, action_id, attribute_value_id, metadata, client_id)
//	VALUES (?1, ?2, ?3, ?4, ?5, NULLIF(?6, ''))
//	RETURNING id
func (q *Queries) createObligationTrigger(ctx context.Context, arg createObligationTriggerParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createObligationTrigger,
		arg.ID,
		arg.ObligationValueID,
		arg.ActionID,
		arg.AttributeValueID,
		arg.Metadata,
		arg.ClientID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createObligationValue = `-- name: createObligationValue :one

INSERT INTO obligation_values_standard (id, obligation_definition_id, value, metadata)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type createObligationValueParams struct {
	ID                     string         `json:"id"`
	ObligationDefinitionID string         `json:"obligation_definition_id"`
	Value                  string         `json:"value"`
	Metadata               sql.NullString `json:"metadata"`
}

// --------------------------------------------------------------
// OBLIGATION VALUES (SQLite)
// --------------------------------------------------------------
// Note: ID generated in application layer before INSERT
//
//	INSERT INTO obligation_values_standard (id, obligation_definition_id, value, metadata)
//	VALUES (?1, ?2, ?3, ?4)
//	RETURNING id
func (q *Queries) createObligationValue(ctx context.Context, arg createObligationValueParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createObligationValue,
		arg.ID,
		arg.ObligationDefinitionID,
		arg.Value,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllObligationTriggersForValue = `-- name: deleteAllObligationTriggersForValue :execrows
DELETE FROM obligation_triggers
WHERE obligation_value_id = ?1
`

// deleteAllObligationTriggersForValue
//
//	DELETE FROM obligation_triggers
//	WHERE obligation_value_id = ?1
func (q *Queries) deleteAllObligationTriggersForValue(ctx context.Context, obligationValueID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllObligationTriggersForValue, obligationValueID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteObligation = `-- name: deleteObligation :execrows
DELETE FROM obligation_definitions
WHERE id = ?1
`

// deleteObligation
//
//	DELETE FROM obligation_definitions
//	WHERE id = ?1
func (q *Queries) deleteObligation(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteObligation, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteObligationTrigger = `-- name: deleteObligationTrigger :execrows
DELETE FROM obligation_triggers
WHERE id = ?1
`

// deleteObligationTrigger
//
//	DELETE FROM obligation_triggers
//	WHERE id = ?1
func (q *Queries) deleteObligationTrigger(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteObligationTrigger, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteObligationValue = `-- name: deleteObligationValue :execrows
DELETE FROM obligation_values_standard
WHERE id = ?1
`

// deleteObligationValue
//
//	DELETE FROM obligation_values_standard
//	WHERE id = ?1
func (q *Queries) deleteObligationValue(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteObligationValue, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getObligation = `-- name: getObligation :one
SELECT
    od.id,
    od.name,
    json_object(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    json_object(
        'labels', json_extract(od.metadata, '$.labels'),
        'created_at', od.created_at,
        'updated_at', od.updated_at
    ) as metadata,
    -- Values with triggers as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', ov.id,
                'value', ov.value,
                'triggers', (
                    SELECT json_group_array(
                        json_object(
                            'id', ot.id,
                            'action', json_object('id', a.id, 'name', a.name),
                            'attribute_value', json_object(
                                'id', av.id,
                                'value', av.value,
                                'fqn', COALESCE(av_fqns.fqn, '')
                            ),
                            'context', CASE
                                WHEN ot.client_id IS NOT NULL THEN json_array(
                                    json_object('pep', json_object('client_id', ot.client_id))
                                )
                                ELSE json_array()
                            END
                        )
                    )
                    FROM obligation_triggers ot
                    JOIN actions a ON ot.action_id = a.id
                    JOIN attribute_values av ON ot.attribute_value_id = av.id
                    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
                    WHERE ot.obligation_value_id = ov.id
                )
            )
        )
        FROM obligation_values_standard ov
        WHERE ov.obligation_definition_id = od.id
    ) as "values"
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
WHERE
    (NULLIF(?1, '') IS NULL OR od.id = ?1)
    OR
    (NULLIF(?2, '') IS NOT NULL AND NULLIF(?3, '') IS NOT NULL
     AND fqns.fqn = ?2 AND od.name = ?3)
`

type getObligationParams struct {
	ID           interface{} `json:"id"`
	NamespaceFqn interface{} `json:"namespace_fqn"`
	Name         interface{} `json:"name"`
}

type getObligationRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Namespace interface{} `json:"namespace"`
	Metadata  interface{} `json:"metadata"`
	Values    interface{} `json:"values"`
}

// getObligation
//
//	SELECT
//	    od.id,
//	    od.name,
//	    json_object(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    json_object(
//	        'labels', json_extract(od.metadata, '$.labels'),
//	        'created_at', od.created_at,
//	        'updated_at', od.updated_at
//	    ) as metadata,
//	    -- Values with triggers as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', ov.id,
//	                'value', ov.value,
//	                'triggers', (
//	                    SELECT json_group_array(
//	                        json_object(
//	                            'id', ot.id,
//	                            'action', json_object('id', a.id, 'name', a.name),
//	                            'attribute_value', json_object(
//	                                'id', av.id,
//	                                'value', av.value,
//	                                'fqn', COALESCE(av_fqns.fqn, '')
//	                            ),
//	                            'context', CASE
//	                                WHEN ot.client_id IS NOT NULL THEN json_array(
//	                                    json_object('pep', json_object('client_id', ot.client_id))
//	                                )
//	                                ELSE json_array()
//	                            END
//	                        )
//	                    )
//	                    FROM obligation_triggers ot
//	                    JOIN actions a ON ot.action_id = a.id
//	                    JOIN attribute_values av ON ot.attribute_value_id = av.id
//	                    LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	                    WHERE ot.obligation_value_id = ov.id
//	                )
//	            )
//	        )
//	        FROM obligation_values_standard ov
//	        WHERE ov.obligation_definition_id = od.id
//	    ) as "values"
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	WHERE
//	    (NULLIF(?1, '') IS NULL OR od.id = ?1)
//	    OR
//	    (NULLIF(?2, '') IS NOT NULL AND NULLIF(?3, '') IS NOT NULL
//	     AND fqns.fqn = ?2 AND od.name = ?3)
func (q *Queries) getObligation(ctx context.Context, arg getObligationParams) (getObligationRow, error) {
	row := q.db.QueryRowContext(ctx, getObligation, arg.ID, arg.NamespaceFqn, arg.Name)
	var i getObligationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Values,
	)
	return i, err
}

const getObligationTrigger = `-- name: getObligationTrigger :one
SELECT
    ot.id,
    ot.obligation_value_id,
    ot.action_id,
    ot.attribute_value_id,
    ot.client_id,
    json_object(
        'labels', json_extract(ot.metadata, '$.labels'),
        'created_at', ot.created_at,
        'updated_at', ot.updated_at
    ) as metadata
FROM obligation_triggers ot
WHERE ot.id = ?1
`

type getObligationTriggerRow struct {
	ID                string         `json:"id"`
	ObligationValueID string         `json:"obligation_value_id"`
	ActionID          string         `json:"action_id"`
	AttributeValueID  string         `json:"attribute_value_id"`
	ClientID          sql.NullString `json:"client_id"`
	Metadata          interface{}    `json:"metadata"`
}

// getObligationTrigger
//
//	SELECT
//	    ot.id,
//	    ot.obligation_value_id,
//	    ot.action_id,
//	    ot.attribute_value_id,
//	    ot.client_id,
//	    json_object(
//	        'labels', json_extract(ot.metadata, '$.labels'),
//	        'created_at', ot.created_at,
//	        'updated_at', ot.updated_at
//	    ) as metadata
//	FROM obligation_triggers ot
//	WHERE ot.id = ?1
func (q *Queries) getObligationTrigger(ctx context.Context, id string) (getObligationTriggerRow, error) {
	row := q.db.QueryRowContext(ctx, getObligationTrigger, id)
	var i getObligationTriggerRow
	err := row.Scan(
		&i.ID,
		&i.ObligationValueID,
		&i.ActionID,
		&i.AttributeValueID,
		&i.ClientID,
		&i.Metadata,
	)
	return i, err
}

const getObligationValue = `-- name: getObligationValue :one
SELECT
    ov.id,
    ov.value,
    od.id as obligation_id,
    od.name,
    json_object(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    json_object(
        'labels', json_extract(ov.metadata, '$.labels'),
        'created_at', ov.created_at,
        'updated_at', ov.updated_at
    ) as metadata,
    -- Triggers as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', ot.id,
                'action', json_object('id', a.id, 'name', a.name),
                'attribute_value', json_object(
                    'id', av.id,
                    'value', av.value,
                    'fqn', COALESCE(av_fqns.fqn, '')
                ),
                'context', CASE
                    WHEN ot.client_id IS NOT NULL THEN json_array(
                        json_object('pep', json_object('client_id', ot.client_id))
                    )
                    ELSE json_array()
                END
            )
        )
        FROM obligation_triggers ot
        JOIN actions a ON ot.action_id = a.id
        JOIN attribute_values av ON ot.attribute_value_id = av.id
        LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
        WHERE ot.obligation_value_id = ov.id
    ) as triggers
FROM obligation_values_standard ov
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
WHERE
    (NULLIF(?1, '') IS NOT NULL AND ov.id = ?1)
    OR
    (NULLIF(?2, '') IS NOT NULL AND NULLIF(?3, '') IS NOT NULL AND NULLIF(?4, '') IS NOT NULL
     AND fqns.fqn = ?2 AND od.name = ?3 AND ov.value = ?4)
`

type getObligationValueParams struct {
	ID           interface{} `json:"id"`
	NamespaceFqn interface{} `json:"namespace_fqn"`
	Name         interface{} `json:"name"`
	Value        interface{} `json:"value"`
}

type getObligationValueRow struct {
	ID           string      `json:"id"`
	Value        string      `json:"value"`
	ObligationID string      `json:"obligation_id"`
	Name         string      `json:"name"`
	Namespace    interface{} `json:"namespace"`
	Metadata     interface{} `json:"metadata"`
	Triggers     interface{} `json:"triggers"`
}

// getObligationValue
//
//	SELECT
//	    ov.id,
//	    ov.value,
//	    od.id as obligation_id,
//	    od.name,
//	    json_object(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    json_object(
//	        'labels', json_extract(ov.metadata, '$.labels'),
//	        'created_at', ov.created_at,
//	        'updated_at', ov.updated_at
//	    ) as metadata,
//	    -- Triggers as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', ot.id,
//	                'action', json_object('id', a.id, 'name', a.name),
//	                'attribute_value', json_object(
//	                    'id', av.id,
//	                    'value', av.value,
//	                    'fqn', COALESCE(av_fqns.fqn, '')
//	                ),
//	                'context', CASE
//	                    WHEN ot.client_id IS NOT NULL THEN json_array(
//	                        json_object('pep', json_object('client_id', ot.client_id))
//	                    )
//	                    ELSE json_array()
//	                END
//	            )
//	        )
//	        FROM obligation_triggers ot
//	        JOIN actions a ON ot.action_id = a.id
//	        JOIN attribute_values av ON ot.attribute_value_id = av.id
//	        LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	        WHERE ot.obligation_value_id = ov.id
//	    ) as triggers
//	FROM obligation_values_standard ov
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	WHERE
//	    (NULLIF(?1, '') IS NOT NULL AND ov.id = ?1)
//	    OR
//	    (NULLIF(?2, '') IS NOT NULL AND NULLIF(?3, '') IS NOT NULL AND NULLIF(?4, '') IS NOT NULL
//	     AND fqns.fqn = ?2 AND od.name = ?3 AND ov.value = ?4)
func (q *Queries) getObligationValue(ctx context.Context, arg getObligationValueParams) (getObligationValueRow, error) {
	row := q.db.QueryRowContext(ctx, getObligationValue,
		arg.ID,
		arg.NamespaceFqn,
		arg.Name,
		arg.Value,
	)
	var i getObligationValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ObligationID,
		&i.Name,
		&i.Namespace,
		&i.Metadata,
		&i.Triggers,
	)
	return i, err
}

const getObligationValuesByFQNs = `-- name: getObligationValuesByFQNs :many
SELECT
    ov.id,
    ov.value,
    json_object(
        'labels', json_extract(ov.metadata, '$.labels'),
        'created_at', ov.created_at,
        'updated_at', ov.updated_at
    ) as metadata,
    od.id as obligation_id,
    od.name as name,
    json_object(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace
FROM obligation_values_standard ov
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
WHERE EXISTS (
    SELECT 1
    FROM json_each(@namespace_fqns) nf, json_each(@names) nm, json_each(@values) vv
    WHERE nf.key = nm.key AND nm.key = vv.key
      AND fqns.fqn = nf.value AND od.name = nm.value AND ov.value = vv.value
)
`

type getObligationValuesByFQNsRow struct {
	ID           string      `json:"id"`
	Value        string      `json:"value"`
	Metadata     interface{} `json:"metadata"`
	ObligationID string      `json:"obligation_id"`
	Name         string      `json:"name"`
	Namespace    interface{} `json:"namespace"`
}

// Note: Uses json_each instead of unnest for array matching
//
//	SELECT
//	    ov.id,
//	    ov.value,
//	    json_object(
//	        'labels', json_extract(ov.metadata, '$.labels'),
//	        'created_at', ov.created_at,
//	        'updated_at', ov.updated_at
//	    ) as metadata,
//	    od.id as obligation_id,
//	    od.name as name,
//	    json_object(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace
//	FROM obligation_values_standard ov
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	WHERE EXISTS (
//	    SELECT 1
//	    FROM json_each(@namespace_fqns) nf, json_each(@names) nm, json_each(@values) vv
//	    WHERE nf.key = nm.key AND nm.key = vv.key
//	      AND fqns.fqn = nf.value AND od.name = nm.value AND ov.value = vv.value
//	)
func (q *Queries) getObligationValuesByFQNs(ctx context.Context) ([]getObligationValuesByFQNsRow, error) {
	rows, err := q.db.QueryContext(ctx, getObligationValuesByFQNs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getObligationValuesByFQNsRow
	for rows.Next() {
		var i getObligationValuesByFQNsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Metadata,
			&i.ObligationID,
			&i.Name,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObligationsByFQNs = `-- name: getObligationsByFQNs :many
SELECT
    od.id,
    od.name,
    json_object(
        'labels', json_extract(od.metadata, '$.labels'),
        'created_at', od.created_at,
        'updated_at', od.updated_at
    ) as metadata,
    json_object(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    (
        SELECT json_group_array(
            json_object('id', ov.id, 'value', ov.value)
        )
        FROM obligation_values_standard ov
        WHERE ov.obligation_definition_id = od.id
    ) as "values"
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
WHERE EXISTS (
    SELECT 1
    FROM json_each(@namespace_fqns) nf, json_each(@names) nm
    WHERE nf.key = nm.key AND fqns.fqn = nf.value AND od.name = nm.value
)
`

type getObligationsByFQNsRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Metadata  interface{} `json:"metadata"`
	Namespace interface{} `json:"namespace"`
	Values    interface{} `json:"values"`
}

// Note: Uses json_each instead of unnest for array matching
//
//	SELECT
//	    od.id,
//	    od.name,
//	    json_object(
//	        'labels', json_extract(od.metadata, '$.labels'),
//	        'created_at', od.created_at,
//	        'updated_at', od.updated_at
//	    ) as metadata,
//	    json_object(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    (
//	        SELECT json_group_array(
//	            json_object('id', ov.id, 'value', ov.value)
//	        )
//	        FROM obligation_values_standard ov
//	        WHERE ov.obligation_definition_id = od.id
//	    ) as "values"
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	WHERE EXISTS (
//	    SELECT 1
//	    FROM json_each(@namespace_fqns) nf, json_each(@names) nm
//	    WHERE nf.key = nm.key AND fqns.fqn = nf.value AND od.name = nm.value
//	)
func (q *Queries) getObligationsByFQNs(ctx context.Context) ([]getObligationsByFQNsRow, error) {
	rows, err := q.db.QueryContext(ctx, getObligationsByFQNs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getObligationsByFQNsRow
	for rows.Next() {
		var i getObligationsByFQNsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Metadata,
			&i.Namespace,
			&i.Values,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObligationTriggers = `-- name: listObligationTriggers :many
SELECT
    ot.id,
    ot.obligation_value_id,
    ov.value as obligation_value_value,
    od.id as obligation_id,
    od.name as obligation_name,
    n.id as namespace_id,
    n.name as namespace_name,
    COALESCE(ns_fqns.fqn, '') as namespace_fqn,
    a.id as action_id,
    a.name as action_name,
    av.id as attribute_value_id,
    av.value as attribute_value_value,
    COALESCE(av_fqns.fqn, '') as attribute_value_fqn,
    ot.client_id,
    ot.metadata,
    ot.created_at,
    ot.updated_at,
    COUNT(*) OVER() as total
FROM obligation_triggers ot
JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
JOIN attribute_namespaces n ON od.namespace_id = n.id
LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
JOIN actions a ON ot.action_id = a.id
JOIN attribute_values av ON ot.attribute_value_id = av.id
LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
WHERE
    (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
    (NULLIF(?2, '') IS NULL OR ns_fqns.fqn = ?2)
ORDER BY ot.created_at DESC
LIMIT ?4
OFFSET ?3
`

type listObligationTriggersParams struct {
	NamespaceID  interface{} `json:"namespace_id"`
	NamespaceFqn interface{} `json:"namespace_fqn"`
	Offset       int64       `json:"offset_"`
	Limit        int64       `json:"limit_"`
}

type listObligationTriggersRow struct {
	ID                   string         `json:"id"`
	ObligationValueID    string         `json:"obligation_value_id"`
	ObligationValueValue string         `json:"obligation_value_value"`
	ObligationID         string         `json:"obligation_id"`
	ObligationName       string         `json:"obligation_name"`
	NamespaceID          string         `json:"namespace_id"`
	NamespaceName        string         `json:"namespace_name"`
	NamespaceFqn         string         `json:"namespace_fqn"`
	ActionID             string         `json:"action_id"`
	ActionName           string         `json:"action_name"`
	AttributeValueID     string         `json:"attribute_value_id"`
	AttributeValueValue  string         `json:"attribute_value_value"`
	AttributeValueFqn    string         `json:"attribute_value_fqn"`
	ClientID             sql.NullString `json:"client_id"`
	Metadata             sql.NullString `json:"metadata"`
	CreatedAt            string         `json:"created_at"`
	UpdatedAt            string         `json:"updated_at"`
	Total                int64          `json:"total"`
}

// Note: Flattened structure - app layer assembles JSON response
//
//	SELECT
//	    ot.id,
//	    ot.obligation_value_id,
//	    ov.value as obligation_value_value,
//	    od.id as obligation_id,
//	    od.name as obligation_name,
//	    n.id as namespace_id,
//	    n.name as namespace_name,
//	    COALESCE(ns_fqns.fqn, '') as namespace_fqn,
//	    a.id as action_id,
//	    a.name as action_name,
//	    av.id as attribute_value_id,
//	    av.value as attribute_value_value,
//	    COALESCE(av_fqns.fqn, '') as attribute_value_fqn,
//	    ot.client_id,
//	    ot.metadata,
//	    ot.created_at,
//	    ot.updated_at,
//	    COUNT(*) OVER() as total
//	FROM obligation_triggers ot
//	JOIN obligation_values_standard ov ON ot.obligation_value_id = ov.id
//	JOIN obligation_definitions od ON ov.obligation_definition_id = od.id
//	JOIN attribute_namespaces n ON od.namespace_id = n.id
//	LEFT JOIN attribute_fqns ns_fqns ON ns_fqns.namespace_id = n.id AND ns_fqns.attribute_id IS NULL AND ns_fqns.value_id IS NULL
//	JOIN actions a ON ot.action_id = a.id
//	JOIN attribute_values av ON ot.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns av_fqns ON av_fqns.value_id = av.id
//	WHERE
//	    (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
//	    (NULLIF(?2, '') IS NULL OR ns_fqns.fqn = ?2)
//	ORDER BY ot.created_at DESC
//	LIMIT ?4
//	OFFSET ?3
func (q *Queries) listObligationTriggers(ctx context.Context, arg listObligationTriggersParams) ([]listObligationTriggersRow, error) {
	rows, err := q.db.QueryContext(ctx, listObligationTriggers,
		arg.NamespaceID,
		arg.NamespaceFqn,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationTriggersRow
	for rows.Next() {
		var i listObligationTriggersRow
		if err := rows.Scan(
			&i.ID,
			&i.ObligationValueID,
			&i.ObligationValueValue,
			&i.ObligationID,
			&i.ObligationName,
			&i.NamespaceID,
			&i.NamespaceName,
			&i.NamespaceFqn,
			&i.ActionID,
			&i.ActionName,
			&i.AttributeValueID,
			&i.AttributeValueValue,
			&i.AttributeValueFqn,
			&i.ClientID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listObligations = `-- name: listObligations :many
WITH counted AS (
    SELECT COUNT(od.id) AS total
    FROM obligation_definitions od
    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
    WHERE
        (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
        (NULLIF(?2, '') IS NULL OR fqns.fqn = ?2)
)
SELECT
    od.id,
    od.name,
    json_object(
        'id', n.id,
        'name', n.name,
        'fqn', fqns.fqn
    ) as namespace,
    json_object(
        'labels', json_extract(od.metadata, '$.labels'),
        'created_at', od.created_at,
        'updated_at', od.updated_at
    ) as metadata,
    -- Values as subquery
    (
        SELECT json_group_array(
            json_object(
                'id', ov.id,
                'value', ov.value
            )
        )
        FROM obligation_values_standard ov
        WHERE ov.obligation_definition_id = od.id
    ) as "values",
    counted.total
FROM obligation_definitions od
JOIN attribute_namespaces n on od.namespace_id = n.id
LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
CROSS JOIN counted
WHERE
    (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
    (NULLIF(?2, '') IS NULL OR fqns.fqn = ?2)
GROUP BY od.id, n.id, fqns.fqn, counted.total
LIMIT ?4
OFFSET ?3
`

type listObligationsParams struct {
	NamespaceID  interface{} `json:"namespace_id"`
	NamespaceFqn interface{} `json:"namespace_fqn"`
	Offset       int64       `json:"offset_"`
	Limit        int64       `json:"limit_"`
}

type listObligationsRow struct {
	ID        string      `json:"id"`
	Name      string      `json:"name"`
	Namespace interface{} `json:"namespace"`
	Metadata  interface{} `json:"metadata"`
	Values    interface{} `json:"values"`
	Total     int64       `json:"total"`
}

// listObligations
//
//	WITH counted AS (
//	    SELECT COUNT(od.id) AS total
//	    FROM obligation_definitions od
//	    LEFT JOIN attribute_namespaces n ON od.namespace_id = n.id
//	    LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	    WHERE
//	        (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
//	        (NULLIF(?2, '') IS NULL OR fqns.fqn = ?2)
//	)
//	SELECT
//	    od.id,
//	    od.name,
//	    json_object(
//	        'id', n.id,
//	        'name', n.name,
//	        'fqn', fqns.fqn
//	    ) as namespace,
//	    json_object(
//	        'labels', json_extract(od.metadata, '$.labels'),
//	        'created_at', od.created_at,
//	        'updated_at', od.updated_at
//	    ) as metadata,
//	    -- Values as subquery
//	    (
//	        SELECT json_group_array(
//	            json_object(
//	                'id', ov.id,
//	                'value', ov.value
//	            )
//	        )
//	        FROM obligation_values_standard ov
//	        WHERE ov.obligation_definition_id = od.id
//	    ) as "values",
//	    counted.total
//	FROM obligation_definitions od
//	JOIN attribute_namespaces n on od.namespace_id = n.id
//	LEFT JOIN attribute_fqns fqns ON fqns.namespace_id = n.id AND fqns.attribute_id IS NULL AND fqns.value_id IS NULL
//	CROSS JOIN counted
//	WHERE
//	    (NULLIF(?1, '') IS NULL OR od.namespace_id = ?1) AND
//	    (NULLIF(?2, '') IS NULL OR fqns.fqn = ?2)
//	GROUP BY od.id, n.id, fqns.fqn, counted.total
//	LIMIT ?4
//	OFFSET ?3
func (q *Queries) listObligations(ctx context.Context, arg listObligationsParams) ([]listObligationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listObligations,
		arg.NamespaceID,
		arg.NamespaceFqn,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listObligationsRow
	for rows.Next() {
		var i listObligationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Namespace,
			&i.Metadata,
			&i.Values,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateObligation = `-- name: updateObligation :execrows
UPDATE obligation_definitions
SET
    name = COALESCE(NULLIF(?1, ''), name),
    metadata = COALESCE(?2, metadata)
WHERE id = ?3
`

type updateObligationParams struct {
	Name     interface{}    `json:"name"`
	Metadata sql.NullString `json:"metadata"`
	ID       string         `json:"id"`
}

// updateObligation
//
//	UPDATE obligation_definitions
//	SET
//	    name = COALESCE(NULLIF(?1, ''), name),
//	    metadata = COALESCE(?2, metadata)
//	WHERE id = ?3
func (q *Queries) updateObligation(ctx context.Context, arg updateObligationParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateObligation, arg.Name, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateObligationValue = `-- name: updateObligationValue :execrows
UPDATE obligation_values_standard
SET
    value = COALESCE(NULLIF(?1, ''), value),
    metadata = COALESCE(?2, metadata)
WHERE id = ?3
`

type updateObligationValueParams struct {
	Value    interface{}    `json:"value"`
	Metadata sql.NullString `json:"metadata"`
	ID       string         `json:"id"`
}

// updateObligationValue
//
//	UPDATE obligation_values_standard
//	SET
//	    value = COALESCE(NULLIF(?1, ''), value),
//	    metadata = COALESCE(?2, metadata)
//	WHERE id = ?3
func (q *Queries) updateObligationValue(ctx context.Context, arg updateObligationValueParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateObligationValue, arg.Value, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
