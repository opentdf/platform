// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resource_mapping.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createResourceMapping = `-- name: createResourceMapping :one
INSERT INTO resource_mappings (id, attribute_value_id, terms, metadata, group_id)
VALUES (?1, ?2, ?3, ?4, ?5)
RETURNING id
`

type createResourceMappingParams struct {
	ID               string         `json:"id"`
	AttributeValueID string         `json:"attribute_value_id"`
	Terms            string         `json:"terms"`
	Metadata         sql.NullString `json:"metadata"`
	GroupID          sql.NullString `json:"group_id"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO resource_mappings (id, attribute_value_id, terms, metadata, group_id)
//	VALUES (?1, ?2, ?3, ?4, ?5)
//	RETURNING id
func (q *Queries) createResourceMapping(ctx context.Context, arg createResourceMappingParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createResourceMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createResourceMappingGroup = `-- name: createResourceMappingGroup :one
INSERT INTO resource_mapping_groups (id, namespace_id, name, metadata)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type createResourceMappingGroupParams struct {
	ID          string         `json:"id"`
	NamespaceID string         `json:"namespace_id"`
	Name        string         `json:"name"`
	Metadata    sql.NullString `json:"metadata"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO resource_mapping_groups (id, namespace_id, name, metadata)
//	VALUES (?1, ?2, ?3, ?4)
//	RETURNING id
func (q *Queries) createResourceMappingGroup(ctx context.Context, arg createResourceMappingGroupParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createResourceMappingGroup,
		arg.ID,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteResourceMapping = `-- name: deleteResourceMapping :execrows
DELETE FROM resource_mappings WHERE id = ?1
`

// deleteResourceMapping
//
//	DELETE FROM resource_mappings WHERE id = ?1
func (q *Queries) deleteResourceMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResourceMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteResourceMappingGroup = `-- name: deleteResourceMappingGroup :execrows
DELETE FROM resource_mapping_groups WHERE id = ?1
`

// deleteResourceMappingGroup
//
//	DELETE FROM resource_mapping_groups WHERE id = ?1
func (q *Queries) deleteResourceMappingGroup(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteResourceMappingGroup, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getResourceMapping = `-- name: getResourceMapping :one
SELECT
    m.id,
    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    json_object(
        'labels', json_extract(m.metadata, '$.labels'),
        'created_at', m.created_at,
        'updated_at', m.updated_at
    ) as metadata,
    COALESCE(m.group_id, '') as group_id
FROM resource_mappings m
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
WHERE m.id = ?1
GROUP BY av.id, m.id, fqns.fqn
`

type getResourceMappingRow struct {
	ID             string      `json:"id"`
	AttributeValue interface{} `json:"attribute_value"`
	Terms          string      `json:"terms"`
	Metadata       interface{} `json:"metadata"`
	GroupID        string      `json:"group_id"`
}

// getResourceMapping
//
//	SELECT
//	    m.id,
//	    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    json_object(
//	        'labels', json_extract(m.metadata, '$.labels'),
//	        'created_at', m.created_at,
//	        'updated_at', m.updated_at
//	    ) as metadata,
//	    COALESCE(m.group_id, '') as group_id
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	WHERE m.id = ?1
//	GROUP BY av.id, m.id, fqns.fqn
func (q *Queries) getResourceMapping(ctx context.Context, id string) (getResourceMappingRow, error) {
	row := q.db.QueryRowContext(ctx, getResourceMapping, id)
	var i getResourceMappingRow
	err := row.Scan(
		&i.ID,
		&i.AttributeValue,
		&i.Terms,
		&i.Metadata,
		&i.GroupID,
	)
	return i, err
}

const getResourceMappingGroup = `-- name: getResourceMappingGroup :one
SELECT id, namespace_id, name,
    json_object(
        'labels', json_extract(metadata, '$.labels'),
        'created_at', created_at,
        'updated_at', updated_at
    ) as metadata
FROM resource_mapping_groups
WHERE id = ?1
`

type getResourceMappingGroupRow struct {
	ID          string      `json:"id"`
	NamespaceID string      `json:"namespace_id"`
	Name        string      `json:"name"`
	Metadata    interface{} `json:"metadata"`
}

// getResourceMappingGroup
//
//	SELECT id, namespace_id, name,
//	    json_object(
//	        'labels', json_extract(metadata, '$.labels'),
//	        'created_at', created_at,
//	        'updated_at', updated_at
//	    ) as metadata
//	FROM resource_mapping_groups
//	WHERE id = ?1
func (q *Queries) getResourceMappingGroup(ctx context.Context, id string) (getResourceMappingGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getResourceMappingGroup, id)
	var i getResourceMappingGroupRow
	err := row.Scan(
		&i.ID,
		&i.NamespaceID,
		&i.Name,
		&i.Metadata,
	)
	return i, err
}

const listResourceMappingGroups = `-- name: listResourceMappingGroups :many

SELECT rmg.id,
    rmg.namespace_id,
    rmg.name,
    json_object(
        'labels', json_extract(rmg.metadata, '$.labels'),
        'created_at', rmg.created_at,
        'updated_at', rmg.updated_at
    ) as metadata,
    COUNT(*) OVER() AS total
FROM resource_mapping_groups rmg
WHERE (NULLIF(?1, '') IS NULL OR rmg.namespace_id = ?1)
LIMIT ?3
OFFSET ?2
`

type listResourceMappingGroupsParams struct {
	NamespaceID interface{} `json:"namespace_id"`
	Offset      int64       `json:"offset_"`
	Limit       int64       `json:"limit_"`
}

type listResourceMappingGroupsRow struct {
	ID          string      `json:"id"`
	NamespaceID string      `json:"namespace_id"`
	Name        string      `json:"name"`
	Metadata    interface{} `json:"metadata"`
	Total       int64       `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING GROUPS (SQLite)
// --------------------------------------------------------------
//
//	SELECT rmg.id,
//	    rmg.namespace_id,
//	    rmg.name,
//	    json_object(
//	        'labels', json_extract(rmg.metadata, '$.labels'),
//	        'created_at', rmg.created_at,
//	        'updated_at', rmg.updated_at
//	    ) as metadata,
//	    COUNT(*) OVER() AS total
//	FROM resource_mapping_groups rmg
//	WHERE (NULLIF(?1, '') IS NULL OR rmg.namespace_id = ?1)
//	LIMIT ?3
//	OFFSET ?2
func (q *Queries) listResourceMappingGroups(ctx context.Context, arg listResourceMappingGroupsParams) ([]listResourceMappingGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappingGroups, arg.NamespaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingGroupsRow
	for rows.Next() {
		var i listResourceMappingGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.NamespaceID,
			&i.Name,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappings = `-- name: listResourceMappings :many

SELECT
    m.id,
    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    json_object(
        'labels', json_extract(m.metadata, '$.labels'),
        'created_at', m.created_at,
        'updated_at', m.updated_at
    ) as metadata,
    CASE
        WHEN rmg.id IS NOT NULL THEN json_object(
            'id', rmg.id,
            'name', rmg.name,
            'namespace_id', rmg.namespace_id
        )
        ELSE NULL
    END AS "group",
    COUNT(*) OVER() AS total
FROM resource_mappings m
LEFT JOIN attribute_values av on m.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
WHERE (NULLIF(?1, '') IS NULL OR m.group_id = ?1)
GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id
LIMIT ?3
OFFSET ?2
`

type listResourceMappingsParams struct {
	GroupID interface{} `json:"group_id"`
	Offset  int64       `json:"offset_"`
	Limit   int64       `json:"limit_"`
}

type listResourceMappingsRow struct {
	ID             string      `json:"id"`
	AttributeValue interface{} `json:"attribute_value"`
	Terms          string      `json:"terms"`
	Metadata       interface{} `json:"metadata"`
	Group          interface{} `json:"group"`
	Total          int64       `json:"total"`
}

// --------------------------------------------------------------
// RESOURCE MAPPING (SQLite)
// --------------------------------------------------------------
//
//	SELECT
//	    m.id,
//	    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    json_object(
//	        'labels', json_extract(m.metadata, '$.labels'),
//	        'created_at', m.created_at,
//	        'updated_at', m.updated_at
//	    ) as metadata,
//	    CASE
//	        WHEN rmg.id IS NOT NULL THEN json_object(
//	            'id', rmg.id,
//	            'name', rmg.name,
//	            'namespace_id', rmg.namespace_id
//	        )
//	        ELSE NULL
//	    END AS "group",
//	    COUNT(*) OVER() AS total
//	FROM resource_mappings m
//	LEFT JOIN attribute_values av on m.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns on av.id = fqns.value_id
//	LEFT JOIN resource_mapping_groups rmg ON m.group_id = rmg.id
//	WHERE (NULLIF(?1, '') IS NULL OR m.group_id = ?1)
//	GROUP BY av.id, m.id, fqns.fqn, rmg.id, rmg.name, rmg.namespace_id
//	LIMIT ?3
//	OFFSET ?2
func (q *Queries) listResourceMappings(ctx context.Context, arg listResourceMappingsParams) ([]listResourceMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappings, arg.GroupID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingsRow
	for rows.Next() {
		var i listResourceMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourceMappingsByFullyQualifiedGroup = `-- name: listResourceMappingsByFullyQualifiedGroup :many
WITH groups_cte AS (
    SELECT
        g.id,
        json_object(
            'id', g.id,
            'namespace_id', g.namespace_id,
            'name', g.name,
            'metadata', json_object(
                'labels', json_extract(g.metadata, '$.labels'),
                'created_at', g.created_at,
                'updated_at', g.updated_at
            )
        ) as "group"
    FROM resource_mapping_groups g
    JOIN attribute_namespaces ns on g.namespace_id = ns.id
    WHERE ns.name = ?1 AND g.name = ?2
)
SELECT
    m.id,
    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
    m.terms,
    json_object(
        'labels', json_extract(m.metadata, '$.labels'),
        'created_at', m.created_at,
        'updated_at', m.updated_at
    ) as metadata,
    g."group"
FROM resource_mappings m
JOIN groups_cte g ON m.group_id = g.id
JOIN attribute_values av on m.attribute_value_id = av.id
JOIN attribute_fqns fqns on av.id = fqns.value_id
`

type listResourceMappingsByFullyQualifiedGroupParams struct {
	NamespaceName string `json:"namespace_name"`
	GroupName     string `json:"group_name"`
}

type listResourceMappingsByFullyQualifiedGroupRow struct {
	ID             string      `json:"id"`
	AttributeValue interface{} `json:"attribute_value"`
	Terms          string      `json:"terms"`
	Metadata       interface{} `json:"metadata"`
	Group          interface{} `json:"group"`
}

// CTE to cache the group JSON build since it will be the same for all mappings of the group
//
//	WITH groups_cte AS (
//	    SELECT
//	        g.id,
//	        json_object(
//	            'id', g.id,
//	            'namespace_id', g.namespace_id,
//	            'name', g.name,
//	            'metadata', json_object(
//	                'labels', json_extract(g.metadata, '$.labels'),
//	                'created_at', g.created_at,
//	                'updated_at', g.updated_at
//	            )
//	        ) as "group"
//	    FROM resource_mapping_groups g
//	    JOIN attribute_namespaces ns on g.namespace_id = ns.id
//	    WHERE ns.name = ?1 AND g.name = ?2
//	)
//	SELECT
//	    m.id,
//	    json_object('id', av.id, 'value', av.value, 'fqn', fqns.fqn) as attribute_value,
//	    m.terms,
//	    json_object(
//	        'labels', json_extract(m.metadata, '$.labels'),
//	        'created_at', m.created_at,
//	        'updated_at', m.updated_at
//	    ) as metadata,
//	    g."group"
//	FROM resource_mappings m
//	JOIN groups_cte g ON m.group_id = g.id
//	JOIN attribute_values av on m.attribute_value_id = av.id
//	JOIN attribute_fqns fqns on av.id = fqns.value_id
func (q *Queries) listResourceMappingsByFullyQualifiedGroup(ctx context.Context, arg listResourceMappingsByFullyQualifiedGroupParams) ([]listResourceMappingsByFullyQualifiedGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, listResourceMappingsByFullyQualifiedGroup, arg.NamespaceName, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listResourceMappingsByFullyQualifiedGroupRow
	for rows.Next() {
		var i listResourceMappingsByFullyQualifiedGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.AttributeValue,
			&i.Terms,
			&i.Metadata,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResourceMapping = `-- name: updateResourceMapping :execrows
UPDATE resource_mappings
SET
    attribute_value_id = COALESCE(?1, attribute_value_id),
    terms = COALESCE(?2, terms),
    metadata = COALESCE(?3, metadata),
    group_id = COALESCE(?4, group_id)
WHERE id = ?5
`

type updateResourceMappingParams struct {
	AttributeValueID sql.NullString `json:"attribute_value_id"`
	Terms            sql.NullString `json:"terms"`
	Metadata         sql.NullString `json:"metadata"`
	GroupID          sql.NullString `json:"group_id"`
	ID               string         `json:"id"`
}

// updateResourceMapping
//
//	UPDATE resource_mappings
//	SET
//	    attribute_value_id = COALESCE(?1, attribute_value_id),
//	    terms = COALESCE(?2, terms),
//	    metadata = COALESCE(?3, metadata),
//	    group_id = COALESCE(?4, group_id)
//	WHERE id = ?5
func (q *Queries) updateResourceMapping(ctx context.Context, arg updateResourceMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateResourceMapping,
		arg.AttributeValueID,
		arg.Terms,
		arg.Metadata,
		arg.GroupID,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateResourceMappingGroup = `-- name: updateResourceMappingGroup :execrows
UPDATE resource_mapping_groups
SET
    namespace_id = COALESCE(?1, namespace_id),
    name = COALESCE(?2, name),
    metadata = COALESCE(?3, metadata)
WHERE id = ?4
`

type updateResourceMappingGroupParams struct {
	NamespaceID sql.NullString `json:"namespace_id"`
	Name        sql.NullString `json:"name"`
	Metadata    sql.NullString `json:"metadata"`
	ID          string         `json:"id"`
}

// updateResourceMappingGroup
//
//	UPDATE resource_mapping_groups
//	SET
//	    namespace_id = COALESCE(?1, namespace_id),
//	    name = COALESCE(?2, name),
//	    metadata = COALESCE(?3, metadata)
//	WHERE id = ?4
func (q *Queries) updateResourceMappingGroup(ctx context.Context, arg updateResourceMappingGroupParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateResourceMappingGroup,
		arg.NamespaceID,
		arg.Name,
		arg.Metadata,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
