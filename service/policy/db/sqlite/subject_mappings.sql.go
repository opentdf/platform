// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subject_mappings.sql

package sqlite

import (
	"context"
	"database/sql"
)

const addActionToSubjectMapping = `-- name: addActionToSubjectMapping :exec
INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
VALUES (?1, ?2)
ON CONFLICT (subject_mapping_id, action_id) DO NOTHING
`

type addActionToSubjectMappingParams struct {
	SubjectMappingID string `json:"subject_mapping_id"`
	ActionID         string `json:"action_id"`
}

// Helper to add actions to subject mapping (called from app layer)
//
//	INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
//	VALUES (?1, ?2)
//	ON CONFLICT (subject_mapping_id, action_id) DO NOTHING
func (q *Queries) addActionToSubjectMapping(ctx context.Context, arg addActionToSubjectMappingParams) error {
	_, err := q.db.ExecContext(ctx, addActionToSubjectMapping, arg.SubjectMappingID, arg.ActionID)
	return err
}

const createSubjectConditionSet = `-- name: createSubjectConditionSet :one
INSERT INTO subject_condition_set (id, condition, metadata)
VALUES (?1, ?2, ?3)
RETURNING id
`

type createSubjectConditionSetParams struct {
	ID        string         `json:"id"`
	Condition string         `json:"condition"`
	Metadata  sql.NullString `json:"metadata"`
}

// Note: ID generated in application layer before INSERT
//
//	INSERT INTO subject_condition_set (id, condition, metadata)
//	VALUES (?1, ?2, ?3)
//	RETURNING id
func (q *Queries) createSubjectConditionSet(ctx context.Context, arg createSubjectConditionSetParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSubjectConditionSet, arg.ID, arg.Condition, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectMapping = `-- name: createSubjectMapping :one
INSERT INTO subject_mappings (
    id,
    attribute_value_id,
    metadata,
    subject_condition_set_id
)
VALUES (?1, ?2, ?3, ?4)
RETURNING id
`

type createSubjectMappingParams struct {
	ID                    string         `json:"id"`
	AttributeValueID      string         `json:"attribute_value_id"`
	Metadata              sql.NullString `json:"metadata"`
	SubjectConditionSetID sql.NullString `json:"subject_condition_set_id"`
}

// Note: Action insertion handled separately in app layer for SQLite
// Note: ID generated in application layer before INSERT
//
//	INSERT INTO subject_mappings (
//	    id,
//	    attribute_value_id,
//	    metadata,
//	    subject_condition_set_id
//	)
//	VALUES (?1, ?2, ?3, ?4)
//	RETURNING id
func (q *Queries) createSubjectMapping(ctx context.Context, arg createSubjectMappingParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createSubjectMapping,
		arg.ID,
		arg.AttributeValueID,
		arg.Metadata,
		arg.SubjectConditionSetID,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllUnmappedSubjectConditionSets = `-- name: deleteAllUnmappedSubjectConditionSets :many
DELETE FROM subject_condition_set
WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm WHERE sm.subject_condition_set_id IS NOT NULL)
RETURNING id
`

// deleteAllUnmappedSubjectConditionSets
//
//	DELETE FROM subject_condition_set
//	WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm WHERE sm.subject_condition_set_id IS NOT NULL)
//	RETURNING id
func (q *Queries) deleteAllUnmappedSubjectConditionSets(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, deleteAllUnmappedSubjectConditionSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteSubjectConditionSet = `-- name: deleteSubjectConditionSet :execrows
DELETE FROM subject_condition_set WHERE id = ?1
`

// deleteSubjectConditionSet
//
//	DELETE FROM subject_condition_set WHERE id = ?1
func (q *Queries) deleteSubjectConditionSet(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSubjectConditionSet, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteSubjectMapping = `-- name: deleteSubjectMapping :execrows
DELETE FROM subject_mappings WHERE id = ?1
`

// deleteSubjectMapping
//
//	DELETE FROM subject_mappings WHERE id = ?1
func (q *Queries) deleteSubjectMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSubjectMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getSubjectConditionSet = `-- name: getSubjectConditionSet :one
SELECT
    id,
    condition,
    json_object(
        'labels', json_extract(metadata, '$.labels'),
        'created_at', created_at,
        'updated_at', updated_at
    ) as metadata
FROM subject_condition_set
WHERE id = ?1
`

type getSubjectConditionSetRow struct {
	ID        string      `json:"id"`
	Condition string      `json:"condition"`
	Metadata  interface{} `json:"metadata"`
}

// getSubjectConditionSet
//
//	SELECT
//	    id,
//	    condition,
//	    json_object(
//	        'labels', json_extract(metadata, '$.labels'),
//	        'created_at', created_at,
//	        'updated_at', updated_at
//	    ) as metadata
//	FROM subject_condition_set
//	WHERE id = ?1
func (q *Queries) getSubjectConditionSet(ctx context.Context, id string) (getSubjectConditionSetRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectConditionSet, id)
	var i getSubjectConditionSetRow
	err := row.Scan(&i.ID, &i.Condition, &i.Metadata)
	return i, err
}

const getSubjectMapping = `-- name: getSubjectMapping :one
SELECT
    sm.id,
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
    ) AS standard_actions,
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
    ) AS custom_actions,
    json_object(
        'labels', json_extract(sm.metadata, '$.labels'),
        'created_at', sm.created_at,
        'updated_at', sm.updated_at
    ) AS metadata,
    json_object(
        'id', scs.id,
        'metadata', json_object(
            'labels', json_extract(scs.metadata, '$.labels'),
            'created_at', scs.created_at,
            'updated_at', scs.updated_at
        ),
        'subject_sets', json(scs.condition)
    ) AS subject_condition_set,
    json_object('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE sm.id = ?1
GROUP BY av.id, sm.id, scs.id
`

type getSubjectMappingRow struct {
	ID                  string      `json:"id"`
	StandardActions     interface{} `json:"standard_actions"`
	CustomActions       interface{} `json:"custom_actions"`
	Metadata            interface{} `json:"metadata"`
	SubjectConditionSet interface{} `json:"subject_condition_set"`
	AttributeValue      interface{} `json:"attribute_value"`
}

// getSubjectMapping
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
//	    ) AS standard_actions,
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
//	    ) AS custom_actions,
//	    json_object(
//	        'labels', json_extract(sm.metadata, '$.labels'),
//	        'created_at', sm.created_at,
//	        'updated_at', sm.updated_at
//	    ) AS metadata,
//	    json_object(
//	        'id', scs.id,
//	        'metadata', json_object(
//	            'labels', json_extract(scs.metadata, '$.labels'),
//	            'created_at', scs.created_at,
//	            'updated_at', scs.updated_at
//	        ),
//	        'subject_sets', json(scs.condition)
//	    ) AS subject_condition_set,
//	    json_object('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE sm.id = ?1
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) getSubjectMapping(ctx context.Context, id string) (getSubjectMappingRow, error) {
	row := q.db.QueryRowContext(ctx, getSubjectMapping, id)
	var i getSubjectMappingRow
	err := row.Scan(
		&i.ID,
		&i.StandardActions,
		&i.CustomActions,
		&i.Metadata,
		&i.SubjectConditionSet,
		&i.AttributeValue,
	)
	return i, err
}

const listSubjectConditionSets = `-- name: listSubjectConditionSets :many

WITH counted AS (
    SELECT COUNT(scs.id) AS total
    FROM subject_condition_set scs
)
SELECT
    scs.id,
    scs.condition,
    json_object(
        'labels', json_extract(scs.metadata, '$.labels'),
        'created_at', scs.created_at,
        'updated_at', scs.updated_at
    ) as metadata,
    counted.total
FROM subject_condition_set scs
CROSS JOIN counted
LIMIT ?2
OFFSET ?1
`

type listSubjectConditionSetsParams struct {
	Offset int64 `json:"offset_"`
	Limit  int64 `json:"limit_"`
}

type listSubjectConditionSetsRow struct {
	ID        string      `json:"id"`
	Condition string      `json:"condition"`
	Metadata  interface{} `json:"metadata"`
	Total     int64       `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT CONDITION SETS (SQLite)
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(scs.id) AS total
//	    FROM subject_condition_set scs
//	)
//	SELECT
//	    scs.id,
//	    scs.condition,
//	    json_object(
//	        'labels', json_extract(scs.metadata, '$.labels'),
//	        'created_at', scs.created_at,
//	        'updated_at', scs.updated_at
//	    ) as metadata,
//	    counted.total
//	FROM subject_condition_set scs
//	CROSS JOIN counted
//	LIMIT ?2
//	OFFSET ?1
func (q *Queries) listSubjectConditionSets(ctx context.Context, arg listSubjectConditionSetsParams) ([]listSubjectConditionSetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubjectConditionSets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listSubjectConditionSetsRow
	for rows.Next() {
		var i listSubjectConditionSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Condition,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectMappings = `-- name: listSubjectMappings :many

WITH counted AS (
    SELECT COUNT(sm.id) AS total
    FROM subject_mappings sm
)
SELECT
    sm.id,
    -- Standard actions as subquery
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM subject_mapping_actions sma
        JOIN actions a ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
    ) AS standard_actions,
    -- Custom actions as subquery
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM subject_mapping_actions sma
        JOIN actions a ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
    ) AS custom_actions,
    json_object(
        'labels', json_extract(sm.metadata, '$.labels'),
        'created_at', sm.created_at,
        'updated_at', sm.updated_at
    ) AS metadata,
    json_object(
        'id', scs.id,
        'metadata', json_object(
            'labels', json_extract(scs.metadata, '$.labels'),
            'created_at', scs.created_at,
            'updated_at', scs.updated_at
        ),
        'subject_sets', json(scs.condition)
    ) AS subject_condition_set,
    json_object(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value,
    counted.total
FROM subject_mappings sm
CROSS JOIN counted
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
GROUP BY sm.id, av.id, scs.id, fqns.fqn, counted.total
LIMIT ?2
OFFSET ?1
`

type listSubjectMappingsParams struct {
	Offset int64 `json:"offset_"`
	Limit  int64 `json:"limit_"`
}

type listSubjectMappingsRow struct {
	ID                  string      `json:"id"`
	StandardActions     interface{} `json:"standard_actions"`
	CustomActions       interface{} `json:"custom_actions"`
	Metadata            interface{} `json:"metadata"`
	SubjectConditionSet interface{} `json:"subject_condition_set"`
	AttributeValue      interface{} `json:"attribute_value"`
	Total               int64       `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT MAPPINGS (SQLite)
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(sm.id) AS total
//	    FROM subject_mappings sm
//	)
//	SELECT
//	    sm.id,
//	    -- Standard actions as subquery
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM subject_mapping_actions sma
//	        JOIN actions a ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
//	    ) AS standard_actions,
//	    -- Custom actions as subquery
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM subject_mapping_actions sma
//	        JOIN actions a ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
//	    ) AS custom_actions,
//	    json_object(
//	        'labels', json_extract(sm.metadata, '$.labels'),
//	        'created_at', sm.created_at,
//	        'updated_at', sm.updated_at
//	    ) AS metadata,
//	    json_object(
//	        'id', scs.id,
//	        'metadata', json_object(
//	            'labels', json_extract(scs.metadata, '$.labels'),
//	            'created_at', scs.created_at,
//	            'updated_at', scs.updated_at
//	        ),
//	        'subject_sets', json(scs.condition)
//	    ) AS subject_condition_set,
//	    json_object(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value,
//	    counted.total
//	FROM subject_mappings sm
//	CROSS JOIN counted
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	GROUP BY sm.id, av.id, scs.id, fqns.fqn, counted.total
//	LIMIT ?2
//	OFFSET ?1
func (q *Queries) listSubjectMappings(ctx context.Context, arg listSubjectMappingsParams) ([]listSubjectMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubjectMappings, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listSubjectMappingsRow
	for rows.Next() {
		var i listSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.Metadata,
			&i.SubjectConditionSet,
			&i.AttributeValue,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchSubjectMappings = `-- name: matchSubjectMappings :many
SELECT
    sm.id,
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM subject_mapping_actions sma
        JOIN actions a ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
    ) AS standard_actions,
    (
        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
        FROM subject_mapping_actions sma
        JOIN actions a ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
    ) AS custom_actions,
    json_object(
        'id', scs.id,
        'subject_sets', json(scs.condition)
    ) AS subject_condition_set,
    json_object(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE
    ns.active = 1
    AND ad.active = 1
    AND av.active = 1
    -- Array overlap emulation: check if any selector from input matches any in selector_values
    AND EXISTS (
        SELECT 1
        FROM json_each(scs.selector_values) sv
        WHERE sv.value IN (SELECT value FROM json_each(@selectors))
    )
GROUP BY sm.id, scs.id, scs.condition, av.id, av.value, av.active, fqns.fqn
`

type matchSubjectMappingsRow struct {
	ID                  string      `json:"id"`
	StandardActions     interface{} `json:"standard_actions"`
	CustomActions       interface{} `json:"custom_actions"`
	SubjectConditionSet interface{} `json:"subject_condition_set"`
	AttributeValue      interface{} `json:"attribute_value"`
}

// Note: Array overlap (&&) not supported in SQLite, using json_each for selector matching
// The selector_values column contains a JSON array, we check if any selector matches
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM subject_mapping_actions sma
//	        JOIN actions a ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 1
//	    ) AS standard_actions,
//	    (
//	        SELECT json_group_array(json_object('id', a.id, 'name', a.name))
//	        FROM subject_mapping_actions sma
//	        JOIN actions a ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = 0
//	    ) AS custom_actions,
//	    json_object(
//	        'id', scs.id,
//	        'subject_sets', json(scs.condition)
//	    ) AS subject_condition_set,
//	    json_object(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE
//	    ns.active = 1
//	    AND ad.active = 1
//	    AND av.active = 1
//	    -- Array overlap emulation: check if any selector from input matches any in selector_values
//	    AND EXISTS (
//	        SELECT 1
//	        FROM json_each(scs.selector_values) sv
//	        WHERE sv.value IN (SELECT value FROM json_each(@selectors))
//	    )
//	GROUP BY sm.id, scs.id, scs.condition, av.id, av.value, av.active, fqns.fqn
func (q *Queries) matchSubjectMappings(ctx context.Context) ([]matchSubjectMappingsRow, error) {
	rows, err := q.db.QueryContext(ctx, matchSubjectMappings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []matchSubjectMappingsRow
	for rows.Next() {
		var i matchSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.SubjectConditionSet,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeActionFromSubjectMapping = `-- name: removeActionFromSubjectMapping :execrows
DELETE FROM subject_mapping_actions
WHERE subject_mapping_id = ?1 AND action_id = ?2
`

type removeActionFromSubjectMappingParams struct {
	SubjectMappingID string `json:"subject_mapping_id"`
	ActionID         string `json:"action_id"`
}

// removeActionFromSubjectMapping
//
//	DELETE FROM subject_mapping_actions
//	WHERE subject_mapping_id = ?1 AND action_id = ?2
func (q *Queries) removeActionFromSubjectMapping(ctx context.Context, arg removeActionFromSubjectMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeActionFromSubjectMapping, arg.SubjectMappingID, arg.ActionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removeAllActionsFromSubjectMapping = `-- name: removeAllActionsFromSubjectMapping :execrows
DELETE FROM subject_mapping_actions
WHERE subject_mapping_id = ?1
`

// removeAllActionsFromSubjectMapping
//
//	DELETE FROM subject_mapping_actions
//	WHERE subject_mapping_id = ?1
func (q *Queries) removeAllActionsFromSubjectMapping(ctx context.Context, subjectMappingID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeAllActionsFromSubjectMapping, subjectMappingID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSubjectConditionSet = `-- name: updateSubjectConditionSet :execrows
UPDATE subject_condition_set
SET
    condition = COALESCE(?1, condition),
    metadata = COALESCE(?2, metadata)
WHERE id = ?3
`

type updateSubjectConditionSetParams struct {
	Condition sql.NullString `json:"condition"`
	Metadata  sql.NullString `json:"metadata"`
	ID        string         `json:"id"`
}

// updateSubjectConditionSet
//
//	UPDATE subject_condition_set
//	SET
//	    condition = COALESCE(?1, condition),
//	    metadata = COALESCE(?2, metadata)
//	WHERE id = ?3
func (q *Queries) updateSubjectConditionSet(ctx context.Context, arg updateSubjectConditionSetParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSubjectConditionSet, arg.Condition, arg.Metadata, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSubjectMapping = `-- name: updateSubjectMapping :execrows
UPDATE subject_mappings
SET
    metadata = COALESCE(?1, metadata),
    subject_condition_set_id = COALESCE(?2, subject_condition_set_id)
WHERE id = ?3
`

type updateSubjectMappingParams struct {
	Metadata              sql.NullString `json:"metadata"`
	SubjectConditionSetID sql.NullString `json:"subject_condition_set_id"`
	ID                    string         `json:"id"`
}

// Note: Action updates handled separately in app layer for SQLite
//
//	UPDATE subject_mappings
//	SET
//	    metadata = COALESCE(?1, metadata),
//	    subject_condition_set_id = COALESCE(?2, subject_condition_set_id)
//	WHERE id = ?3
func (q *Queries) updateSubjectMapping(ctx context.Context, arg updateSubjectMappingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSubjectMapping, arg.Metadata, arg.SubjectConditionSetID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
