// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subject_mappings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSubjectConditionSet = `-- name: createSubjectConditionSet :one
INSERT INTO subject_condition_set (condition, metadata)
VALUES ($1, $2)
RETURNING id
`

type createSubjectConditionSetParams struct {
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// createSubjectConditionSet
//
//	INSERT INTO subject_condition_set (condition, metadata)
//	VALUES ($1, $2)
//	RETURNING id
func (q *Queries) createSubjectConditionSet(ctx context.Context, arg createSubjectConditionSetParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectConditionSet, arg.Condition, arg.Metadata)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createSubjectMapping = `-- name: createSubjectMapping :one
WITH inserted_mapping AS (
    INSERT INTO subject_mappings (
        attribute_value_id,
        metadata,
        subject_condition_set_id
    )
    VALUES ($1, $2, $3)
    RETURNING id
),
inserted_actions AS (
    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
    SELECT 
        (SELECT id FROM inserted_mapping),
        unnest($4::uuid[])
)
SELECT id FROM inserted_mapping
`

type createSubjectMappingParams struct {
	AttributeValueID      string      `json:"attribute_value_id"`
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
	ActionIds             []string    `json:"action_ids"`
}

// createSubjectMapping
//
//	WITH inserted_mapping AS (
//	    INSERT INTO subject_mappings (
//	        attribute_value_id,
//	        metadata,
//	        subject_condition_set_id
//	    )
//	    VALUES ($1, $2, $3)
//	    RETURNING id
//	),
//	inserted_actions AS (
//	    INSERT INTO subject_mapping_actions (subject_mapping_id, action_id)
//	    SELECT
//	        (SELECT id FROM inserted_mapping),
//	        unnest($4::uuid[])
//	)
//	SELECT id FROM inserted_mapping
func (q *Queries) createSubjectMapping(ctx context.Context, arg createSubjectMappingParams) (string, error) {
	row := q.db.QueryRow(ctx, createSubjectMapping,
		arg.AttributeValueID,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ActionIds,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const deleteAllUnmappedSubjectConditionSets = `-- name: deleteAllUnmappedSubjectConditionSets :many
DELETE FROM subject_condition_set
WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
RETURNING id
`

// deleteAllUnmappedSubjectConditionSets
//
//	DELETE FROM subject_condition_set
//	WHERE id NOT IN (SELECT DISTINCT sm.subject_condition_set_id FROM subject_mappings sm)
//	RETURNING id
func (q *Queries) deleteAllUnmappedSubjectConditionSets(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, deleteAllUnmappedSubjectConditionSets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteSubjectConditionSet = `-- name: deleteSubjectConditionSet :execrows
DELETE FROM subject_condition_set WHERE id = $1
`

// deleteSubjectConditionSet
//
//	DELETE FROM subject_condition_set WHERE id = $1
func (q *Queries) deleteSubjectConditionSet(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectConditionSet, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSubjectMapping = `-- name: deleteSubjectMapping :execrows
DELETE FROM subject_mappings WHERE id = $1
`

// deleteSubjectMapping
//
//	DELETE FROM subject_mappings WHERE id = $1
func (q *Queries) deleteSubjectMapping(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSubjectMapping, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getSubjectConditionSet = `-- name: getSubjectConditionSet :one
SELECT
    id,
    condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
FROM subject_condition_set
WHERE id = $1
`

type getSubjectConditionSetRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// getSubjectConditionSet
//
//	SELECT
//	    id,
//	    condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', metadata -> 'labels', 'created_at', created_at, 'updated_at', updated_at)) as metadata
//	FROM subject_condition_set
//	WHERE id = $1
func (q *Queries) getSubjectConditionSet(ctx context.Context, id string) (getSubjectConditionSetRow, error) {
	row := q.db.QueryRow(ctx, getSubjectConditionSet, id)
	var i getSubjectConditionSetRow
	err := row.Scan(&i.ID, &i.Condition, &i.Metadata)
	return i, err
}

const getSubjectMapping = `-- name: getSubjectMapping :one
SELECT
    sm.id,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
    ) AS standard_actions,
    (
        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
        FROM actions a
        JOIN subject_mapping_actions sma ON sma.action_id = a.id
        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
    ) AS custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
FROM subject_mappings sm
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE sm.id = $1
GROUP BY av.id, sm.id, scs.id
`

type getSubjectMappingRow struct {
	ID                  string `json:"id"`
	StandardActions     []byte `json:"standard_actions"`
	CustomActions       []byte `json:"custom_actions"`
	Metadata            []byte `json:"metadata"`
	SubjectConditionSet []byte `json:"subject_condition_set"`
	AttributeValue      []byte `json:"attribute_value"`
}

// getSubjectMapping
//
//	SELECT
//	    sm.id,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = TRUE
//	    ) AS standard_actions,
//	    (
//	        SELECT JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name))
//	        FROM actions a
//	        JOIN subject_mapping_actions sma ON sma.action_id = a.id
//	        WHERE sma.subject_mapping_id = sm.id AND a.is_standard = FALSE
//	    ) AS custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT('id', av.id,'value', av.value,'active', av.active) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE sm.id = $1
//	GROUP BY av.id, sm.id, scs.id
func (q *Queries) getSubjectMapping(ctx context.Context, id string) (getSubjectMappingRow, error) {
	row := q.db.QueryRow(ctx, getSubjectMapping, id)
	var i getSubjectMappingRow
	err := row.Scan(
		&i.ID,
		&i.StandardActions,
		&i.CustomActions,
		&i.Metadata,
		&i.SubjectConditionSet,
		&i.AttributeValue,
	)
	return i, err
}

const listSubjectConditionSets = `-- name: listSubjectConditionSets :many

WITH counted AS (
    SELECT COUNT(scs.id) AS total
    FROM subject_condition_set scs
)
SELECT
    scs.id,
    scs.condition,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
    counted.total
FROM subject_condition_set scs
CROSS JOIN counted
LIMIT $2 
OFFSET $1
`

type listSubjectConditionSetsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listSubjectConditionSetsRow struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
	Total     int64  `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT CONDITION SETS
// --------------------------------------------------------------
//
//	WITH counted AS (
//	    SELECT COUNT(scs.id) AS total
//	    FROM subject_condition_set scs
//	)
//	SELECT
//	    scs.id,
//	    scs.condition,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata -> 'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)) as metadata,
//	    counted.total
//	FROM subject_condition_set scs
//	CROSS JOIN counted
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listSubjectConditionSets(ctx context.Context, arg listSubjectConditionSetsParams) ([]listSubjectConditionSetsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectConditionSets, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listSubjectConditionSetsRow
	for rows.Next() {
		var i listSubjectConditionSetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Condition,
			&i.Metadata,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubjectMappings = `-- name: listSubjectMappings :many

WITH subject_actions AS (
    SELECT
        sma.subject_mapping_id,
        COALESCE(
            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = TRUE),
            '[]'::JSONB
        ) AS standard_actions,
        COALESCE(
            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = FALSE),
            '[]'::JSONB
        ) AS custom_actions
    FROM subject_mapping_actions sma
    JOIN actions a ON sma.action_id = a.id
    GROUP BY sma.subject_mapping_id
), counted AS (
    SELECT COUNT(sm.id) AS total
    FROM subject_mappings sm
)
SELECT
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value,
    counted.total
FROM subject_mappings sm
CROSS JOIN counted
LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
GROUP BY
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    sm.metadata, sm.created_at, sm.updated_at, -- for metadata object
    scs.id, scs.metadata, scs.created_at, scs.updated_at, scs.condition, -- for subject_condition_set object
    av.id, av.value, av.active, -- for attribute_value object
    fqns.fqn,
    counted.total
LIMIT $2
OFFSET $1
`

type listSubjectMappingsParams struct {
	Offset int32 `json:"offset_"`
	Limit  int32 `json:"limit_"`
}

type listSubjectMappingsRow struct {
	ID                  string      `json:"id"`
	StandardActions     interface{} `json:"standard_actions"`
	CustomActions       interface{} `json:"custom_actions"`
	Metadata            []byte      `json:"metadata"`
	SubjectConditionSet []byte      `json:"subject_condition_set"`
	AttributeValue      []byte      `json:"attribute_value"`
	Total               int64       `json:"total"`
}

// --------------------------------------------------------------
// SUBJECT MAPPINGS
// --------------------------------------------------------------
//
//	WITH subject_actions AS (
//	    SELECT
//	        sma.subject_mapping_id,
//	        COALESCE(
//	            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = TRUE),
//	            '[]'::JSONB
//	        ) AS standard_actions,
//	        COALESCE(
//	            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = FALSE),
//	            '[]'::JSONB
//	        ) AS custom_actions
//	    FROM subject_mapping_actions sma
//	    JOIN actions a ON sma.action_id = a.id
//	    GROUP BY sma.subject_mapping_id
//	), counted AS (
//	    SELECT COUNT(sm.id) AS total
//	    FROM subject_mappings sm
//	)
//	SELECT
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', sm.metadata -> 'labels', 'created_at', sm.created_at, 'updated_at', sm.updated_at)) AS metadata,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'metadata', JSON_STRIP_NULLS(JSON_BUILD_OBJECT('labels', scs.metadata->'labels', 'created_at', scs.created_at, 'updated_at', scs.updated_at)),
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value,
//	    counted.total
//	FROM subject_mappings sm
//	CROSS JOIN counted
//	LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	GROUP BY
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    sm.metadata, sm.created_at, sm.updated_at, -- for metadata object
//	    scs.id, scs.metadata, scs.created_at, scs.updated_at, scs.condition, -- for subject_condition_set object
//	    av.id, av.value, av.active, -- for attribute_value object
//	    fqns.fqn,
//	    counted.total
//	LIMIT $2
//	OFFSET $1
func (q *Queries) listSubjectMappings(ctx context.Context, arg listSubjectMappingsParams) ([]listSubjectMappingsRow, error) {
	rows, err := q.db.Query(ctx, listSubjectMappings, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listSubjectMappingsRow
	for rows.Next() {
		var i listSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.Metadata,
			&i.SubjectConditionSet,
			&i.AttributeValue,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchSubjectMappings = `-- name: matchSubjectMappings :many
WITH subject_actions AS (
    SELECT
        sma.subject_mapping_id,
        COALESCE(
            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = TRUE),
            '[]'::JSONB
        ) AS standard_actions,
        COALESCE(
            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = FALSE),
            '[]'::JSONB
        ) AS custom_actions
    FROM subject_mapping_actions sma
    JOIN actions a ON sma.action_id = a.id
    GROUP BY sma.subject_mapping_id
)
SELECT
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    JSON_BUILD_OBJECT(
        'id', scs.id,
        'subject_sets', scs.condition
    ) AS subject_condition_set,
    JSON_BUILD_OBJECT(
        'id', av.id,
        'value', av.value,
        'active', av.active,
        'fqn', fqns.fqn
    ) AS attribute_value
FROM subject_mappings sm
LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
WHERE
    ns.active = TRUE
    AND ad.active = TRUE
    AND av.active = TRUE
    AND scs.selector_values && $1::TEXT[]
GROUP BY
    sm.id,
    sa.standard_actions,
    sa.custom_actions,
    scs.id, scs.condition,
    av.id, av.value, av.active, fqns.fqn
`

type matchSubjectMappingsRow struct {
	ID                  string      `json:"id"`
	StandardActions     interface{} `json:"standard_actions"`
	CustomActions       interface{} `json:"custom_actions"`
	SubjectConditionSet []byte      `json:"subject_condition_set"`
	AttributeValue      []byte      `json:"attribute_value"`
}

// matchSubjectMappings
//
//	WITH subject_actions AS (
//	    SELECT
//	        sma.subject_mapping_id,
//	        COALESCE(
//	            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = TRUE),
//	            '[]'::JSONB
//	        ) AS standard_actions,
//	        COALESCE(
//	            JSONB_AGG(JSONB_BUILD_OBJECT('id', a.id, 'name', a.name)) FILTER (WHERE a.is_standard = FALSE),
//	            '[]'::JSONB
//	        ) AS custom_actions
//	    FROM subject_mapping_actions sma
//	    JOIN actions a ON sma.action_id = a.id
//	    GROUP BY sma.subject_mapping_id
//	)
//	SELECT
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    JSON_BUILD_OBJECT(
//	        'id', scs.id,
//	        'subject_sets', scs.condition
//	    ) AS subject_condition_set,
//	    JSON_BUILD_OBJECT(
//	        'id', av.id,
//	        'value', av.value,
//	        'active', av.active,
//	        'fqn', fqns.fqn
//	    ) AS attribute_value
//	FROM subject_mappings sm
//	LEFT JOIN subject_actions sa ON sm.id = sa.subject_mapping_id
//	LEFT JOIN attribute_values av ON sm.attribute_value_id = av.id
//	LEFT JOIN attribute_definitions ad ON av.attribute_definition_id = ad.id
//	LEFT JOIN attribute_namespaces ns ON ad.namespace_id = ns.id
//	LEFT JOIN attribute_fqns fqns ON av.id = fqns.value_id
//	LEFT JOIN subject_condition_set scs ON scs.id = sm.subject_condition_set_id
//	WHERE
//	    ns.active = TRUE
//	    AND ad.active = TRUE
//	    AND av.active = TRUE
//	    AND scs.selector_values && $1::TEXT[]
//	GROUP BY
//	    sm.id,
//	    sa.standard_actions,
//	    sa.custom_actions,
//	    scs.id, scs.condition,
//	    av.id, av.value, av.active, fqns.fqn
func (q *Queries) matchSubjectMappings(ctx context.Context, selectors []string) ([]matchSubjectMappingsRow, error) {
	rows, err := q.db.Query(ctx, matchSubjectMappings, selectors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []matchSubjectMappingsRow
	for rows.Next() {
		var i matchSubjectMappingsRow
		if err := rows.Scan(
			&i.ID,
			&i.StandardActions,
			&i.CustomActions,
			&i.SubjectConditionSet,
			&i.AttributeValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubjectConditionSet = `-- name: updateSubjectConditionSet :execrows
UPDATE subject_condition_set
SET
    condition = COALESCE($2, condition),
    metadata = COALESCE($3, metadata)
WHERE id = $1
`

type updateSubjectConditionSetParams struct {
	ID        string `json:"id"`
	Condition []byte `json:"condition"`
	Metadata  []byte `json:"metadata"`
}

// updateSubjectConditionSet
//
//	UPDATE subject_condition_set
//	SET
//	    condition = COALESCE($2, condition),
//	    metadata = COALESCE($3, metadata)
//	WHERE id = $1
func (q *Queries) updateSubjectConditionSet(ctx context.Context, arg updateSubjectConditionSetParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectConditionSet, arg.ID, arg.Condition, arg.Metadata)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSubjectMapping = `-- name: updateSubjectMapping :execrows
WITH
    subject_mapping_update AS (
        UPDATE subject_mappings
        SET
            metadata = COALESCE($1::JSONB, metadata),
            subject_condition_set_id = COALESCE($2::UUID, subject_condition_set_id)
        WHERE id = $3
        RETURNING id
    ),
    -- Delete any actions that are NOT in the new list
    action_delete AS (
        DELETE FROM subject_mapping_actions
        WHERE
            subject_mapping_id = $3
            AND $4::UUID[] IS NOT NULL
            AND action_id NOT IN (SELECT unnest($4::UUID[]))
    ),
    -- Insert actions that are not already related to the mapping
    action_insert AS (
        INSERT INTO
            subject_mapping_actions (subject_mapping_id, action_id)
        SELECT
            $3,
            a
        FROM unnest($4::UUID[]) AS a
        WHERE
            $4::UUID[] IS NOT NULL
            AND NOT EXISTS (
                SELECT 1
                FROM subject_mapping_actions
                WHERE subject_mapping_id = $3 AND action_id = a
            )
    ),
    update_count AS (
        SELECT COUNT(*) AS cnt
        FROM subject_mapping_update
    )
SELECT cnt
FROM update_count
`

type updateSubjectMappingParams struct {
	Metadata              []byte      `json:"metadata"`
	SubjectConditionSetID pgtype.UUID `json:"subject_condition_set_id"`
	ID                    string      `json:"id"`
	ActionIds             []string    `json:"action_ids"`
}

// updateSubjectMapping
//
//	WITH
//	    subject_mapping_update AS (
//	        UPDATE subject_mappings
//	        SET
//	            metadata = COALESCE($1::JSONB, metadata),
//	            subject_condition_set_id = COALESCE($2::UUID, subject_condition_set_id)
//	        WHERE id = $3
//	        RETURNING id
//	    ),
//	    -- Delete any actions that are NOT in the new list
//	    action_delete AS (
//	        DELETE FROM subject_mapping_actions
//	        WHERE
//	            subject_mapping_id = $3
//	            AND $4::UUID[] IS NOT NULL
//	            AND action_id NOT IN (SELECT unnest($4::UUID[]))
//	    ),
//	    -- Insert actions that are not already related to the mapping
//	    action_insert AS (
//	        INSERT INTO
//	            subject_mapping_actions (subject_mapping_id, action_id)
//	        SELECT
//	            $3,
//	            a
//	        FROM unnest($4::UUID[]) AS a
//	        WHERE
//	            $4::UUID[] IS NOT NULL
//	            AND NOT EXISTS (
//	                SELECT 1
//	                FROM subject_mapping_actions
//	                WHERE subject_mapping_id = $3 AND action_id = a
//	            )
//	    ),
//	    update_count AS (
//	        SELECT COUNT(*) AS cnt
//	        FROM subject_mapping_update
//	    )
//	SELECT cnt
//	FROM update_count
func (q *Queries) updateSubjectMapping(ctx context.Context, arg updateSubjectMappingParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateSubjectMapping,
		arg.Metadata,
		arg.SubjectConditionSetID,
		arg.ID,
		arg.ActionIds,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
